[
    {
        "Name": "dtcrowd",
        "Structs": {
            "BoundarySegment": {
                "Name": "BoundarySegment",
                "Code": "type BoundarySegment struct {\n\ts [6]float32 ///\u003c Segment start/end\n\td float32    ///\u003c Distance for pruning.\n}\n",
                "Methods": {}
            },
            "CrowdAgentState": {
                "Name": "CrowdAgentState",
                "Code": "/// The type of navigation mesh polygon the agent is currently traversing.\r\n/// @ingroup crowd\r\ntype CrowdAgentState int\r",
                "Methods": {}
            },
            "DtCrowd": {
                "Name": "DtCrowd",
                "Code": "/// Provides local steering behaviors for a group of agents.\r\n/// @ingroup crowd\r\ntype DtCrowd struct {\r\n\tm_maxAgents    int\r\n\tm_agents       []DtCrowdAgent\r\n\tm_activeAgents []*DtCrowdAgent\r\n\tm_agentAnims   []DtCrowdAgentAnimation\r\n\r\n\tm_pathq DtPathQueue\r\n\r\n\tm_obstacleQueryParams [DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]DtObstacleAvoidanceParams\r\n\tm_obstacleQuery       *DtObstacleAvoidanceQuery\r\n\r\n\tm_grid *DtProximityGrid\r\n\r\n\tm_pathResult    []detour.DtPolyRef\r\n\tm_maxPathResult int\r\n\r\n\tm_agentPlacementHalfExtents [3]float32\r\n\r\n\tm_filters [DT_CROWD_MAX_QUERY_FILTER_TYPE]detour.DtQueryFilter\r\n\r\n\tm_maxAgentRadius float32\r\n\r\n\tm_velocitySampleCount int\r\n\r\n\tm_navquery *detour.DtNavMeshQuery\r\n}\r",
                "Methods": {
                    "AddAgent": {
                        "Name": "AddAgent",
                        "Code": "func (this *DtCrowd) AddAgent(pos []float32, params *DtCrowdAgentParams) int {\r\n\t// Find empty slot.\r\n\tvar idx = -1\r\n\tfor i := 0; i \u003c this.m_maxAgents; i += 1 {\r\n\t\tif !this.m_agents[i].active {\r\n\t\t\tidx = i\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tif idx == -1 {\r\n\t\treturn -1\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\r\n\tthis.UpdateAgentParameters(idx, params)\r\n\r\n\t// Find nearest position on navmesh and place the agent there.\r\n\tvar nearest [3]float32\r\n\tvar ref detour.DtPolyRef\r\n\tdetour.DtVcopy(nearest[:], pos)\r\n\tvar status = this.m_navquery.FindNearestPoly(pos, this.m_agentPlacementHalfExtents[:],\r\n\t\t\u0026this.m_filters[ag.params.queryFilterType], \u0026ref, nearest[:])\r\n\tif detour.DtStatusFailed(status) {\r\n\t\tdetour.DtVcopy(nearest[:], pos)\r\n\t\tref = 0\r\n\t}\r\n\r\n\tag.corridor.Reset(ref, nearest[:])\r\n\tag.boundary.Reset()\r\n\tag.partial = false\r\n\r\n\tag.topologyOptTime = 0\r\n\tag.targetReplanTime = 0\r\n\tag.nneis = 0\r\n\r\n\tdetour.DtVset(ag.dvel[:], 0, 0, 0)\r\n\tdetour.DtVset(ag.nvel[:], 0, 0, 0)\r\n\tdetour.DtVset(ag.vel[:], 0, 0, 0)\r\n\tdetour.DtVcopy(ag.npos[:], nearest[:])\r\n\r\n\tag.desiredSpeed = 0\r\n\r\n\tif ref \u003e 0 {\r\n\t\tag.state = DT_CROWDAGENT_STATE_WALKING\r\n\t} else {\r\n\t\tag.state = DT_CROWDAGENT_STATE_INVALID\r\n\t}\r\n\r\n\tag.active = true\r\n\r\n\treturn idx\r\n}\r"
                    },
                    "AgentGoto": {
                        "Name": "AgentGoto",
                        "Code": "func (this *DtCrowd) AgentGoto(idx int, pos []float32) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\tvar polyRef detour.DtPolyRef\r\n\tvar nearest [3]float32\r\n\tthis.m_navquery.FindNearestPoly(pos, this.m_agentPlacementHalfExtents[:], \u0026this.m_filters[ag.params.queryFilterType], \u0026polyRef, nearest[:])\r\n\r\n\treturn this.RequestMoveTarget(idx, polyRef, nearest[:])\r\n}\r"
                    },
                    "GetActiveAgents": {
                        "Name": "GetActiveAgents",
                        "Code": "func (this *DtCrowd) GetActiveAgents(agents []*DtCrowdAgent, maxAgents int) int {\r\n\tvar n int\r\n\tfor i := 0; i \u003c this.m_maxAgents; i += 1 {\r\n\t\tif !this.m_agents[i].active {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif n \u003c maxAgents {\r\n\t\t\tagents[n] = \u0026this.m_agents[i]\r\n\t\t\tn += 1\r\n\t\t}\r\n\t}\r\n\treturn n\r\n}\r"
                    },
                    "GetAgent": {
                        "Name": "GetAgent",
                        "Code": "func (this *DtCrowd) GetAgent(idx int) *DtCrowdAgent {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn nil\r\n\t}\r\n\treturn \u0026this.m_agents[idx]\r\n}\r"
                    },
                    "GetAgentCount": {
                        "Name": "GetAgentCount",
                        "Code": "func (this *DtCrowd) GetAgentCount() int {\r\n\treturn this.m_maxAgents\r\n}\r"
                    },
                    "GetEditableAgent": {
                        "Name": "GetEditableAgent",
                        "Code": "func (this *DtCrowd) GetEditableAgent(idx int) *DtCrowdAgent {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn nil\r\n\t}\r\n\treturn \u0026this.m_agents[idx]\r\n}\r"
                    },
                    "GetEditableFilter": {
                        "Name": "GetEditableFilter",
                        "Code": "func (this *DtCrowd) GetEditableFilter(i int) *detour.DtQueryFilter {\r\n\tif i \u003e= 0 \u0026\u0026 i \u003c DT_CROWD_MAX_QUERY_FILTER_TYPE {\r\n\t\treturn \u0026this.m_filters[i]\r\n\t}\r\n\treturn nil\r\n}\r"
                    },
                    "GetFilter": {
                        "Name": "GetFilter",
                        "Code": "func (this *DtCrowd) GetFilter(i int) *detour.DtQueryFilter {\r\n\tif i \u003e= 0 \u0026\u0026 i \u003c DT_CROWD_MAX_QUERY_FILTER_TYPE {\r\n\t\treturn \u0026this.m_filters[i]\r\n\t}\r\n\treturn nil\r\n}\r"
                    },
                    "GetGrid": {
                        "Name": "GetGrid",
                        "Code": "func (this *DtCrowd) GetGrid() *DtProximityGrid {\r\n\treturn this.m_grid\r\n}\r"
                    },
                    "GetNavMeshQuery": {
                        "Name": "GetNavMeshQuery",
                        "Code": "func (this *DtCrowd) GetNavMeshQuery() *detour.DtNavMeshQuery {\r\n\treturn this.m_navquery\r\n}\r"
                    },
                    "GetObstacleAvoidanceParams": {
                        "Name": "GetObstacleAvoidanceParams",
                        "Code": "func (this *DtCrowd) GetObstacleAvoidanceParams(idx int) *DtObstacleAvoidanceParams {\r\n\tif idx \u003e= 0 \u0026\u0026 idx \u003c DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS {\r\n\t\treturn \u0026this.m_obstacleQueryParams[idx]\r\n\t}\r\n\treturn nil\r\n}\r"
                    },
                    "GetPathQueue": {
                        "Name": "GetPathQueue",
                        "Code": "func (this *DtCrowd) GetPathQueue() *DtPathQueue {\r\n\treturn \u0026this.m_pathq\r\n}\r"
                    },
                    "GetQueryExtents": {
                        "Name": "GetQueryExtents",
                        "Code": "func (this *DtCrowd) GetQueryExtents() []float32 {\r\n\treturn this.m_agentPlacementHalfExtents[:]\r\n}\r"
                    },
                    "GetQueryHalfExtents": {
                        "Name": "GetQueryHalfExtents",
                        "Code": "func (this *DtCrowd) GetQueryHalfExtents() []float32 {\r\n\treturn this.m_agentPlacementHalfExtents[:]\r\n}\r"
                    },
                    "GetVelocitySampleCount": {
                        "Name": "GetVelocitySampleCount",
                        "Code": "func (this *DtCrowd) GetVelocitySampleCount() int {\r\n\treturn this.m_velocitySampleCount\r\n}\r"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtCrowd) Init(maxAgents int, maxAgentRadius float32, nav *detour.DtNavMesh) bool {\r\n\tthis.purge()\r\n\r\n\tthis.m_maxAgents = maxAgents\r\n\tthis.m_maxAgentRadius = maxAgentRadius\r\n\r\n\t// Larger than agent radius because it is also used for agent recovery.\r\n\tdetour.DtVset(this.m_agentPlacementHalfExtents[:], this.m_maxAgentRadius*2, this.m_maxAgentRadius*1.5, this.m_maxAgentRadius*2)\r\n\r\n\tthis.m_grid = DtAllocProximityGrid()\r\n\tif !this.m_grid.init(this.m_maxAgents*4, maxAgentRadius*3) {\r\n\t\treturn false\r\n\t}\r\n\r\n\tthis.m_obstacleQuery = DtAllocObstacleAvoidanceQuery()\r\n\tif !this.m_obstacleQuery.init(6, 8) {\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Init obstacle query params.\r\n\tfor i := 0; i \u003c DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS; i += 1 {\r\n\t\tvar params = \u0026this.m_obstacleQueryParams[i]\r\n\t\tparams.velBias = 0.4\r\n\t\tparams.weightDesVel = 2.0\r\n\t\tparams.weightCurVel = 0.75\r\n\t\tparams.weightSide = 0.75\r\n\t\tparams.weightToi = 2.5\r\n\t\tparams.horizTime = 2.5\r\n\t\tparams.gridSize = 33\r\n\t\tparams.adaptiveDivs = 7\r\n\t\tparams.adaptiveRings = 2\r\n\t\tparams.adaptiveDepth = 5\r\n\t}\r\n\r\n\t// Allocate temp buffer for merging paths.\r\n\tthis.m_maxPathResult = 256\r\n\tthis.m_pathResult = make([]detour.DtPolyRef, this.m_maxPathResult)\r\n\r\n\tif !this.m_pathq.Init(this.m_maxPathResult, MAX_PATHQUEUE_NODES, nav) {\r\n\t\treturn false\r\n\t}\r\n\r\n\tthis.m_agents = make([]DtCrowdAgent, this.m_maxAgents)\r\n\tthis.m_activeAgents = make([]*DtCrowdAgent, this.m_maxAgents)\r\n\tthis.m_agentAnims = make([]DtCrowdAgentAnimation, this.m_maxAgents)\r\n\r\n\tfor i := 0; i \u003c this.m_maxAgents; i += 1 {\r\n\t\tthis.m_agents[i].active = false\r\n\t\tif !this.m_agents[i].corridor.Init(this.m_maxPathResult) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c this.m_maxAgents; i += 1 {\r\n\t\tthis.m_agentAnims[i].active = false\r\n\t}\r\n\r\n\t// The navquery is mostly used for local searches, no need for large node pool.\r\n\tthis.m_navquery = detour.DtAllocNavMeshQuery()\r\n\tif detour.DtStatusFailed(this.m_navquery.Init(nav, MAX_COMMON_NODES)) {\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn true\r\n}\r"
                    },
                    "RemoveAgent": {
                        "Name": "RemoveAgent",
                        "Code": "func (this *DtCrowd) RemoveAgent(idx int) {\r\n\tif idx \u003e= 0 \u0026\u0026 idx \u003c this.m_maxAgents {\r\n\t\tthis.m_agents[idx].active = false\r\n\t}\r\n}\r"
                    },
                    "RequestMoveTarget": {
                        "Name": "RequestMoveTarget",
                        "Code": "func (this *DtCrowd) RequestMoveTarget(idx int, ref detour.DtPolyRef, pos []float32) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\tif ref \u003c= 0 {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\r\n\t// Initialize request.\r\n\tag.targetRef = ref\r\n\tdetour.DtVcopy(ag.targetPos[:], pos)\r\n\tag.targetPathqRef = DT_PATHQ_INVALID\r\n\tag.targetReplan = false\r\n\tif ag.targetRef \u003e 0 {\r\n\t\tag.targetState = DT_CROWDAGENT_TARGET_REQUESTING\r\n\t} else {\r\n\t\tag.targetState = DT_CROWDAGENT_TARGET_FAILED\r\n\t}\r\n\r\n\treturn true\r\n}\r"
                    },
                    "RequestMoveVelocity": {
                        "Name": "RequestMoveVelocity",
                        "Code": "func (this *DtCrowd) RequestMoveVelocity(idx int, vel []float32) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\t// Initialize request.\r\n\tag.targetRef = 0\r\n\tdetour.DtVcopy(ag.targetPos[:], vel)\r\n\tag.targetPathqRef = DT_PATHQ_INVALID\r\n\tag.targetReplan = false\r\n\tag.targetState = DT_CROWDAGENT_TARGET_VELOCITY\r\n\r\n\treturn true\r\n}\r"
                    },
                    "ResetMoveTargetIdx": {
                        "Name": "ResetMoveTargetIdx",
                        "Code": "func (this *DtCrowd) ResetMoveTargetIdx(idx int) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\t// Initialize request.\r\n\tag.targetRef = 0\r\n\tdetour.DtVset(ag.targetPos[:], 0, 0, 0)\r\n\tdetour.DtVset(ag.dvel[:], 0, 0, 0)\r\n\tag.targetPathqRef = DT_PATHQ_INVALID\r\n\tag.targetReplan = false\r\n\tag.targetState = DT_CROWDAGENT_TARGET_NONE\r\n\r\n\treturn true\r\n}\r"
                    },
                    "SetObstacleAvoidanceParams": {
                        "Name": "SetObstacleAvoidanceParams",
                        "Code": "func (this *DtCrowd) SetObstacleAvoidanceParams(idx int, params *DtObstacleAvoidanceParams) {\r\n\tif idx \u003e= 0 \u0026\u0026 idx \u003c= DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS {\r\n\t\tthis.m_obstacleQueryParams[idx] = *params\r\n\t}\r\n}\r"
                    },
                    "TeleportAgent": {
                        "Name": "TeleportAgent",
                        "Code": "func (this *DtCrowd) TeleportAgent(idx int, des []float32) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\r\n\tvar polyRef detour.DtPolyRef\r\n\tvar nearest [3]float32\r\n\tthis.m_navquery.FindNearestPoly(des, this.m_agentPlacementHalfExtents[:], \u0026this.m_filters[ag.params.queryFilterType], \u0026polyRef, nearest[:])\r\n\r\n\tag.corridor.Reset(polyRef, nearest[:])\r\n\tag.boundary.Reset()\r\n\tag.partial = false\r\n\r\n\tag.topologyOptTime = 0\r\n\tag.targetReplanTime = 0\r\n\tag.nneis = 0\r\n\r\n\tdetour.DtVset(ag.dvel[:], 0, 0, 0)\r\n\tdetour.DtVset(ag.nvel[:], 0, 0, 0)\r\n\tdetour.DtVset(ag.vel[:], 0, 0, 0)\r\n\tdetour.DtVcopy(ag.npos[:], nearest[:])\r\n\r\n\tag.desiredSpeed = 0\r\n\r\n\tif polyRef \u003e 0 {\r\n\t\tag.state = DT_CROWDAGENT_STATE_WALKING\r\n\t} else {\r\n\t\tag.state = DT_CROWDAGENT_STATE_INVALID\r\n\t}\r\n\r\n\tag.targetState = DT_CROWDAGENT_TARGET_NONE\r\n\treturn true\r\n}\r"
                    },
                    "Update": {
                        "Name": "Update",
                        "Code": "func (this *DtCrowd) Update(dt float32, debug *DtCrowdAgentDebugInfo) {\r\n\tthis.m_velocitySampleCount = 0\r\n\r\n\tvar debugIdx = -1\r\n\tif debug != nil {\r\n\t\tdebugIdx = debug.idx\r\n\t}\r\n\r\n\tvar agents = this.m_activeAgents\r\n\tvar nagents = this.GetActiveAgents(agents, this.m_maxAgents)\r\n\r\n\tthis.checkPathValidity(agents, nagents, dt)\r\n\r\n\tthis.updateMoveRequest(dt)\r\n\r\n\tthis.updateTopologyOptimization(agents, nagents, dt)\r\n\r\n\tthis.m_grid.clear()\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tvar p = ag.npos[0:]\r\n\t\tvar r = ag.params.radius\r\n\t\tthis.m_grid.addItem(uint16(i), p[0]-r, p[2]-r, p[0]+r, p[2]+r)\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar updateThr = ag.params.collisionQueryRange * 0.25\r\n\t\tif detour.DtVdist2DSqr(ag.npos[:], ag.boundary.GetCenter()) \u003e detour.DtSqrFloat32(updateThr) ||\r\n\t\t\t!ag.boundary.IsValid(this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType]) {\r\n\t\t\tag.boundary.Update(ag.corridor.GetFirstPoly(), ag.npos[:], ag.params.collisionQueryRange,\r\n\t\t\t\tthis.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\t\t}\r\n\r\n\t\tag.nneis = getNeighbours(ag.npos[:], ag.params.height, ag.params.collisionQueryRange,\r\n\t\t\tag, ag.neis[:], DT_CROWDAGENT_MAX_NEIGHBOURS,\r\n\t\t\tagents, nagents, this.m_grid)\r\n\t\tfor j := 0; j \u003c ag.nneis; j += 1 {\r\n\t\t\tag.neis[j].idx = this.getAgentIndex(agents[ag.neis[j].idx])\r\n\t\t}\r\n\t}\r\n\r\n\t// Find next corner to steer to.\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tag.ncorners = ag.corridor.FindCorners(ag.cornerVerts[:], ag.cornerFlags[:], ag.cornerPolys[:],\r\n\t\t\tDT_CROWDAGENT_MAX_CORNERS, this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\r\n\t\tif (ag.params.updateFlags\u0026DT_CROWD_OPTIMIZE_VIS \u003e 0) \u0026\u0026 ag.ncorners \u003e 0 {\r\n\t\t\tvar target = ag.cornerVerts[detour.DtMinInt(1, ag.ncorners-1)*3:]\r\n\t\t\tag.corridor.OptimizePathVisibility(target, ag.params.pathOptimizationRange, this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\r\n\t\t\tif debugIdx == i {\r\n\t\t\t\tdetour.DtVcopy(debug.optStart[:], ag.corridor.GetPos())\r\n\t\t\t\tdetour.DtVcopy(debug.optEnd[:], target)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif debugIdx == i {\r\n\t\t\t\tdetour.DtVset(debug.optStart[:], 0, 0, 0)\r\n\t\t\t\tdetour.DtVset(debug.optEnd[:], 0, 0, 0)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar triggerRadius = ag.params.radius * 2.25\r\n\t\tif overOffmeshConnection(ag, triggerRadius) {\r\n\t\t\tvar idx = this.getAgentIndex(ag)\r\n\t\t\tvar anim = \u0026this.m_agentAnims[idx]\r\n\r\n\t\t\tvar refs [2]detour.DtPolyRef\r\n\t\t\tif ag.corridor.MoveOverOffmeshConnection(ag.cornerPolys[ag.ncorners-1], refs[:], anim.startPos[:], anim.endPos[:], this.m_navquery) {\r\n\t\t\t\tdetour.DtVcopy(anim.initPos[:], ag.npos[:])\r\n\t\t\t\tanim.polyRef = refs[1]\r\n\t\t\t\tanim.active = true\r\n\t\t\t\tanim.t = 0\r\n\t\t\t\tanim.tmax = detour.DtVdist2D(anim.startPos[:], anim.endPos[:]) / ag.params.maxSpeed * 0.5\r\n\r\n\t\t\t\tag.state = DT_CROWDAGENT_STATE_OFFMESH\r\n\t\t\t\tag.ncorners = 0\r\n\t\t\t\tag.nneis = 0\r\n\t\t\t\tcontinue\r\n\t\t\t} else {\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar dvel [3]float32\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tdetour.DtVcopy(dvel[:], ag.targetPos[:])\r\n\t\t\tag.desiredSpeed = detour.DtVlen(ag.targetPos[:])\r\n\t\t} else {\r\n\t\t\tif ag.params.updateFlags\u0026DT_CROWD_ANTICIPATE_TURNS \u003e 0 {\r\n\t\t\t\tcalcSmoothSteerDirection(ag, dvel[:])\r\n\t\t\t} else {\r\n\t\t\t\tcalcStraightSteerDirection(ag, dvel[:])\r\n\t\t\t}\r\n\r\n\t\t\tvar slowDownRadius = ag.params.radius * 2\r\n\t\t\tvar speedScale = getDistanceToGoal(ag, slowDownRadius) / slowDownRadius\r\n\r\n\t\t\tag.desiredSpeed = ag.params.maxSpeed\r\n\t\t\tdetour.DtVscale(dvel[:], dvel[:], ag.desiredSpeed*speedScale)\r\n\t\t}\r\n\r\n\t\tif ag.params.updateFlags\u0026DT_CROWD_SEPARATION \u003e 0 {\r\n\t\t\tvar separationDist = ag.params.collisionQueryRange\r\n\t\t\tvar invSeparationDist = 1.0 / separationDist\r\n\t\t\tvar separationWeight = ag.params.separationWeight\r\n\r\n\t\t\tvar w float32\r\n\t\t\tvar disp [3]float32\r\n\r\n\t\t\tfor j := 0; j \u003c ag.nneis; j += 1 {\r\n\t\t\t\tvar nei = \u0026this.m_agents[ag.neis[j].idx]\r\n\t\t\t\tvar diff [3]float32\r\n\t\t\t\tdetour.DtVsub(diff[:], ag.npos[:], nei.npos[:])\r\n\t\t\t\tdiff[1] = 0\r\n\r\n\t\t\t\tvar distSqr = detour.DtVlenSqr(diff[:])\r\n\t\t\t\tif distSqr \u003c 0.00001 {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif distSqr \u003e detour.DtSqrFloat32(separationDist) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar dist = detour.DtMathSqrtf(distSqr)\r\n\t\t\t\tvar weight = separationWeight * (1 - detour.DtSqrFloat32(dist*invSeparationDist))\r\n\r\n\t\t\t\tdetour.DtVmad(disp[:], disp[:], diff[:], weight/dist)\r\n\t\t\t\tw += 1\r\n\t\t\t}\r\n\r\n\t\t\tif w \u003e 0.0001 {\r\n\t\t\t\tdetour.DtVmad(dvel[:], dvel[:], disp[:], 1/w)\r\n\r\n\t\t\t\tvar speedSqr = detour.DtVlenSqr(dvel[:])\r\n\t\t\t\tvar desiredSqr = detour.DtSqrFloat32(ag.desiredSpeed)\r\n\t\t\t\tif speedSqr \u003e desiredSqr {\r\n\t\t\t\t\tdetour.DtVscale(dvel[:], dvel[:], desiredSqr/speedSqr)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdetour.DtVcopy(ag.dvel[:], dvel[:])\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif ag.params.updateFlags\u0026DT_CROWD_OBSTACLE_AVOIDANCE \u003e 0 {\r\n\t\t\tthis.m_obstacleQuery.reset()\r\n\r\n\t\t\tfor j := 0; j \u003c ag.nneis; j += 1 {\r\n\t\t\t\tvar nei = \u0026this.m_agents[ag.neis[j].idx]\r\n\t\t\t\tthis.m_obstacleQuery.addCircle(nei.npos[:], nei.params.radius, nei.vel[:], nei.dvel[:])\r\n\t\t\t}\r\n\r\n\t\t\tfor j := 0; j \u003c ag.boundary.GetSegmentCount(); j += 1 {\r\n\t\t\t\tvar s = ag.boundary.GetSegment(j)\r\n\t\t\t\tif detour.DtTriArea2D(ag.npos[:], s, s[3:]) \u003c 0 {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tthis.m_obstacleQuery.addSegment(s, s[3:])\r\n\t\t\t}\r\n\r\n\t\t\tvar vod *DtObstacleAvoidanceDebugData\r\n\t\t\tif debugIdx == i {\r\n\t\t\t\tvod = debug.vod\r\n\t\t\t}\r\n\r\n\t\t\tvar adaptive = true\r\n\t\t\tvar ns = 0\r\n\t\t\tvar params = \u0026this.m_obstacleQueryParams[ag.params.obstacleAvoidanceType]\r\n\r\n\t\t\tif adaptive {\r\n\t\t\t\tns = this.m_obstacleQuery.sampleVelocityAdaptive(ag.npos[:], ag.params.radius, ag.desiredSpeed,\r\n\t\t\t\t\tag.vel[:], ag.dvel[:], ag.nvel[:], params, vod)\r\n\t\t\t} else {\r\n\t\t\t\tns = this.m_obstacleQuery.sampleVelocityGrid(ag.npos[:], ag.params.radius, ag.desiredSpeed,\r\n\t\t\t\t\tag.vel[:], ag.dvel[:], ag.nvel[:], params, vod)\r\n\t\t\t}\r\n\t\t\tthis.m_velocitySampleCount += ns\r\n\t\t} else {\r\n\t\t\tdetour.DtVcopy(ag.nvel[:], ag.dvel[:])\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tintegrate(ag, dt)\r\n\t}\r\n\r\n\tconst COLLISION_RESOLVE_FACTOR = 0.7\r\n\r\n\tfor iter := 0; iter \u003c 4; iter += 1 {\r\n\t\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\t\tvar ag = agents[i]\r\n\t\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tvar idx0 = this.getAgentIndex(ag)\r\n\r\n\t\t\tdetour.DtVset(ag.disp[:], 0, 0, 0)\r\n\r\n\t\t\tvar w float32\r\n\t\t\tfor j := 0; j \u003c ag.nneis; j += 1 {\r\n\t\t\t\tvar nei = \u0026this.m_agents[ag.neis[j].idx]\r\n\t\t\t\tvar idx1 = this.getAgentIndex(nei)\r\n\r\n\t\t\t\tvar diff [3]float32\r\n\t\t\t\tdetour.DtVsub(diff[:], ag.npos[:], nei.npos[:])\r\n\t\t\t\tdiff[1] = 0\r\n\r\n\t\t\t\tvar dist = detour.DtVlenSqr(diff[:])\r\n\t\t\t\tif dist \u003e detour.DtSqrFloat32(ag.params.radius+nei.params.radius) {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = detour.DtMathSqrtf(dist)\r\n\t\t\t\tvar pen = (ag.params.radius + nei.params.radius) - dist\r\n\t\t\t\tif dist \u003c 0.0001 {\r\n\t\t\t\t\tif idx0 \u003e idx1 {\r\n\t\t\t\t\t\tdetour.DtVset(diff[:], -ag.dvel[2], 0, ag.dvel[0])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdetour.DtVset(diff[:], ag.dvel[2], 0, -ag.dvel[0])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpen = 0.01\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpen = (1 / dist) * (pen * 0.5) * COLLISION_RESOLVE_FACTOR\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdetour.DtVmad(ag.disp[:], ag.disp[:], diff[:], pen)\r\n\t\t\t\tw += 1\r\n\t\t\t}\r\n\r\n\t\t\tif w \u003e 0.0001 {\r\n\t\t\t\tvar iw = 1 / w\r\n\t\t\t\tdetour.DtVscale(ag.disp[:], ag.disp[:], iw)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\t\tvar ag = agents[i]\r\n\t\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tdetour.DtVadd(ag.npos[:], ag.npos[:], ag.disp[:])\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tag.corridor.MovePosition(ag.npos[:], this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\t\tdetour.DtVcopy(ag.npos[:], ag.corridor.GetPos())\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tag.corridor.Reset(ag.corridor.GetFirstPoly(), ag.npos[:])\r\n\t\t\tag.partial = false\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tvar idx = this.getAgentIndex(ag)\r\n\t\tvar anim = \u0026this.m_agentAnims[idx]\r\n\t\tif !anim.active {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tanim.t += dt\r\n\t\tif anim.t \u003e anim.tmax {\r\n\t\t\tanim.active = false\r\n\t\t\tag.state = DT_CROWDAGENT_STATE_WALKING\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar ta = anim.tmax * 0.15\r\n\t\tvar tb = anim.tmax\r\n\t\tif anim.t \u003c ta {\r\n\t\t\tvar u = tween(anim.t, 0, ta)\r\n\t\t\tdetour.DtVlerp(ag.npos[:], anim.initPos[:], anim.startPos[:], u)\r\n\t\t} else {\r\n\t\t\tvar u = tween(anim.t, ta, tb)\r\n\t\t\tdetour.DtVlerp(ag.npos[:], anim.startPos[:], anim.endPos[:], u)\r\n\t\t}\r\n\r\n\t\tdetour.DtVset(ag.vel[:], 0, 0, 0)\r\n\t\tdetour.DtVset(ag.dvel[:], 0, 0, 0)\r\n\t}\r\n}\r"
                    },
                    "UpdateAgentParameters": {
                        "Name": "UpdateAgentParameters",
                        "Code": "func (this *DtCrowd) UpdateAgentParameters(idx int, params *DtCrowdAgentParams) {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn\r\n\t}\r\n\tthis.m_agents[idx].params = *params\r\n}\r"
                    },
                    "checkPathValidity": {
                        "Name": "checkPathValidity",
                        "Code": "func (this *DtCrowd) checkPathValidity(agents []*DtCrowdAgent, nagents int, dt float32) {\r\n\tconst CHECK_LOOKAHEAD = 10\r\n\tconst TARGET_REPLAN_DELAY = 1.0 // seconds\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tag.targetReplanTime += dt\r\n\r\n\t\tvar replan = false\r\n\r\n\t\tvar idx = this.getAgentIndex(ag)\r\n\t\tvar agentPos [3]float32\r\n\t\tvar agentRef = ag.corridor.GetFirstPoly()\r\n\t\tdetour.DtVcopy(agentPos[:], ag.npos[:])\r\n\t\tif !this.m_navquery.IsValidPolyRef(agentRef, \u0026this.m_filters[ag.params.queryFilterType]) {\r\n\t\t\tvar nearest [3]float32\r\n\t\t\tdetour.DtVcopy(nearest[:], agentPos[:])\r\n\t\t\tagentRef = 0\r\n\t\t\tthis.m_navquery.FindNearestPoly(ag.npos[:], this.m_agentPlacementHalfExtents[:], \u0026this.m_filters[ag.params.queryFilterType], \u0026agentRef, nearest[:])\r\n\t\t\tdetour.DtVcopy(agentPos[:], nearest[:])\r\n\r\n\t\t\tif agentRef \u003c= 0 {\r\n\t\t\t\tag.corridor.Reset(0, agentPos[:])\r\n\t\t\t\tag.partial = false\r\n\t\t\t\tag.boundary.Reset()\r\n\t\t\t\tag.state = DT_CROWDAGENT_STATE_INVALID\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tag.corridor.FixPathStart(agentRef, agentPos[:])\r\n\t\t\t// ag.corridor.trimInvalidPath(agentRef, agentPos[:], this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\t\t\tag.boundary.Reset()\r\n\t\t\tdetour.DtVcopy(ag.npos[:], agentPos[:])\r\n\r\n\t\t\treplan = true\r\n\t\t}\r\n\r\n\t\t// If the agent does not have move target or is controlled by velocity, no need to recover the target nor replan.\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\t// Try to recover move request position.\r\n\t\tif ag.targetState != DT_CROWDAGENT_TARGET_NONE \u0026\u0026 ag.targetState != DT_CROWDAGENT_TARGET_FAILED {\r\n\t\t\tif !this.m_navquery.IsValidPolyRef(ag.targetRef, \u0026this.m_filters[ag.params.queryFilterType]) {\r\n\t\t\t\tvar nearest [3]float32\r\n\t\t\t\tdetour.DtVcopy(nearest[:], ag.targetPos[:])\r\n\t\t\t\tag.targetRef = 0\r\n\t\t\t\tthis.m_navquery.FindNearestPoly(ag.targetPos[:], this.m_agentPlacementHalfExtents[:], \u0026this.m_filters[ag.params.queryFilterType], \u0026ag.targetRef, nearest[:])\r\n\t\t\t\tdetour.DtVcopy(ag.targetPos[:], nearest[:])\r\n\t\t\t\treplan = true\r\n\t\t\t}\r\n\t\t\tif ag.targetRef \u003c= 0 {\r\n\t\t\t\tag.corridor.Reset(agentRef, agentPos[:])\r\n\t\t\t\tag.partial = false\r\n\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_NONE\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif !ag.corridor.IsValid(CHECK_LOOKAHEAD, this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType]) {\r\n\t\t\treplan = true\r\n\t\t}\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_VALID {\r\n\t\t\tif ag.targetReplanTime \u003e TARGET_REPLAN_DELAY \u0026\u0026\r\n\t\t\t\tag.corridor.GetPathCount() \u003c CHECK_LOOKAHEAD \u0026\u0026\r\n\t\t\t\tag.corridor.GetLastPoly() != ag.targetRef {\r\n\t\t\t\treplan = true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif replan {\r\n\t\t\tif ag.targetState != DT_CROWDAGENT_TARGET_NONE {\r\n\t\t\t\tthis.requestMoveTargetReplan(idx, ag.targetRef, ag.targetPos[:])\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r"
                    },
                    "getAgentIndex": {
                        "Name": "getAgentIndex",
                        "Code": "func (this *DtCrowd) getAgentIndex(agent *DtCrowdAgent) int {\r\n\tfor i := range this.m_agents {\r\n\t\tif \u0026this.m_agents[i] == agent {\r\n\t\t\treturn i\r\n\t\t}\r\n\t}\r\n\treturn -1\r\n}\r"
                    },
                    "purge": {
                        "Name": "purge",
                        "Code": "func (this *DtCrowd) purge() {\r\n\tthis.m_agents = nil\r\n\tthis.m_maxAgents = 0\r\n\tthis.m_activeAgents = nil\r\n\tthis.m_agentAnims = nil\r\n\tthis.m_pathResult = nil\r\n\tthis.m_grid = nil\r\n\tthis.m_obstacleQuery = nil\r\n\tthis.m_navquery = nil\r\n}\r"
                    },
                    "requestMoveTargetReplan": {
                        "Name": "requestMoveTargetReplan",
                        "Code": "func (this *DtCrowd) requestMoveTargetReplan(idx int, ref detour.DtPolyRef, pos []float32) bool {\r\n\tif idx \u003c 0 || idx \u003e= this.m_maxAgents {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar ag = \u0026this.m_agents[idx]\r\n\r\n\t// Initialize request.\r\n\tag.targetRef = ref\r\n\tdetour.DtVcopy(ag.targetPos[:], pos)\r\n\tag.targetPathqRef = DT_PATHQ_INVALID\r\n\tag.targetReplan = true\r\n\tif ag.targetRef \u003e 0 {\r\n\t\tag.targetState = DT_CROWDAGENT_TARGET_REQUESTING\r\n\t} else {\r\n\t\tag.targetState = DT_CROWDAGENT_TARGET_FAILED\r\n\t}\r\n\r\n\treturn true\r\n}\r"
                    },
                    "updateMoveRequest": {
                        "Name": "updateMoveRequest",
                        "Code": "func (this *DtCrowd) updateMoveRequest(_ float32) {\r\n\tconst PATH_MAX_AGENTS = 8\r\n\tvar queue = make([]*DtCrowdAgent, PATH_MAX_AGENTS)\r\n\tvar nqueue int\r\n\r\n\tfor i := 0; i \u003c this.m_maxAgents; i += 1 {\r\n\t\tvar ag = \u0026this.m_agents[i]\r\n\t\tif !ag.active {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.state == DT_CROWDAGENT_STATE_INVALID {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_REQUESTING {\r\n\t\t\tvar path = ag.corridor.GetPath()\r\n\t\t\tvar npath = ag.corridor.GetPathCount()\r\n\t\t\tdetour.DtAssert(npath \u003e 0)\r\n\r\n\t\t\tconst MAX_RES = 32\r\n\t\t\tvar reqPos [3]float32\r\n\t\t\tvar reqPath [MAX_RES]detour.DtPolyRef // The path to the request location\r\n\t\t\tvar reqPathCount int\r\n\r\n\t\t\t// Quick search towards the goal.\r\n\t\t\tconst MAX_ITER = 20\r\n\t\t\tvar doneIters int\r\n\t\t\tthis.m_navquery.InitSlicedFindPath(path[0], ag.targetRef, ag.npos[:], ag.targetPos[:], \u0026this.m_filters[ag.params.queryFilterType], 0)\r\n\t\t\tthis.m_navquery.UpdateSlicedFindPath(MAX_ITER, \u0026doneIters)\r\n\r\n\t\t\tvar status detour.DtStatus\r\n\t\t\tif ag.targetReplan {\r\n\t\t\t\tstatus = this.m_navquery.FinalizeSlicedFindPathPartial(path, npath, reqPath[:], \u0026reqPathCount, MAX_RES)\r\n\t\t\t} else {\r\n\t\t\t\tstatus = this.m_navquery.FinalizeSlicedFindPath(reqPath[:], \u0026reqPathCount, MAX_RES)\r\n\t\t\t}\r\n\r\n\t\t\tif !detour.DtStatusFailed(status) \u0026\u0026 reqPathCount \u003e 0 {\r\n\t\t\t\tif reqPath[reqPathCount-1] != ag.targetRef {\r\n\t\t\t\t\tvar posOverPoly bool\r\n\t\t\t\t\tstatus = this.m_navquery.ClosestPointOnPoly(reqPath[reqPathCount-1], ag.targetPos[:], reqPos[:], \u0026posOverPoly)\r\n\t\t\t\t\tif detour.DtStatusFailed(status) {\r\n\t\t\t\t\t\treqPathCount = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdetour.DtVcopy(reqPos[:], ag.targetPos[:])\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treqPathCount = 0\r\n\t\t\t}\r\n\r\n\t\t\tif reqPathCount \u003c= 0 {\r\n\t\t\t\tdetour.DtVcopy(reqPos[:], ag.npos[:])\r\n\t\t\t\treqPath[0] = path[0]\r\n\t\t\t\treqPathCount = 1\r\n\t\t\t}\r\n\r\n\t\t\tag.corridor.SetCorridor(reqPos[:], reqPath[:], reqPathCount)\r\n\t\t\tag.boundary.Reset()\r\n\t\t\tag.partial = false\r\n\r\n\t\t\tif reqPath[reqPathCount-1] == ag.targetRef {\r\n\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_VALID\r\n\t\t\t\tag.targetReplanTime = 0\r\n\t\t\t} else {\r\n\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_WAITING_FOR_QUEUE\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_WAITING_FOR_QUEUE {\r\n\t\t\tnqueue = addToPathQueue(ag, queue, nqueue, PATH_MAX_AGENTS)\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nqueue; i += 1 {\r\n\t\tvar ag = queue[i]\r\n\t\tag.targetPathqRef = this.m_pathq.Request(ag.corridor.GetLastPoly(), ag.targetRef,\r\n\t\t\tag.corridor.GetTarget(), ag.targetPos[:], \u0026this.m_filters[ag.params.queryFilterType])\r\n\t\tif ag.targetPathqRef != DT_PATHQ_INVALID {\r\n\t\t\tag.targetState = DT_CROWDAGENT_TARGET_WAITING_FOR_PATH\r\n\t\t}\r\n\t}\r\n\r\n\tthis.m_pathq.Update(MAX_ITERS_PER_UPDATE)\r\n\r\n\tvar status detour.DtStatus\r\n\tfor i := 0; i \u003c this.m_maxAgents; i++ {\r\n\t\tvar ag = \u0026this.m_agents[i]\r\n\t\tif !ag.active {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_WAITING_FOR_PATH {\r\n\t\t\t// Poll path queue.\r\n\t\t\tstatus = this.m_pathq.GetRequestStatus(ag.targetPathqRef)\r\n\t\t\tif detour.DtStatusFailed(status) {\r\n\t\t\t\tag.targetPathqRef = DT_PATHQ_INVALID\r\n\t\t\t\tif ag.targetRef \u003e 0 {\r\n\t\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_REQUESTING\r\n\t\t\t\t} else {\r\n\t\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_FAILED\r\n\t\t\t\t}\r\n\t\t\t\tag.targetReplanTime = 0\r\n\t\t\t} else if detour.DtStatusSucceed(status) {\r\n\t\t\t\tvar path = ag.corridor.GetPath()\r\n\t\t\t\tvar npath = ag.corridor.GetPathCount()\r\n\t\t\t\tdetour.DtAssert(npath \u003e 0)\r\n\r\n\t\t\t\tvar targetPos [3]float32\r\n\t\t\t\tdetour.DtVcopy(targetPos[:], ag.targetPos[:])\r\n\r\n\t\t\t\tvar res = this.m_pathResult\r\n\t\t\t\tvar valid = true\r\n\t\t\t\tvar nres int\r\n\t\t\t\tstatus = this.m_pathq.GetPathResult(ag.targetPathqRef, res, \u0026nres, this.m_maxPathResult)\r\n\t\t\t\tif detour.DtStatusFailed(status) || nres \u003c= 0 {\r\n\t\t\t\t\tvalid = false\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif detour.DtStatusDetail(status, detour.DT_PARTIAL_RESULT) {\r\n\t\t\t\t\tag.partial = true\r\n\t\t\t\t} else {\r\n\t\t\t\t\tag.partial = false\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Merge result and existing path.\r\n\t\t\t\t// The agent might have moved whilst the request is\r\n\t\t\t\t// being processed, so the path may have changed.\r\n\t\t\t\t// We assume that the end of the path is at the same location\r\n\t\t\t\t// where the request was issued.\r\n\r\n\t\t\t\t// The last ref in the old path should be the same as\r\n\t\t\t\t// the location where the request was issued..\r\n\t\t\t\tif valid \u0026\u0026 path[npath-1] != res[0] {\r\n\t\t\t\t\tvalid = false\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif valid {\r\n\t\t\t\t\tif npath \u003e 1 {\r\n\t\t\t\t\t\tif (npath-1)+nres \u003e this.m_maxPathResult {\r\n\t\t\t\t\t\t\tnres = this.m_maxPathResult - (npath - 1)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcopy(res[npath-1:], res[:nres])\r\n\t\t\t\t\t\tcopy(res, path[:npath-1])\r\n\t\t\t\t\t\tnres += npath - 1\r\n\r\n\t\t\t\t\t\tfor j := 0; j \u003c nres; j += 1 {\r\n\t\t\t\t\t\t\tif j-1 \u003e= 0 \u0026\u0026 j+1 \u003c nres {\r\n\t\t\t\t\t\t\t\tif res[j-1] == res[j+1] {\r\n\t\t\t\t\t\t\t\t\tcopy(res[j-1:], res[j+1:nres])\r\n\t\t\t\t\t\t\t\t\tnres -= 2\r\n\t\t\t\t\t\t\t\t\tj -= 2\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif res[nres-1] != ag.targetRef {\r\n\t\t\t\t\t\tvar nearest [3]float32\r\n\t\t\t\t\t\tvar posOverPoly bool\r\n\t\t\t\t\t\tstatus = this.m_navquery.ClosestPointOnPoly(res[nres-1], targetPos[:], nearest[:], \u0026posOverPoly)\r\n\t\t\t\t\t\tif detour.DtStatusSucceed(status) {\r\n\t\t\t\t\t\t\tdetour.DtVcopy(targetPos[:], nearest[:])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalid = false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif valid {\r\n\t\t\t\t\tag.corridor.SetCorridor(targetPos[:], res, nres)\r\n\t\t\t\t\tag.boundary.Reset()\r\n\t\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_VALID\r\n\t\t\t\t} else {\r\n\t\t\t\t\tag.targetState = DT_CROWDAGENT_TARGET_FAILED\r\n\t\t\t\t}\r\n\r\n\t\t\t\tag.targetReplanTime = 0\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r"
                    },
                    "updateTopologyOptimization": {
                        "Name": "updateTopologyOptimization",
                        "Code": "func (this *DtCrowd) updateTopologyOptimization(agents []*DtCrowdAgent, nagents int, dt float32) {\r\n\tif nagents \u003c= 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst OPT_TIME_THR = 0.5 // seconds\r\n\tconst OPT_MAX_AGENTS = 1\r\n\r\n\tvar queue [OPT_MAX_AGENTS]*DtCrowdAgent\r\n\tvar nqueue int\r\n\r\n\tfor i := 0; i \u003c nagents; i += 1 {\r\n\t\tvar ag = agents[i]\r\n\t\tif ag.state != DT_CROWDAGENT_STATE_WALKING {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.targetState == DT_CROWDAGENT_TARGET_NONE || ag.targetState == DT_CROWDAGENT_TARGET_VELOCITY {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ag.params.updateFlags\u0026DT_CROWD_OPTIMIZE_TOPO == 0 {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tag.topologyOptTime += dt\r\n\t\tif ag.topologyOptTime \u003e= OPT_TIME_THR {\r\n\t\t\tnqueue = addToOptQueue(ag, queue[:], nqueue, OPT_MAX_AGENTS)\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := 0; i \u003c nqueue; i += 1 {\r\n\t\tvar ag = queue[i]\r\n\t\tag.corridor.OptimizePathTopology(this.m_navquery, \u0026this.m_filters[ag.params.queryFilterType])\r\n\t\tag.topologyOptTime = 0\r\n\t}\r\n}\r"
                    }
                }
            },
            "DtCrowdAgent": {
                "Name": "DtCrowdAgent",
                "Code": "/// Represents an agent managed by a #dtCrowd object.\r\n/// @ingroup crowd\r\ntype DtCrowdAgent struct {\r\n\t/// True if the agent is active, false if the agent is in an unused slot in the agent pool.\r\n\tactive bool\r\n\r\n\t/// The type of mesh polygon the agent is traversing. (See: #CrowdAgentState)\r\n\tstate CrowdAgentState\r\n\r\n\t/// True if the agent has valid path (targetState == DT_CROWDAGENT_TARGET_VALID) and the path does not lead to the requested position, else false.\r\n\tpartial bool\r\n\r\n\t/// The path corridor the agent is using.\r\n\tcorridor DtPathCorridor\r\n\r\n\t/// The local boundary data for the agent.\r\n\tboundary DtLocalBoundary\r\n\r\n\t/// Time since the agent's path corridor was optimized.\r\n\ttopologyOptTime float32\r\n\r\n\t/// The known neighbors of the agent.\r\n\tneis [DT_CROWDAGENT_MAX_NEIGHBOURS]DtCrowdNeighbour\r\n\r\n\t/// The number of neighbors.\r\n\tnneis int\r\n\r\n\t/// The desired speed.\r\n\tdesiredSpeed float32\r\n\r\n\tnpos [3]float32 ///\u003c The current agent position. [(x, y, z)]\r\n\tdisp [3]float32 ///\u003c A temporary value used to accumulate agent displacement during iterative collision resolution. [(x, y, z)]\r\n\tdvel [3]float32 ///\u003c The desired velocity of the agent. Based on the current path, calculated from scratch each frame. [(x, y, z)]\r\n\tnvel [3]float32 ///\u003c The desired velocity adjusted by obstacle avoidance, calculated from scratch each frame. [(x, y, z)]\r\n\tvel  [3]float32 ///\u003c The actual velocity of the agent. The change from nvel -\u003e vel is constrained by max acceleration. [(x, y, z)]\r\n\r\n\t/// The agent's configuration parameters.\r\n\tparams DtCrowdAgentParams\r\n\r\n\t/// The local path corridor corners for the agent. (Staight path.) [(x, y, z) * #ncorners]\r\n\tcornerVerts [DT_CROWDAGENT_MAX_CORNERS * 3]float32\r\n\r\n\t/// The local path corridor corner flags. (See: #dtStraightPathFlags) [(flags) * #ncorners]\r\n\tcornerFlags [DT_CROWDAGENT_MAX_CORNERS]detour.DtStraightPathFlags\r\n\r\n\t/// The reference id of the polygon being entered at the corner. [(polyRef) * #ncorners]\r\n\tcornerPolys [DT_CROWDAGENT_MAX_CORNERS]detour.DtPolyRef\r\n\r\n\t/// The number of corners.\r\n\tncorners int\r\n\r\n\ttargetState      MoveRequestState ///\u003c State of the movement request.\r\n\ttargetRef        detour.DtPolyRef ///\u003c Target polyref of the movement request.\r\n\ttargetPos        [3]float32       ///\u003c Target position of the movement request (or velocity in case of DT_CROWDAGENT_TARGET_VELOCITY).\r\n\ttargetPathqRef   DtPathQueueRef   ///\u003c Path finder ref.\r\n\ttargetReplan     bool             ///\u003c Flag indicating that the current path is being replanned.\r\n\ttargetReplanTime float32          /// \u003cTime since the agent's target was replanned.\r\n}\r",
                "Methods": {
                    "GetCurrentPos": {
                        "Name": "GetCurrentPos",
                        "Code": "func (agent *DtCrowdAgent) GetCurrentPos() []float32 {\r\n\treturn agent.npos[:]\r\n}\r"
                    },
                    "GetState": {
                        "Name": "GetState",
                        "Code": "func (agent *DtCrowdAgent) GetState() CrowdAgentState {\r\n\treturn agent.state\r\n}\r"
                    }
                }
            },
            "DtCrowdAgentAnimation": {
                "Name": "DtCrowdAgentAnimation",
                "Code": "type DtCrowdAgentAnimation struct {\r\n\tactive   bool\r\n\tinitPos  [3]float32\r\n\tstartPos [3]float32\r\n\tendPos   [3]float32\r\n\tpolyRef  detour.DtPolyRef\r\n\tt        float32\r\n\ttmax     float32\r\n}\r",
                "Methods": {}
            },
            "DtCrowdAgentDebugInfo": {
                "Name": "DtCrowdAgentDebugInfo",
                "Code": "type DtCrowdAgentDebugInfo struct {\r\n\tidx      int\r\n\toptStart [3]float32\r\n\toptEnd   [3]float32\r\n\tvod      *DtObstacleAvoidanceDebugData\r\n}\r",
                "Methods": {}
            },
            "DtCrowdAgentParams": {
                "Name": "DtCrowdAgentParams",
                "Code": "/// Configuration parameters for a crowd agent.\r\n/// @ingroup crowd\r\ntype DtCrowdAgentParams struct {\r\n\tradius          float32 ///\u003c Agent radius. [Limit: \u003e= 0]\r\n\theight          float32 ///\u003c Agent height. [Limit: \u003e 0]\r\n\tmaxAcceleration float32 ///\u003c Maximum allowed acceleration. [Limit: \u003e= 0]\r\n\tmaxSpeed        float32 ///\u003c Maximum allowed speed. [Limit: \u003e= 0]\r\n\r\n\t/// Defines how close a collision element must be before it is considered for steering behaviors. [Limits: \u003e 0]\r\n\tcollisionQueryRange float32\r\n\r\n\tpathOptimizationRange float32 ///\u003c The path visibility optimization range. [Limit: \u003e 0]\r\n\r\n\t/// How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: \u003e= 0]\r\n\tseparationWeight float32\r\n\r\n\t/// Flags that impact steering behavior. (See: #UpdateFlags)\r\n\tupdateFlags UpdateFlags\r\n\r\n\t/// The index of the avoidance configuration to use for the agent.\r\n\t/// [Limits: 0 \u003c= value \u003c= #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]\r\n\tobstacleAvoidanceType uint8\r\n\r\n\t/// The index of the query filter used by this agent.\r\n\tqueryFilterType uint8\r\n\r\n\t/// User defined data attached to the agent.\r\n\tuserData []byte\r\n}\r",
                "Methods": {
                    "SetCollisionQueryRange": {
                        "Name": "SetCollisionQueryRange",
                        "Code": "func (p *DtCrowdAgentParams) SetCollisionQueryRange(collisionQueryRange float32) *DtCrowdAgentParams {\r\n\tp.collisionQueryRange = collisionQueryRange\r\n\treturn p\r\n}\r"
                    },
                    "SetHeight": {
                        "Name": "SetHeight",
                        "Code": "func (p *DtCrowdAgentParams) SetHeight(height float32) *DtCrowdAgentParams {\r\n\tp.height = height\r\n\treturn p\r\n}\r"
                    },
                    "SetMaxAcceleration": {
                        "Name": "SetMaxAcceleration",
                        "Code": "func (p *DtCrowdAgentParams) SetMaxAcceleration(maxAcceleration float32) *DtCrowdAgentParams {\r\n\tp.maxAcceleration = maxAcceleration\r\n\treturn p\r\n}\r"
                    },
                    "SetMaxSpeed": {
                        "Name": "SetMaxSpeed",
                        "Code": "func (p *DtCrowdAgentParams) SetMaxSpeed(maxSpeed float32) *DtCrowdAgentParams {\r\n\tp.maxSpeed = maxSpeed\r\n\treturn p\r\n}\r"
                    },
                    "SetPathOptimizationRange": {
                        "Name": "SetPathOptimizationRange",
                        "Code": "func (p *DtCrowdAgentParams) SetPathOptimizationRange(pathOptimizationRange float32) *DtCrowdAgentParams {\r\n\tp.pathOptimizationRange = pathOptimizationRange\r\n\treturn p\r\n}\r"
                    },
                    "SetRadius": {
                        "Name": "SetRadius",
                        "Code": "func (p *DtCrowdAgentParams) SetRadius(radius float32) *DtCrowdAgentParams {\r\n\tp.radius = radius\r\n\treturn p\r\n}\r"
                    },
                    "SetSeparationWeight": {
                        "Name": "SetSeparationWeight",
                        "Code": "func (p *DtCrowdAgentParams) SetSeparationWeight(separationWeight float32) *DtCrowdAgentParams {\r\n\tp.separationWeight = separationWeight\r\n\treturn p\r\n}\r"
                    },
                    "SetUpdateFlags": {
                        "Name": "SetUpdateFlags",
                        "Code": "func (p *DtCrowdAgentParams) SetUpdateFlags(updateFlags UpdateFlags) *DtCrowdAgentParams {\r\n\tp.updateFlags = updateFlags\r\n\treturn p\r\n}\r"
                    }
                }
            },
            "DtCrowdNeighbour": {
                "Name": "DtCrowdNeighbour",
                "Code": "/// Provides neighbor data for agents managed by the crowd.\r\n/// @ingroup crowd\r\n/// @see dtCrowdAgent::neis, dtCrowd\r\ntype DtCrowdNeighbour struct {\r\n\tidx  int     ///\u003c The index of the neighbor in the crowd.\r\n\tdist float32 ///\u003c The distance between the current agent and the neighbor.\r\n}\r",
                "Methods": {}
            },
            "DtLocalBoundary": {
                "Name": "DtLocalBoundary",
                "Code": "type DtLocalBoundary struct {\n\tm_center [3]float32\n\tm_segs   [MAX_LOCAL_SEGS]BoundarySegment\n\tm_nsegs  int\n\n\tm_polys  [MAX_LOCAL_POLYS]detour.DtPolyRef\n\tm_npolys int\n}\n",
                "Methods": {
                    "GetCenter": {
                        "Name": "GetCenter",
                        "Code": "func (this *DtLocalBoundary) GetCenter() []float32 {\n\treturn this.m_center[:]\n}\n"
                    },
                    "GetSegment": {
                        "Name": "GetSegment",
                        "Code": "func (this *DtLocalBoundary) GetSegment(i int) []float32 {\n\treturn this.m_segs[i].s[:]\n}\n"
                    },
                    "GetSegmentCount": {
                        "Name": "GetSegmentCount",
                        "Code": "func (this *DtLocalBoundary) GetSegmentCount() int {\n\treturn this.m_nsegs\n}\n"
                    },
                    "IsValid": {
                        "Name": "IsValid",
                        "Code": "func (this *DtLocalBoundary) IsValid(navquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\n\tif this.m_npolys \u003c= 0 {\n\t\treturn false\n\t}\n\n\tfor i := 0; i \u003c this.m_npolys; i += 1 {\n\t\tif !navquery.IsValidPolyRef(this.m_polys[i], filter) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
                    },
                    "Reset": {
                        "Name": "Reset",
                        "Code": "func (this *DtLocalBoundary) Reset() {\n\tdetour.DtVset(this.m_center[:], math.MaxFloat32, math.MaxFloat32, math.MaxFloat32)\n\tthis.m_npolys = 0\n\tthis.m_nsegs = 0\n}\n"
                    },
                    "Update": {
                        "Name": "Update",
                        "Code": "func (this *DtLocalBoundary) Update(ref detour.DtPolyRef, pos []float32, collisionQueryRange float32,\n\tnavquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) {\n\n\tconst MAX_SEGS_PER_POLY int32 = detour.DT_VERTS_PER_POLYGON * 3\n\n\tif ref \u003c= 0 {\n\t\tthis.Reset()\n\t\treturn\n\t}\n\n\tdetour.DtVcopy(this.m_center[:], pos)\n\n\tnavquery.FindLocalNeighbourhood(ref, pos, collisionQueryRange, filter, this.m_polys[:], nil,\n\t\t\u0026this.m_npolys, int(MAX_LOCAL_POLYS))\n\n\tthis.m_nsegs = 0\n\n\tvar segs [MAX_SEGS_PER_POLY * 6]float32\n\tvar nsegs int\n\tfor j := 0; j \u003c this.m_npolys; j += 1 {\n\t\tnavquery.GetPolyWallSegments(this.m_polys[j], filter, segs[:], nil, \u0026nsegs, int(MAX_SEGS_PER_POLY))\n\t\tfor k := 0; k \u003c nsegs; k += 1 {\n\t\t\ts := segs[k*6:]\n\t\t\tvar tseg float32\n\t\t\tvar distSqr = detour.DtDistancePtSegSqr2D(pos, s, s[3:], \u0026tseg)\n\t\t\tif distSqr \u003e detour.DtSqrFloat32(collisionQueryRange) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tthis.addSegment(distSqr, s)\n\t\t}\n\t}\n}\n"
                    },
                    "addSegment": {
                        "Name": "addSegment",
                        "Code": "func (this *DtLocalBoundary) addSegment(dist float32, s []float32) {\n\t// Insert neighbour based on the distance.\n\tvar seg *BoundarySegment\n\tif this.m_nsegs \u003c= 0 {\n\t\t// First, trivial accept.\n\t\tseg = \u0026this.m_segs[0]\n\t} else if dist \u003e= this.m_segs[this.m_nsegs-1].d {\n\t\t// Further than the last segment, skip.\n\t\tif this.m_nsegs \u003e= MAX_LOCAL_SEGS {\n\t\t\treturn\n\t\t}\n\t\t// Last, trivial accept.\n\t\tseg = \u0026this.m_segs[this.m_nsegs]\n\t} else {\n\t\t// Insert inbetween.\n\t\tvar i int\n\t\tfor i = 0; i \u003c this.m_nsegs; i += 1 {\n\t\t\tif dist \u003c= this.m_segs[i].d {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\ttgt := i + 1\n\t\tn := detour.DtMinInt(this.m_nsegs-i, MAX_LOCAL_SEGS-tgt)\n\t\tdetour.DtAssert(tgt+n \u003c= MAX_LOCAL_SEGS)\n\t\tif n \u003e 0 {\n\t\t\tcopy(this.m_segs[tgt:], this.m_segs[i:i+n])\n\t\t\t//memmove(\u0026m_segs[tgt], \u0026m_segs[i], sizeof(Segment)*n);\n\t\t}\n\n\t\tseg = \u0026this.m_segs[i]\n\t}\n\n\tseg.d = dist\n\tcopy(seg.s[0:], s[:6])\n\n\tif this.m_nsegs \u003c MAX_LOCAL_SEGS {\n\t\tthis.m_nsegs += 1\n\t}\n\n}\n"
                    }
                }
            },
            "DtObstacleAvoidanceDebugData": {
                "Name": "DtObstacleAvoidanceDebugData",
                "Code": "type DtObstacleAvoidanceDebugData struct {\n\tm_nsamples   int\n\tm_maxSamples int\n\tm_vel        []float32\n\tm_ssize      []float32\n\tm_pen        []float32\n\tm_vpen       []float32\n\tm_vcpen      []float32\n\tm_spen       []float32\n\tm_tpen       []float32\n}\n",
                "Methods": {
                    "addSample": {
                        "Name": "addSample",
                        "Code": "func (this *DtObstacleAvoidanceDebugData) addSample(vel []float32, ssize, pen, vpen, vcpen, spen, tpen float32) {\n\tif this.m_nsamples \u003e= this.m_maxSamples {\n\t\treturn\n\t}\n\tdetour.DtAssert(len(this.m_vel) \u003e 0)\n\tdetour.DtAssert(len(this.m_ssize) \u003e 0)\n\tdetour.DtAssert(len(this.m_pen) \u003e 0)\n\tdetour.DtAssert(len(this.m_vpen) \u003e 0)\n\tdetour.DtAssert(len(this.m_vcpen) \u003e 0)\n\tdetour.DtAssert(len(this.m_spen) \u003e 0)\n\tdetour.DtAssert(len(this.m_tpen) \u003e 0)\n\n\tdetour.DtVcopy(this.m_vel[this.m_nsamples*3:], vel)\n\tthis.m_ssize[this.m_nsamples] = ssize\n\tthis.m_pen[this.m_nsamples] = pen\n\tthis.m_vpen[this.m_nsamples] = vpen\n\tthis.m_vcpen[this.m_nsamples] = vcpen\n\tthis.m_spen[this.m_nsamples] = spen\n\tthis.m_tpen[this.m_nsamples] = tpen\n\tthis.m_nsamples += 1\n}\n"
                    },
                    "init": {
                        "Name": "init",
                        "Code": "func (this *DtObstacleAvoidanceDebugData) init(maxSamples int) bool {\n\n\tdetour.DtAssert(maxSamples \u003e 0)\n\tthis.m_maxSamples = maxSamples\n\n\tthis.m_vel = make([]float32, 3*this.m_maxSamples)\n\tthis.m_pen = make([]float32, this.m_maxSamples)\n\tthis.m_ssize = make([]float32, this.m_maxSamples)\n\tthis.m_vpen = make([]float32, this.m_maxSamples)\n\tthis.m_vcpen = make([]float32, this.m_maxSamples)\n\tthis.m_spen = make([]float32, this.m_maxSamples)\n\tthis.m_tpen = make([]float32, this.m_maxSamples)\n\n\treturn true\n}\n"
                    },
                    "normalizeSamples": {
                        "Name": "normalizeSamples",
                        "Code": "func (this *DtObstacleAvoidanceDebugData) normalizeSamples() {\n\tnormalizeArray(this.m_pen, this.m_nsamples)\n\tnormalizeArray(this.m_vpen, this.m_nsamples)\n\tnormalizeArray(this.m_vcpen, this.m_nsamples)\n\tnormalizeArray(this.m_spen, this.m_nsamples)\n\tnormalizeArray(this.m_tpen, this.m_nsamples)\n}\n"
                    },
                    "reset": {
                        "Name": "reset",
                        "Code": "func (this *DtObstacleAvoidanceDebugData) reset() {\n\tthis.m_nsamples = 0\n}\n"
                    }
                }
            },
            "DtObstacleAvoidanceParams": {
                "Name": "DtObstacleAvoidanceParams",
                "Code": "type DtObstacleAvoidanceParams struct {\n\tvelBias       float32\n\tweightDesVel  float32\n\tweightCurVel  float32\n\tweightSide    float32\n\tweightToi     float32\n\thorizTime     float32\n\tgridSize      uint8 ///\u003c grid\n\tadaptiveDivs  uint8 ///\u003c adaptive\n\tadaptiveRings uint8 ///\u003c adaptive\n\tadaptiveDepth uint8 ///\u003c adaptive\n}\n",
                "Methods": {}
            },
            "DtObstacleAvoidanceQuery": {
                "Name": "DtObstacleAvoidanceQuery",
                "Code": "type DtObstacleAvoidanceQuery struct {\n\tm_params       DtObstacleAvoidanceParams\n\tm_invHorizTime float32\n\tm_vmax         float32\n\tm_invVmax      float32\n\n\tm_maxCircles int\n\tm_circles    []DtObstacleCircle\n\tm_ncircles   int\n\n\tm_maxSegments int\n\tm_segments    []DtObstacleSegment\n\tm_nsegments   int\n}\n",
                "Methods": {
                    "addCircle": {
                        "Name": "addCircle",
                        "Code": "func (this *DtObstacleAvoidanceQuery) addCircle(pos []float32, rad float32,\n\tvel []float32, dvel []float32) {\n\tif this.m_ncircles \u003e= this.m_maxCircles {\n\t\treturn\n\t}\n\n\tvar cir = \u0026this.m_circles[this.m_ncircles]\n\tthis.m_ncircles += 1\n\tdetour.DtVcopy(cir.p[:], pos)\n\tcir.rad = rad\n\tdetour.DtVcopy(cir.vel[:], vel)\n\tdetour.DtVcopy(cir.dvel[:], dvel)\n}\n"
                    },
                    "addSegment": {
                        "Name": "addSegment",
                        "Code": "func (this *DtObstacleAvoidanceQuery) addSegment(p []float32, q []float32) {\n\tif this.m_nsegments \u003e= this.m_maxSegments {\n\t\treturn\n\t}\n\n\tvar seg = \u0026this.m_segments[this.m_nsegments]\n\tthis.m_nsegments += 1\n\tdetour.DtVcopy(seg.p[:], p)\n\tdetour.DtVcopy(seg.q[:], q)\n}\n"
                    },
                    "init": {
                        "Name": "init",
                        "Code": "func (this *DtObstacleAvoidanceQuery) init(maxCircles, maxSegments int) bool {\n\n\tthis.m_maxCircles = maxCircles\n\tthis.m_ncircles = 0\n\tthis.m_circles = make([]DtObstacleCircle, this.m_maxCircles)\n\n\tthis.m_maxSegments = maxSegments\n\tthis.m_nsegments = 0\n\tthis.m_segments = make([]DtObstacleSegment, this.m_maxSegments)\n\n\treturn true\n}\n"
                    },
                    "prepare": {
                        "Name": "prepare",
                        "Code": "func (this *DtObstacleAvoidanceQuery) prepare(pos, dvel []float32) {\n\t// Prepare obstacles\n\tfor i := 0; i \u003c this.m_ncircles; i += 1 {\n\t\tvar cir = \u0026this.m_circles[i]\n\n\t\tvar pa = pos\n\t\tvar pb = cir.p[:]\n\n\t\tvar orig [3]float32\n\t\tvar dv [3]float32\n\t\tdetour.DtVsub(cir.dp[:], pb, pa)\n\t\tdetour.DtVnormalize(cir.dp[:])\n\t\tdetour.DtVsub(dv[:], cir.dvel[:], dvel)\n\n\t\tvar a = detour.DtTriArea2D(orig[:], cir.dp[:], dv[:])\n\t\tif a \u003c 0.01 {\n\t\t\tcir.np[0] = -cir.dp[2]\n\t\t\tcir.np[2] = cir.dp[0]\n\t\t} else {\n\t\t\tcir.np[0] = cir.dp[2]\n\t\t\tcir.np[2] = cir.dp[0]\n\t\t}\n\t}\n\n\tfor i := 0; i \u003c this.m_nsegments; i += 1 {\n\t\tvar seg = \u0026this.m_segments[i]\n\n\t\t// Precalc if the agent is really close to the segment.\n\t\tvar r = float32(0.01)\n\t\tvar t float32\n\t\tseg.touch = detour.DtDistancePtSegSqr2D(pos, seg.p[:], seg.q[:], \u0026t) \u003c detour.DtSqrFloat32(r)\n\t}\n}\n"
                    },
                    "processSample": {
                        "Name": "processSample",
                        "Code": "func (this *DtObstacleAvoidanceQuery) processSample(vcand []float32, cs float32,\n\tpos []float32, rad float32,\n\tvel []float32, dvel []float32,\n\tminPenalty float32,\n\tdebug *DtObstacleAvoidanceDebugData) float32 {\n\t// penalty for straying away from the desired and current velocities\n\tvar vpen = this.m_params.weightDesVel * (detour.DtVdist2D(vcand, dvel) * this.m_invVmax)\n\tvar vcpen = this.m_params.weightCurVel * (detour.DtVdist2D(vcand, vel) * this.m_invVmax)\n\n\tconst FLT_EPSILON = 1.192092896e-07\n\t// find the threshold hit time to bail out based on the early out penalty\n\t// (see how the penalty is calculated below to understnad)\n\tvar minPen = minPenalty - vpen - vcpen\n\tvar tThresold = (this.m_params.weightToi/minPen - 0.1) * this.m_params.horizTime\n\tif tThresold-this.m_params.horizTime \u003e -FLT_EPSILON {\n\t\treturn minPenalty\n\t}\n\n\t// Find min time of impact and exit amongst all obstacles.\n\tvar tmin = this.m_params.horizTime\n\tvar side float32\n\tvar nside int\n\n\tfor i := 0; i \u003c this.m_ncircles; i += 1 {\n\t\tvar cir = \u0026this.m_circles[i]\n\n\t\t// RVO\n\t\tvar vab [3]float32\n\t\tdetour.DtVscale(vab[:], vcand, 2)\n\t\tdetour.DtVsub(vab[:], vab[:], vel)\n\t\tdetour.DtVsub(vab[:], vab[:], cir.vel[:])\n\n\t\t// Side\n\t\tside += detour.DtClampFloat32(detour.DtMinFloat32(detour.DtVdot2D(cir.dp[:], vab[:])*0.5+0.5, detour.DtVdot2D(cir.np[:], vab[:])*2), 0, 1)\n\t\tnside += 1\n\n\t\tvar htmin, htmax float32\n\t\tif sweepCircleCircle(pos, rad, vab[:], cir.p[:], cir.rad, \u0026htmin, \u0026htmax) \u003c= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle overlapping obstacles.\n\t\tif htmin \u003c 0 \u0026\u0026 htmax \u003e 0 {\n\t\t\t// Avoid more when overlapped.\n\t\t\thtmin = -htmin * 0.5\n\t\t}\n\n\t\tif htmin \u003e= 0 {\n\t\t\t// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.\n\t\t\tif htmin \u003c tmin {\n\t\t\t\ttmin = htmin\n\t\t\t\tif tmin \u003c tThresold {\n\t\t\t\t\treturn minPenalty\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i \u003c this.m_nsegments; i++ {\n\t\tvar seg = \u0026this.m_segments[i]\n\t\tvar htmin float32\n\n\t\tif seg.touch {\n\t\t\t// Special case when the agent is very close to the segment.\n\t\t\tvar sdir, snorm [3]float32\n\t\t\tdetour.DtVsub(sdir[:], seg.q[:], seg.p[:])\n\t\t\tsnorm[0] = -sdir[2]\n\t\t\tsnorm[2] = sdir[0]\n\t\t\t// If the velocity is pointing towards the segment, no collision.\n\t\t\tif detour.DtVdot2D(snorm[:], vcand) \u003c 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thtmin = 0\n\t\t} else {\n\t\t\tif isectRaySeg(pos, vcand, seg.p[:], seg.q[:], \u0026htmin) \u003c= 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Avoid less when facing walls.\n\t\thtmin *= 2.0\n\n\t\t// The closest obstacle is somewhere ahead of us, keep track of nearest obstacle.\n\t\tif htmin \u003c tmin {\n\t\t\ttmin = htmin\n\t\t\tif tmin \u003c tThresold {\n\t\t\t\treturn minPenalty\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize side bias, to prevent it dominating too much.\n\tif nside \u003e 0 {\n\t\tside /= float32(nside)\n\t}\n\n\tvar spen = this.m_params.weightSide * side\n\tvar tpen = this.m_params.weightToi * (1 / (0.1 + tmin*this.m_invHorizTime))\n\n\tvar penalty = vpen + vcpen + spen + tpen\n\t// Store different penalties for debug viewing\n\tif debug != nil {\n\t\tdebug.addSample(vcand, cs, penalty, vpen, vcpen, spen, tpen)\n\t}\n\n\treturn penalty\n}\n"
                    },
                    "reset": {
                        "Name": "reset",
                        "Code": "func (this *DtObstacleAvoidanceQuery) reset() {\n\tthis.m_ncircles = 0\n\tthis.m_nsegments = 0\n}\n"
                    },
                    "sampleVelocityAdaptive": {
                        "Name": "sampleVelocityAdaptive",
                        "Code": "func (this *DtObstacleAvoidanceQuery) sampleVelocityAdaptive(pos []float32, rad float32, vmax float32,\n\tvel []float32, dvel []float32, nvel []float32,\n\tparams *DtObstacleAvoidanceParams,\n\tdebug *DtObstacleAvoidanceDebugData) int {\n\n\tthis.prepare(pos, dvel)\n\tthis.m_params = *params\n\tthis.m_invHorizTime = 1 / this.m_params.horizTime\n\tthis.m_vmax = vmax\n\tthis.m_invVmax = math.MaxFloat32\n\tif vmax \u003e 0 {\n\t\tthis.m_invVmax = 1 / vmax\n\t}\n\n\tdetour.DtVset(nvel, 0, 0, 0)\n\n\tif debug != nil {\n\t\tdebug.reset()\n\t}\n\n\t// Build sampling pattern aligned to desired velocity.\n\tvar pat [(DT_MAX_PATTERN_DIVS*DT_MAX_PATTERN_RINGS + 1) * 2]float32\n\tvar npat int\n\n\tvar ndivs = int(this.m_params.adaptiveDivs)\n\tvar nrings = int(this.m_params.adaptiveRings)\n\tvar depth = int(this.m_params.adaptiveDepth)\n\n\tvar nd = detour.DtClampInt(ndivs, 1, DT_MAX_PATTERN_DIVS)\n\tvar nr = detour.DtClampInt(nrings, 1, DT_MAX_PATTERN_RINGS)\n\tvar da = (1.0 / float32(nd)) * DT_PI * 2\n\tvar ca = float32(math.Cos(float64(da)))\n\tvar sa = float32(math.Sin(float64(da)))\n\n\t// desired direction\n\tvar ddir [6]float32\n\tdetour.DtVcopy(ddir[:], dvel)\n\tdtNormalize2D(ddir[:])\n\tdtRorate2D(ddir[3:], ddir[:], da*0.5)\n\n\t// Always add sample at zero\n\tpat[npat*2+0] = 0\n\tpat[npat*2+1] = 0\n\tnpat += 1\n\n\tfor j := 0; j \u003c nr; j++ {\n\t\tvar r = float32(nr-j) / float32(nr)\n\t\tpat[npat*2+0] = ddir[(j%2)*3] * r\n\t\tpat[npat*2+1] = ddir[(j%2)*3+2] * r\n\t\tvar last1 = pat[npat*2:]\n\t\tvar last2 = last1\n\t\tnpat += 1\n\n\t\tfor i := 1; i \u003c nd-1; i += 2 {\n\t\t\t// get next point on the \"right\" (rotate CW)\n\t\t\tpat[npat*2+0] = last1[0]*ca + last1[1]*sa\n\t\t\tpat[npat*2+1] = -last1[0]*sa + last1[1]*ca\n\t\t\t// get next point on the \"left\" (rotate CCW)\n\t\t\tpat[npat*2+2] = last2[0]*ca - last2[1]*sa\n\t\t\tpat[npat*2+3] = last2[0]*sa + last2[1]*ca\n\n\t\t\tlast1 = pat[npat*2:]\n\t\t\tlast2 = last1[2:]\n\t\t\tnpat += 2\n\t\t}\n\n\t\tif nd\u00261 == 0 {\n\t\t\tpat[npat*2+2] = last2[0]*ca - last2[1]*sa\n\t\t\tpat[npat*2+3] = last2[0]*sa + last2[1]*ca\n\t\t\tnpat += 1\n\t\t}\n\t}\n\n\t// Start sampling.\n\tvar cr = vmax * (1 - this.m_params.velBias)\n\tvar res [3]float32\n\tdetour.DtVset(res[:], dvel[0]*this.m_params.velBias, 0, dvel[2]*this.m_params.velBias)\n\tvar ns int\n\n\tfor k := 0; k \u003c depth; k += 1 {\n\t\tvar minPenalty = float32(math.MaxFloat32)\n\t\tvar bvel [3]float32\n\n\t\tfor i := 0; i \u003c npat; i += 1 {\n\t\t\tvar vcand [3]float32\n\t\t\tvcand[0] = res[0] + pat[i*2+0]*cr\n\t\t\tvcand[1] = 0\n\t\t\tvcand[2] = res[2] + pat[i*2+1]*cr\n\n\t\t\tif detour.DtSqrFloat32(vcand[0])+detour.DtSqrFloat32(vcand[2]) \u003e detour.DtSqrFloat32(vmax+0.001) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar penalty = this.processSample(vcand[:], cr/10, pos, rad, vel, dvel, minPenalty, debug)\n\t\t\tns += 1\n\t\t\tif penalty \u003c minPenalty {\n\t\t\t\tminPenalty = penalty\n\t\t\t\tdetour.DtVcopy(bvel[:], vcand[:])\n\t\t\t}\n\t\t}\n\n\t\tdetour.DtVcopy(res[:], bvel[:])\n\t\tcr *= 0.5\n\t}\n\n\tdetour.DtVcopy(nvel, res[:])\n\treturn ns\n}\n"
                    },
                    "sampleVelocityGrid": {
                        "Name": "sampleVelocityGrid",
                        "Code": "func (this *DtObstacleAvoidanceQuery) sampleVelocityGrid(pos []float32, rad float32, vmax float32,\n\tvel []float32, dvel []float32, nvel []float32,\n\tparams *DtObstacleAvoidanceParams,\n\tdebug *DtObstacleAvoidanceDebugData) int {\n\n\tthis.prepare(pos, dvel)\n\n\tthis.m_params = *params\n\tthis.m_invHorizTime = 1 / this.m_params.horizTime\n\tthis.m_vmax = vmax\n\tthis.m_invVmax = math.MaxFloat32\n\tif vmax \u003e 0 {\n\t\tthis.m_invVmax = 1 / vmax\n\t}\n\n\tdetour.DtVset(nvel, 0, 0, 0)\n\n\tif debug != nil {\n\t\tdebug.reset()\n\t}\n\n\tvar cvx = dvel[0] * this.m_params.velBias\n\tvar cvz = dvel[2] * this.m_params.velBias\n\tvar cs = vmax * 2 * (1 - this.m_params.velBias) / float32(this.m_params.gridSize-1)\n\tvar half = (float32(this.m_params.gridSize) - 1) * cs * 0.5\n\n\tvar minPenalty = float32(math.MaxFloat32)\n\tvar ns int\n\n\tfor y := 0; y \u003c int(this.m_params.gridSize); y += 1 {\n\t\tfor x := 0; x \u003c int(this.m_params.gridSize); x += 1 {\n\t\t\tvar vcand [3]float32\n\t\t\tvcand[0] = cvx + float32(x)*cs - half\n\t\t\tvcand[1] = 0\n\t\t\tvcand[2] = cvz + float32(y)*cs - half\n\n\t\t\tif detour.DtSqrFloat32(vcand[0])+detour.DtSqrFloat32(vcand[2]) \u003e detour.DtSqrFloat32(vmax+cs/2) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar penalty = this.processSample(vcand[:], cs, pos, rad, vel, dvel, minPenalty, debug)\n\t\t\tns += 1\n\t\t\tif penalty \u003c minPenalty {\n\t\t\t\tminPenalty = penalty\n\t\t\t\tdetour.DtVcopy(nvel, vcand[:])\n\t\t\t}\n\t\t}\n\t}\n\treturn ns\n}\n"
                    }
                }
            },
            "DtObstacleCircle": {
                "Name": "DtObstacleCircle",
                "Code": "type DtObstacleCircle struct {\n\tp    [3]float32 ///\u003c Position of the obstacle\n\tvel  [3]float32 ///\u003c Velocity of the obstacle\n\tdvel [3]float32 ///\u003c Velocity of the obstacle\n\trad  float32    ///\u003c Radius of the obstacle\n\tdp   [3]float32\n\tnp   [3]float32 ///\u003c Use for side selection during sampling.\n}\n",
                "Methods": {}
            },
            "DtObstacleSegment": {
                "Name": "DtObstacleSegment",
                "Code": "type DtObstacleSegment struct {\n\tp     [3]float32\n\tq     [3]float32 ///\u003c End points of the obstacle segment\n\ttouch bool\n}\n",
                "Methods": {}
            },
            "DtPathCorridor": {
                "Name": "DtPathCorridor",
                "Code": "type DtPathCorridor struct {\n\tm_pos    [3]float32\n\tm_target [3]float32\n\n\tm_path    []detour.DtPolyRef\n\tm_npath   int\n\tm_maxPath int\n}\n",
                "Methods": {
                    "FindCorners": {
                        "Name": "FindCorners",
                        "Code": "func (this *DtPathCorridor) FindCorners(cornerVerts []float32, cornerFlags []detour.DtStraightPathFlags,\n\tcornerPolys []detour.DtPolyRef, maxCorners int,\n\tnavquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) int {\n\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(this.m_npath \u003e 0)\n\n\tconst MIN_TARGET_DIST = 0.01\n\n\tvar ncorners int\n\tvar option detour.DtStraightPathOptions\n\tnavquery.FindStraightPath(this.m_pos[:], this.m_target[:], this.m_path, this.m_npath,\n\t\tcornerVerts, cornerFlags, cornerPolys, \u0026ncorners, maxCorners, option)\n\n\t// Prune points in the beginning of the path which are too close.\n\tfor ncorners \u003e 0 {\n\t\tif cornerFlags[0]\u0026detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION \u003e 0 ||\n\t\t\tdetour.DtVdist2DSqr(cornerVerts[0:], this.m_pos[:]) \u003e detour.DtSqrFloat32(MIN_TARGET_DIST) {\n\t\t\tbreak\n\t\t}\n\t\tncorners -= 1\n\t\tif ncorners \u003e 0 {\n\t\t\tcopy(cornerFlags[0:], cornerFlags[1:1+ncorners])\n\t\t\tcopy(cornerPolys[0:], cornerPolys[1:1+ncorners])\n\t\t\tcopy(cornerVerts[0:], cornerVerts[3:3+3*ncorners])\n\t\t}\n\t}\n\n\t// Prune points after an off-mesh connection.\n\tfor i := 0; i \u003c ncorners; i += 1 {\n\t\tif cornerFlags[i]\u0026detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION \u003e 0 {\n\t\t\tncorners = i + 1\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ncorners\n}\n"
                    },
                    "FixPathStart": {
                        "Name": "FixPathStart",
                        "Code": "func (this *DtPathCorridor) FixPathStart(safeRef detour.DtPolyRef, safePos []float32) bool {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\n\tdetour.DtVcopy(this.m_pos[:], safePos)\n\tif this.m_npath \u003c 3 \u0026\u0026 this.m_npath \u003e 0 {\n\t\tthis.m_path[2] = this.m_path[this.m_npath-1]\n\t\tthis.m_path[0] = safeRef\n\t\tthis.m_path[1] = 0\n\t\tthis.m_npath = 3\n\t} else {\n\t\tthis.m_path[0] = safeRef\n\t\tthis.m_path[1] = 0\n\t}\n\n\treturn true\n}\n"
                    },
                    "GetFirstPoly": {
                        "Name": "GetFirstPoly",
                        "Code": "func (this *DtPathCorridor) GetFirstPoly() detour.DtPolyRef {\n\tif len(this.m_path) \u003e 0 {\n\t\treturn this.m_path[0]\n\t}\n\treturn 0\n}\n"
                    },
                    "GetLastPoly": {
                        "Name": "GetLastPoly",
                        "Code": "func (this *DtPathCorridor) GetLastPoly() detour.DtPolyRef {\n\tif len(this.m_path) \u003e 0 {\n\t\treturn this.m_path[this.m_npath-1]\n\t}\n\treturn 0\n}\n"
                    },
                    "GetPath": {
                        "Name": "GetPath",
                        "Code": "func (this *DtPathCorridor) GetPath() []detour.DtPolyRef {\n\treturn this.m_path\n}\n"
                    },
                    "GetPathCount": {
                        "Name": "GetPathCount",
                        "Code": "func (this *DtPathCorridor) GetPathCount() int {\n\treturn this.m_npath\n}\n"
                    },
                    "GetPos": {
                        "Name": "GetPos",
                        "Code": "func (this *DtPathCorridor) GetPos() []float32 {\n\treturn this.m_pos[:]\n}\n"
                    },
                    "GetTarget": {
                        "Name": "GetTarget",
                        "Code": "func (this *DtPathCorridor) GetTarget() []float32 {\n\treturn this.m_target[:]\n}\n"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtPathCorridor) Init(maxPath int) bool {\n\n\tdetour.DtAssert(len(this.m_path) \u003c= 0)\n\tthis.m_path = make([]detour.DtPolyRef, maxPath)\n\n\tthis.m_npath = 0\n\tthis.m_maxPath = maxPath\n\n\treturn true\n}\n"
                    },
                    "IsValid": {
                        "Name": "IsValid",
                        "Code": "func (this *DtPathCorridor) IsValid(maxLookAhead int, navquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\t// Check that all polygons still pass query filter.\n\n\tvar n = detour.DtMinInt(this.m_npath, maxLookAhead)\n\tfor i := 0; i \u003c n; i += 1 {\n\t\tif !navquery.IsValidPolyRef(this.m_path[i], filter) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
                    },
                    "MoveOverOffmeshConnection": {
                        "Name": "MoveOverOffmeshConnection",
                        "Code": "func (this *DtPathCorridor) MoveOverOffmeshConnection(offMeshConRef detour.DtPolyRef, refs []detour.DtPolyRef,\n\tstartPos, endPos []float32,\n\tnavquery *detour.DtNavMeshQuery) bool {\n\tdetour.DtAssert(navquery != nil)\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(this.m_npath \u003e 0)\n\n\t// Advance the path up to and over the off-mesh connection.\n\tvar prevRef detour.DtPolyRef\n\tvar polyRef = this.m_path[0]\n\tvar npos int\n\tfor npos \u003c this.m_npath \u0026\u0026 polyRef != offMeshConRef {\n\t\tprevRef = polyRef\n\t\tpolyRef = this.m_path[npos]\n\t\tnpos += 1\n\t}\n\tif npos == this.m_npath {\n\t\t// Could not find offMeshConRef\n\t\treturn false\n\t}\n\n\t// Prune path\n\tfor i := npos; i \u003c this.m_npath; i += 1 {\n\t\tthis.m_path[i-npos] = this.m_path[i]\n\t}\n\tthis.m_npath -= npos\n\n\trefs[0] = prevRef\n\trefs[1] = polyRef\n\n\tvar nav = navquery.GetAttachedNavMesh()\n\tdetour.DtAssert(nav != nil)\n\n\tvar status = nav.GetOffMeshConnectionPolyEndPoints(refs[0], refs[1], startPos, endPos)\n\tif detour.DtStatusSucceed(status) {\n\t\tdetour.DtVcopy(this.m_pos[:], endPos)\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
                    },
                    "MovePosition": {
                        "Name": "MovePosition",
                        "Code": "func (this *DtPathCorridor) MovePosition(npos []float32, navquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(this.m_npath \u003e 0)\n\n\tconst MAX_VISITED = 16\n\t// Move along navmesh and update new position.\n\tvar result [3]float32\n\tvar visited [MAX_VISITED]detour.DtPolyRef\n\tvar nvisited int\n\tvar bhit bool\n\tvar status = navquery.MoveAlongSurface(this.m_path[0], this.m_pos[:], npos, filter, result[:], visited[:], \u0026nvisited, MAX_VISITED, \u0026bhit)\n\tif detour.DtStatusSucceed(status) {\n\t\tthis.m_npath = dtMergeCorridorStartMoved(this.m_path, this.m_npath, this.m_maxPath, visited[:], nvisited)\n\n\t\t// Adjust the position to stay on top of the navmesh.\n\t\tvar h = this.m_pos[1]\n\t\tnavquery.GetPolyHeight(this.m_path[0], result[:], \u0026h)\n\t\tresult[1] = h\n\t\tdetour.DtVcopy(this.m_pos[:], result[:])\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
                    },
                    "MoveTargetPosition": {
                        "Name": "MoveTargetPosition",
                        "Code": "func (this *DtPathCorridor) MoveTargetPosition(npos []float32, navquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(this.m_npath \u003e 0)\n\n\tconst MAX_VISITED = 16\n\t// Move along navmesh and update new position.\n\tvar result [3]float32\n\tvar visited [MAX_VISITED]detour.DtPolyRef\n\tvar nvisited int\n\tvar bhit bool\n\tvar status = navquery.MoveAlongSurface(this.m_path[this.m_npath-1], this.m_target[:], npos, filter,\n\t\tresult[:], visited[:], \u0026nvisited, MAX_VISITED, \u0026bhit)\n\tif detour.DtStatusSucceed(status) {\n\t\tthis.m_npath = dtMergeCorridorEndMoved(this.m_path, this.m_npath, this.m_maxPath, visited[:], nvisited)\n\t\t// TODO: should we do that?\n\t\t// Adjust the position to stay on top of the navmesh.\n\t\t/*\tfloat h = m_target[1];\n\t\t\tnavquery-\u003egetPolyHeight(m_path[m_npath-1], result, \u0026h);\n\t\t\tresult[1] = h;*/\n\t\tdetour.DtVcopy(this.m_target[:], result[:])\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
                    },
                    "OptimizePathTopology": {
                        "Name": "OptimizePathTopology",
                        "Code": "func (this *DtPathCorridor) OptimizePathTopology(navquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\n\tdetour.DtAssert(navquery != nil)\n\tdetour.DtAssert(filter != nil)\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\n\tif this.m_npath \u003c 3 {\n\t\treturn false\n\t}\n\n\tconst MAX_ITER = 32\n\tconst MAX_RES = 32\n\n\tvar res [MAX_RES]detour.DtPolyRef\n\tvar nres int\n\tvar option detour.DtFindPathOptions\n\tvar doneIter int\n\tnavquery.InitSlicedFindPath(this.m_path[0], this.m_path[this.m_npath-1], this.m_pos[:], this.m_target[:], filter, option)\n\tnavquery.UpdateSlicedFindPath(MAX_ITER, \u0026doneIter)\n\n\tvar status = navquery.FinalizeSlicedFindPathPartial(this.m_path, this.m_npath, res[:], \u0026nres, MAX_RES)\n\tif detour.DtStatusSucceed(status) \u0026\u0026 nres \u003e 0 {\n\t\tthis.m_npath = dtMergeCorridorStartShortcut(this.m_path, this.m_npath, this.m_maxPath, res[:], nres)\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
                    },
                    "OptimizePathVisibility": {
                        "Name": "OptimizePathVisibility",
                        "Code": "func (this *DtPathCorridor) OptimizePathVisibility(next []float32, pathOptimizationRange float32,\n\tnavquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\n\t// Clamp the ray to max distance.\n\tvar goal [3]float32\n\tdetour.DtVcopy(goal[:], next)\n\tvar dist = detour.DtVdist2D(this.m_pos[:], goal[:])\n\n\t// If too close to the goal, do not try to optimize.\n\tif dist \u003c 0.01 {\n\t\treturn\n\t}\n\n\t// Overshoot a little. This helps to optimize open fields in tiled meshes.\n\tdist = detour.DtMinFloat32(dist+0.01, pathOptimizationRange)\n\n\t// Adjust ray length.\n\tvar delta [3]float32\n\tdetour.DtVsub(delta[:], goal[:], this.m_pos[:])\n\tdetour.DtVmad(goal[:], this.m_pos[:], delta[:], pathOptimizationRange/dist)\n\n\tconst MAX_RES = 32\n\tvar res [MAX_RES]detour.DtPolyRef\n\tvar t float32\n\tvar norm [3]float32\n\tvar nres int\n\tnavquery.Raycast(this.m_path[0], this.m_pos[:], goal[:], filter, \u0026t, norm[:], res[:], \u0026nres, MAX_RES)\n\tif nres \u003e 1 \u0026\u0026 t \u003e 0.99 {\n\t\tthis.m_npath = dtMergeCorridorStartShortcut(this.m_path, this.m_npath, this.m_maxPath, res[:], nres)\n\t}\n}\n"
                    },
                    "Reset": {
                        "Name": "Reset",
                        "Code": "func (this *DtPathCorridor) Reset(ref detour.DtPolyRef, pos []float32) {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\n\tdetour.DtVcopy(this.m_pos[:], pos)\n\tdetour.DtVcopy(this.m_target[:], pos)\n\tthis.m_path[0] = ref\n\tthis.m_npath = 1\n}\n"
                    },
                    "SetCorridor": {
                        "Name": "SetCorridor",
                        "Code": "func (this *DtPathCorridor) SetCorridor(target []float32, path []detour.DtPolyRef, npath int) {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(npath \u003e 0)\n\tdetour.DtAssert(npath \u003c this.m_maxPath)\n\n\tdetour.DtVcopy(this.m_target[:], target)\n\tcopy(this.m_path[0:], path[:npath])\n\tthis.m_npath = npath\n}\n"
                    },
                    "trimInvalidPath": {
                        "Name": "trimInvalidPath",
                        "Code": "func (this *DtPathCorridor) trimInvalidPath(safeRef detour.DtPolyRef, safePos []float32,\n\tnavquery *detour.DtNavMeshQuery, filter *detour.DtQueryFilter) bool {\n\tdetour.DtAssert(len(this.m_path) \u003e 0)\n\tdetour.DtAssert(navquery != nil)\n\tdetour.DtAssert(filter != nil)\n\n\t// Keep valid path as far as possible.\n\tvar n int\n\tfor n \u003c this.m_npath \u0026\u0026 navquery.IsValidPolyRef(this.m_path[n], filter) {\n\t\tn += 1\n\t}\n\n\tif n == this.m_npath {\n\t\t// All valid, no need to fix.\n\t\treturn true\n\t} else if n == 0 {\n\t\t// The first polyref is bad, use current safe values.\n\t\tdetour.DtVcopy(this.m_pos[:], safePos)\n\t\tthis.m_path[0] = safeRef\n\t\tthis.m_npath = 1\n\t} else {\n\t\t// The path is partially usable.\n\t\tthis.m_npath = n\n\t}\n\n\tvar tgt [3]float32\n\tdetour.DtVcopy(tgt[:], this.m_target[:])\n\tnavquery.ClosestPointOnPolyBoundary(this.m_path[this.m_npath-1], tgt[:], this.m_target[:])\n\n\treturn true\n}\n"
                    }
                }
            },
            "DtPathQueue": {
                "Name": "DtPathQueue",
                "Code": "type DtPathQueue struct {\n\tm_queue       [MAX_QUEUE]PathQuery\n\tm_nextHandle  DtPathQueueRef\n\tm_maxPathSize int\n\tm_queueHead   int\n\tm_navquery    *detour.DtNavMeshQuery\n}\n",
                "Methods": {
                    "GetNavQuery": {
                        "Name": "GetNavQuery",
                        "Code": "func (this *DtPathQueue) GetNavQuery() *detour.DtNavMeshQuery {\n\treturn this.m_navquery\n}\n"
                    },
                    "GetPathResult": {
                        "Name": "GetPathResult",
                        "Code": "func (this *DtPathQueue) GetPathResult(ref DtPathQueueRef, path []detour.DtPolyRef,\n\tpathSize *int, maxPath int) detour.DtStatus {\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tif this.m_queue[i].ref == ref {\n\t\t\tvar q = \u0026this.m_queue[i]\n\t\t\tvar details = q.status \u0026 detour.DT_STATUS_DETAIL_MASK\n\t\t\t// Free request for reuse.\n\t\t\tq.ref = DtPathQueueRef(DT_PATHQ_INVALID)\n\t\t\tq.status = 0\n\t\t\t// Copy path\n\t\t\tvar n = detour.DtMinInt(q.npath, maxPath)\n\t\t\tcopy(path[:], q.path[:n])\n\t\t\t*pathSize = n\n\t\t\treturn details | detour.DT_SUCCESS\n\t\t}\n\t}\n\treturn detour.DT_FAILURE\n}\n"
                    },
                    "GetRequestStatus": {
                        "Name": "GetRequestStatus",
                        "Code": "func (this *DtPathQueue) GetRequestStatus(ref DtPathQueueRef) detour.DtStatus {\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tif this.m_queue[i].ref == ref {\n\t\t\treturn this.m_queue[i].status\n\t\t}\n\t}\n\treturn detour.DT_FAILURE\n}\n"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtPathQueue) Init(maxPathSize, maxSearchNodeCount int, nav *detour.DtNavMesh) bool {\n\n\tthis.purge()\n\n\tthis.m_navquery = detour.DtAllocNavMeshQuery()\n\tif this.m_navquery == nil {\n\t\treturn false\n\t}\n\tif detour.DtStatusFailed(this.m_navquery.Init(nav, maxSearchNodeCount)) {\n\t\treturn false\n\t}\n\n\tthis.m_maxPathSize = maxPathSize\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tthis.m_queue[i].ref = DtPathQueueRef(DT_PATHQ_INVALID)\n\t\tthis.m_queue[i].path = make([]detour.DtPolyRef, this.m_maxPathSize)\n\t\tif len(this.m_queue[i].path) \u003c= 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\tthis.m_queueHead = 0\n\treturn true\n}\n"
                    },
                    "Request": {
                        "Name": "Request",
                        "Code": "func (this *DtPathQueue) Request(startRef, endRef detour.DtPolyRef,\n\tstartPos, endPos []float32,\n\tfilter *detour.DtQueryFilter) DtPathQueueRef {\n\n\tvar slot = -1\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tif this.m_queue[i].ref == DtPathQueueRef(DT_PATHQ_INVALID) {\n\t\t\tslot = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif slot \u003c 0 {\n\t\treturn DtPathQueueRef(DT_PATHQ_INVALID)\n\t}\n\n\tvar ref = this.m_nextHandle\n\tthis.m_nextHandle += 1\n\tif this.m_nextHandle == DtPathQueueRef(DT_PATHQ_INVALID) {\n\t\tthis.m_nextHandle += 1\n\t}\n\n\tvar q = \u0026this.m_queue[slot]\n\tq.ref = ref\n\tdetour.DtVcopy(q.startPos[:], startPos)\n\tq.startRef = startRef\n\tdetour.DtVcopy(q.endPos[:], endPos)\n\tq.endRef = endRef\n\n\tq.status = 0\n\tq.npath = 0\n\tq.filter = filter\n\tq.keepAlive = 0\n\n\treturn ref\n}\n"
                    },
                    "Update": {
                        "Name": "Update",
                        "Code": "func (this *DtPathQueue) Update(maxIters int) {\n\tconst MAX_KEEP_ALIVE = 2\n\n\tvar iterCount = maxIters\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tvar q = \u0026this.m_queue[this.m_queueHead%MAX_QUEUE]\n\n\t\tif q.ref == DtPathQueueRef(DT_PATHQ_INVALID) {\n\t\t\tthis.m_queueHead += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif detour.DtStatusSucceed(q.status) || detour.DtStatusFailed(q.status) {\n\t\t\tq.keepAlive += 1\n\t\t\tif q.keepAlive \u003e MAX_KEEP_ALIVE {\n\t\t\t\tq.ref = DtPathQueueRef(DT_PATHQ_INVALID)\n\t\t\t\tq.status = 0\n\t\t\t}\n\n\t\t\tthis.m_queueHead += 1\n\t\t\tcontinue\n\t\t}\n\n\t\tif q.status == 0 {\n\t\t\tvar option detour.DtFindPathOptions\n\t\t\tq.status = this.m_navquery.InitSlicedFindPath(q.startRef, q.endRef,\n\t\t\t\tq.startPos[:], q.endPos[:], q.filter, option)\n\t\t}\n\n\t\tif detour.DtStatusInProgress(q.status) {\n\t\t\tvar iters int\n\t\t\tq.status = this.m_navquery.UpdateSlicedFindPath(iterCount, \u0026iters)\n\t\t\titerCount -= iters\n\t\t}\n\t\tif detour.DtStatusSucceed(q.status) {\n\t\t\tq.status = this.m_navquery.FinalizeSlicedFindPath(q.path, \u0026q.npath, this.m_maxPathSize)\n\t\t}\n\n\t\tif iterCount \u003c= 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tthis.m_queueHead += 1\n\t}\n}\n"
                    },
                    "purge": {
                        "Name": "purge",
                        "Code": "func (this *DtPathQueue) purge() {\n\tthis.m_navquery = nil\n\tfor i := 0; i \u003c MAX_QUEUE; i += 1 {\n\t\tthis.m_queue[i].filter = nil\n\t}\n}\n"
                    }
                }
            },
            "DtPathQueueRef": {
                "Name": "DtPathQueueRef",
                "Code": "type DtPathQueueRef uint32\n",
                "Methods": {}
            },
            "DtProximityGrid": {
                "Name": "DtProximityGrid",
                "Code": "type DtProximityGrid struct {\n\tm_cellSize    float32\n\tm_invCellSize float32\n\n\tm_pool     []DtProximityGridItem\n\tm_poolHead int\n\tm_poolSize int\n\n\tm_buckets     []uint16\n\tm_bucketsSize int\n\n\tm_bounds [4]int\n}\n",
                "Methods": {
                    "addItem": {
                        "Name": "addItem",
                        "Code": "func (this *DtProximityGrid) addItem(id uint16, minx, miny, maxx, maxy float32) {\n\tvar iminx = int(detour.DtMathFloorf(minx * this.m_invCellSize))\n\tvar iminy = int(detour.DtMathFloorf(miny * this.m_invCellSize))\n\tvar imaxx = int(detour.DtMathFloorf(maxx * this.m_invCellSize))\n\tvar imaxy = int(detour.DtMathFloorf(maxy * this.m_invCellSize))\n\n\tthis.m_bounds[0] = detour.DtMinInt(this.m_bounds[0], iminx)\n\tthis.m_bounds[1] = detour.DtMinInt(this.m_bounds[1], iminy)\n\tthis.m_bounds[2] = detour.DtMinInt(this.m_bounds[2], imaxx)\n\tthis.m_bounds[3] = detour.DtMinInt(this.m_bounds[3], imaxy)\n\n\tvar h int\n\tvar idx uint16\n\tfor y := iminy; y \u003c= imaxy; y += 1 {\n\t\tfor x := iminx; x \u003c= imaxx; x += 1 {\n\t\t\tif this.m_poolHead \u003c this.m_poolSize {\n\t\t\t\th = hashPos2(x, y, this.m_bucketsSize)\n\t\t\t\tidx = uint16(this.m_poolHead)\n\t\t\t\tthis.m_poolHead += 1\n\n\t\t\t\tvar item = \u0026this.m_pool[idx]\n\t\t\t\titem.x = int16(x)\n\t\t\t\titem.y = int16(y)\n\t\t\t\titem.id = id\n\t\t\t\titem.next = this.m_buckets[h]\n\t\t\t\tthis.m_buckets[h] = idx\n\t\t\t}\n\t\t}\n\t}\n}\n"
                    },
                    "clear": {
                        "Name": "clear",
                        "Code": "func (this *DtProximityGrid) clear() {\n\tfor i := range this.m_buckets {\n\t\tthis.m_buckets[i] = 0xffff\n\t}\n\tthis.m_poolHead = 0\n\tthis.m_bounds[0] = 0xffff\n\tthis.m_bounds[1] = 0xffff\n\tthis.m_bounds[2] = -0xffff\n\tthis.m_bounds[3] = -0xffff\n}\n"
                    },
                    "getItemCountAt": {
                        "Name": "getItemCountAt",
                        "Code": "func (this *DtProximityGrid) getItemCountAt(x, y int) int {\n\tvar n int\n\n\tvar h = hashPos2(x, y, this.m_bucketsSize)\n\tvar idx = this.m_buckets[h]\n\n\tfor idx != 0xffff {\n\t\tvar item = \u0026this.m_pool[idx]\n\t\tif int(item.x) == x \u0026\u0026 int(item.y) == y {\n\t\t\tn += 1\n\t\t}\n\t\tidx = item.next\n\t}\n\treturn n\n}\n"
                    },
                    "init": {
                        "Name": "init",
                        "Code": "func (this *DtProximityGrid) init(poolSize int, cellSize float32) bool {\n\tdetour.DtAssert(poolSize \u003e 0)\n\tdetour.DtAssert(cellSize \u003e 0)\n\n\tthis.m_cellSize = cellSize\n\tthis.m_invCellSize = 1.0 / this.m_cellSize\n\n\tthis.m_bucketsSize = int(detour.DtNextPow2(uint32(poolSize)))\n\tthis.m_buckets = make([]uint16, this.m_bucketsSize)\n\tif len(this.m_buckets) \u003c= 0 {\n\t\treturn false\n\t}\n\n\tthis.m_poolSize = poolSize\n\tthis.m_poolHead = 0\n\tthis.m_pool = make([]DtProximityGridItem, this.m_poolSize)\n\tif len(this.m_pool) \u003c= 0 {\n\t\treturn false\n\t}\n\n\tthis.clear()\n\n\treturn true\n}\n"
                    },
                    "queryItems": {
                        "Name": "queryItems",
                        "Code": "func (this *DtProximityGrid) queryItems(minx, miny, maxx, maxy float32,\n\tids []uint16, maxIds int) int {\n\tvar iminx = int(detour.DtMathFloorf(minx * this.m_invCellSize))\n\tvar iminy = int(detour.DtMathFloorf(miny * this.m_invCellSize))\n\tvar imaxx = int(detour.DtMathFloorf(maxx * this.m_invCellSize))\n\tvar imaxy = int(detour.DtMathFloorf(maxy * this.m_invCellSize))\n\n\tvar n int\n\tvar h int\n\tvar idx uint16\n\tfor y := iminy; y \u003c= imaxy; y += 1 {\n\t\tfor x := iminx; x \u003c= imaxx; x += 1 {\n\t\t\th = hashPos2(x, y, this.m_bucketsSize)\n\t\t\tidx = this.m_buckets[h]\n\t\t\tfor idx != 0xffff {\n\t\t\t\tvar item = \u0026this.m_pool[idx]\n\t\t\t\tif int(item.x) == x \u0026\u0026 int(item.y) == y {\n\t\t\t\t\tvar alreadyExist bool\n\t\t\t\t\tfor i := 0; i \u003c n; i++ {\n\t\t\t\t\t\tif ids[i] == item.id {\n\t\t\t\t\t\t\talreadyExist = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !alreadyExist {\n\t\t\t\t\t\tif n \u003e= maxIds {\n\t\t\t\t\t\t\treturn n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tids[n] = item.id\n\t\t\t\t\t\tn += 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx = item.next\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n\n}\n"
                    }
                }
            },
            "DtProximityGridItem": {
                "Name": "DtProximityGridItem",
                "Code": "type DtProximityGridItem struct {\n\tid   uint16\n\tx    int16\n\ty    int16\n\tnext uint16\n}\n",
                "Methods": {}
            },
            "MoveRequestState": {
                "Name": "MoveRequestState",
                "Code": "type MoveRequestState int\r",
                "Methods": {}
            },
            "PathQuery": {
                "Name": "PathQuery",
                "Code": "type PathQuery struct {\n\tref DtPathQueueRef\n\t/// Path find start and end location.\n\tstartPos [3]float32\n\tendPos   [3]float32\n\tstartRef detour.DtPolyRef\n\tendRef   detour.DtPolyRef\n\t/// Result.\n\tpath  []detour.DtPolyRef\n\tnpath int\n\t/// State.\n\tstatus    detour.DtStatus\n\tkeepAlive int\n\tfilter    *detour.DtQueryFilter ///\u003c TODO: This is potentially dangerous!\n}\n",
                "Methods": {}
            },
            "UpdateFlags": {
                "Name": "UpdateFlags",
                "Code": "/// Crowd agent update flags.\r\n/// @ingroup crowd\r\n/// @see dtCrowdAgentParams::updateFlags\r\ntype UpdateFlags uint8\r",
                "Methods": {}
            }
        },
        "Functions": {
            "DtAllocCrowd": {
                "Name": "DtAllocCrowd",
                "Code": "func DtAllocCrowd() *DtCrowd {\r\n\tcrowd := \u0026DtCrowd{}\r\n\tfor i := 0; i \u003c len(crowd.m_filters); i++ {\r\n\t\tcrowd.m_filters[i].Reset()\r\n\t}\r\n\treturn crowd\r\n}\r"
            },
            "DtAllocCrowdAgentParams": {
                "Name": "DtAllocCrowdAgentParams",
                "Code": "func DtAllocCrowdAgentParams() *DtCrowdAgentParams {\r\n\tparams := \u0026DtCrowdAgentParams{}\r\n\treturn params\r\n}\r"
            },
            "DtAllocObstacleAvoidanceQuery": {
                "Name": "DtAllocObstacleAvoidanceQuery",
                "Code": "func DtAllocObstacleAvoidanceQuery() *DtObstacleAvoidanceQuery {\n\tquery := \u0026DtObstacleAvoidanceQuery{}\n\treturn query\n}\n"
            },
            "DtAllocProximityGrid": {
                "Name": "DtAllocProximityGrid",
                "Code": "func DtAllocProximityGrid() *DtProximityGrid {\n\tgrid := \u0026DtProximityGrid{}\n\treturn grid\n}\n"
            },
            "addNeighbour": {
                "Name": "addNeighbour",
                "Code": "func addNeighbour(idx int, dist float32, neis []DtCrowdNeighbour, nneis int, maxNeis int) int {\r\n\t// Insert neighbour based on the distance.\r\n\tvar nei *DtCrowdNeighbour\r\n\tif nneis \u003c= 0 {\r\n\t\tnei = \u0026neis[nneis]\r\n\t} else if dist \u003e= neis[nneis-1].dist {\r\n\t\tif nneis \u003e= maxNeis {\r\n\t\t\treturn nneis\r\n\t\t}\r\n\t\tnei = \u0026neis[nneis]\r\n\t} else {\r\n\t\tvar i int\r\n\t\tfor ; i \u003c nneis; i += 1 {\r\n\t\t\tif dist \u003c= neis[i].dist {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar tgt = i + 1\r\n\t\tvar n = detour.DtMinInt(nneis-i, maxNeis-tgt)\r\n\r\n\t\tdetour.DtAssert(tgt+n \u003c= maxNeis)\r\n\r\n\t\tif n \u003e 0 {\r\n\t\t\tcopy(neis[tgt:], neis[i:i+n])\r\n\t\t}\r\n\t\tnei = \u0026neis[i]\r\n\t}\r\n\r\n\tnei.idx = idx\r\n\tnei.dist = dist\r\n\r\n\treturn detour.DtMinInt(nneis+1, maxNeis)\r\n}\r"
            },
            "addToOptQueue": {
                "Name": "addToOptQueue",
                "Code": "func addToOptQueue(newag *DtCrowdAgent, agents []*DtCrowdAgent, nagents int, maxAgents int) int {\r\n\t// Insert neighbour based on greatest time.\r\n\tvar slot int\r\n\tif nagents \u003c= 0 {\r\n\t\tslot = nagents\r\n\t} else if newag.topologyOptTime \u003c= agents[nagents-1].topologyOptTime {\r\n\t\tif nagents \u003e= maxAgents {\r\n\t\t\treturn nagents\r\n\t\t}\r\n\t\tslot = nagents\r\n\t} else {\r\n\t\tvar i int\r\n\t\tfor ; i \u003c nagents; i += 1 {\r\n\t\t\tif newag.topologyOptTime \u003e= agents[i].topologyOptTime {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar tgt = i + 1\r\n\t\tvar n = detour.DtMinInt(nagents-i, maxAgents-tgt)\r\n\r\n\t\tdetour.DtAssert(tgt+n \u003c= maxAgents)\r\n\r\n\t\tif n \u003e 0 {\r\n\t\t\tcopy(agents[tgt:], agents[i:i+n])\r\n\t\t}\r\n\t\tslot = i\r\n\t}\r\n\tagents[slot] = newag\r\n\r\n\treturn detour.DtMinInt(nagents+1, maxAgents)\r\n}\r"
            },
            "addToPathQueue": {
                "Name": "addToPathQueue",
                "Code": "func addToPathQueue(newag *DtCrowdAgent, agents []*DtCrowdAgent, nagents int, maxAgents int) int {\r\n\t// Insert neighbour based on greatest time.\r\n\tvar slot int\r\n\tif nagents \u003c= 0 {\r\n\t\tslot = nagents\r\n\t} else if newag.targetReplanTime \u003c= agents[nagents-1].targetReplanTime {\r\n\t\tif nagents \u003e= maxAgents {\r\n\t\t\treturn nagents\r\n\t\t}\r\n\t\tslot = nagents\r\n\t} else {\r\n\t\tvar i int\r\n\t\tfor ; i \u003c nagents; i += 1 {\r\n\t\t\tif newag.targetReplanTime \u003e= agents[i].targetReplanTime {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar tgt = i + 1\r\n\t\tvar n = detour.DtMinInt(nagents-i, maxAgents-tgt)\r\n\r\n\t\tdetour.DtAssert(tgt+n \u003c= maxAgents)\r\n\t\tif n \u003e 0 {\r\n\t\t\tcopy(agents[tgt:], agents[i:i+n])\r\n\t\t}\r\n\t\tslot = i\r\n\t}\r\n\tagents[slot] = newag\r\n\r\n\treturn detour.DtMinInt(nagents+1, maxAgents)\r\n}\r"
            },
            "calcSmoothSteerDirection": {
                "Name": "calcSmoothSteerDirection",
                "Code": "func calcSmoothSteerDirection(ag *DtCrowdAgent, dir []float32) {\r\n\tif ag.ncorners \u003c= 0 {\r\n\t\tdetour.DtVset(dir, 0, 0, 0)\r\n\t\treturn\r\n\t}\r\n\r\n\tvar ip0 int\r\n\tvar ip1 = detour.DtMinInt(1, ag.ncorners-1)\r\n\tvar p0 = ag.cornerVerts[ip0*3:]\r\n\tvar p1 = ag.cornerVerts[ip1*3:]\r\n\r\n\tvar dir0, dir1 [3]float32\r\n\tdetour.DtVsub(dir0[:], p0, ag.npos[:])\r\n\tdetour.DtVsub(dir1[:], p1, ag.npos[:])\r\n\tdir0[1] = 0\r\n\tdir1[1] = 0\r\n\r\n\tvar len0 = detour.DtVlen(dir0[:])\r\n\tvar len1 = detour.DtVlen(dir1[:])\r\n\tif len1 \u003e 0.001 {\r\n\t\tdetour.DtVscale(dir1[:], dir1[:], 1/len1)\r\n\t}\r\n\r\n\tdir[0] = dir0[0] - dir1[0]*len0*0.5\r\n\tdir[1] = 0\r\n\tdir[2] = dir0[2] - dir1[2]*len0*0.5\r\n\r\n\tdetour.DtVnormalize(dir)\r\n}\r"
            },
            "calcStraightSteerDirection": {
                "Name": "calcStraightSteerDirection",
                "Code": "func calcStraightSteerDirection(ag *DtCrowdAgent, dir []float32) {\r\n\tif ag.ncorners \u003c= 0 {\r\n\t\tdetour.DtVset(dir, 0, 0, 0)\r\n\t\treturn\r\n\t}\r\n\tdetour.DtVsub(dir, ag.cornerVerts[:], ag.npos[:])\r\n\tdir[1] = 0\r\n\tdetour.DtVnormalize(dir)\r\n}\r"
            },
            "dtMergeCorridorEndMoved": {
                "Name": "dtMergeCorridorEndMoved",
                "Code": "func dtMergeCorridorEndMoved(path []detour.DtPolyRef, npath, maxPath int,\n\tvisited []detour.DtPolyRef, nvisited int) int {\n\tvar furthestPath = -1\n\tvar furthestVisited = -1\n\n\t// Find furthest common polygon.\n\tfor i := 0; i \u003c npath; i += 1 {\n\t\tvar found = false\n\t\tfor j := nvisited - 1; j \u003e= 0; j -= 1 {\n\t\t\tif path[i] == visited[j] {\n\t\t\t\tfurthestPath = i\n\t\t\t\tfurthestVisited = j\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If no intersection found just return current path.\n\tif furthestPath == -1 || furthestVisited == -1 {\n\t\treturn npath\n\t}\n\n\t// Concatenate paths.\n\tvar ppos = furthestPath + 1\n\tvar vpos = furthestVisited + 1\n\tvar count = detour.DtMinInt(nvisited-vpos, maxPath-ppos)\n\tdetour.DtAssert(ppos+count \u003c= maxPath)\n\tif count \u003e 0 {\n\t\t// memcpy(path+ppos, visited+vpos, sizeof(dtPolyRef)*count)\n\t\tcopy(path[ppos:], visited[vpos:vpos+count])\n\t}\n\n\treturn ppos + count\n}\n"
            },
            "dtMergeCorridorStartMoved": {
                "Name": "dtMergeCorridorStartMoved",
                "Code": "func dtMergeCorridorStartMoved(path []detour.DtPolyRef, npath, maxPath int,\n\tvisited []detour.DtPolyRef, nvisited int) int {\n\tvar furthestPath = -1\n\tvar furthestVisited = -1\n\n\t// Find furthest common polygon.\n\tfor i := npath - 1; i \u003e= 0; i -= 1 {\n\t\tvar found = false\n\t\tfor j := nvisited - 1; j \u003e= 0; j -= 1 {\n\t\t\tif path[i] == visited[j] {\n\t\t\t\tfurthestPath = i\n\t\t\t\tfurthestVisited = j\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If no intersection found just return current path.\n\tif furthestPath == -1 || furthestVisited == -1 {\n\t\treturn npath\n\t}\n\n\t// Concatenate paths.\n\n\t// Adjust beginning of the buffer to include the visited.\n\tvar req = nvisited - furthestVisited\n\tvar orig = detour.DtMinInt(furthestPath+1, npath)\n\tvar size = detour.DtMaxInt(0, npath-orig)\n\tif req+size \u003e maxPath {\n\t\tsize = maxPath - req\n\t}\n\tif size \u003e 0 {\n\t\t// memmove(path+req, path+orig, size*sizeof(dtPolyRef));\n\t\tcopy(path[req:], path[orig:orig+size])\n\t}\n\n\t// Store visited\n\tfor i := 0; i \u003c req; i += 1 {\n\t\tpath[i] = visited[(nvisited-1)-i]\n\t}\n\n\treturn req + size\n}\n"
            },
            "dtMergeCorridorStartShortcut": {
                "Name": "dtMergeCorridorStartShortcut",
                "Code": "func dtMergeCorridorStartShortcut(path []detour.DtPolyRef, npath, maxPath int,\n\tvisited []detour.DtPolyRef, nvisited int) int {\n\tvar furthestPath = -1\n\tvar furthestVisited = -1\n\n\t// Find furthest common polygon.'\n\tfor i := npath - 1; i \u003e= 0; i -= 1 {\n\t\tvar found bool\n\t\tfor j := nvisited - 1; j \u003e= 0; j -= 1 {\n\t\t\tif path[i] == visited[j] {\n\t\t\t\tfurthestPath = i\n\t\t\t\tfurthestVisited = j\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If no intersection found just return current path. '\n\tif furthestPath == -1 || furthestVisited == -1 {\n\t\treturn npath\n\t}\n\n\t// Concatenate paths.\n\n\t// Adjust beginning of the buffer to include the visited.\n\tvar req = furthestVisited\n\tif req \u003c= 0 {\n\t\treturn npath\n\t}\n\n\tvar orig = furthestPath\n\tvar size = detour.DtMaxInt(0, npath-orig)\n\tif req+size \u003e maxPath {\n\t\tsize = maxPath - req\n\t}\n\tif size \u003e 0 {\n\t\t// memmove(path+req, path+orig, size*sizeof(dtPolyRef));\n\t\tcopy(path[req:], path[orig:orig+size])\n\t}\n\n\t// Store visited\n\tfor i := 0; i \u003c req; i += 1 {\n\t\tpath[i] = visited[i]\n\t}\n\n\treturn req + size\n}\n"
            },
            "dtNormalize2D": {
                "Name": "dtNormalize2D",
                "Code": "func dtNormalize2D(v []float32) {\n\tvar d = detour.DtMathSqrtf(v[0]*v[0] + v[2]*v[2])\n\tif d == 0 {\n\t\treturn\n\t}\n\td = 1.0 / d\n\tv[0] *= d\n\tv[2] *= d\n}\n"
            },
            "dtRorate2D": {
                "Name": "dtRorate2D",
                "Code": "func dtRorate2D(dest []float32, v []float32, ang float32) {\n\tvar c = float32(math.Cos(float64(ang)))\n\tvar s = float32(math.Sin(float64(ang)))\n\tdest[0] = v[0]*c - v[2]*s\n\tdest[2] = v[0]*s + v[2]*c\n\tdest[1] = v[1]\n}\n"
            },
            "getDistanceToGoal": {
                "Name": "getDistanceToGoal",
                "Code": "func getDistanceToGoal(ag *DtCrowdAgent, ranged float32) float32 {\r\n\tif ag.ncorners \u003c= 0 {\r\n\t\treturn ranged\r\n\t}\r\n\r\n\tvar endOfPath = ag.cornerFlags[ag.ncorners-1]\u0026detour.DT_STRAIGHTPATH_END \u003e 0\r\n\tif endOfPath {\r\n\t\treturn detour.DtMinFloat32(detour.DtVdist2D(ag.npos[:], ag.cornerVerts[(ag.ncorners-1)*3:]), ranged)\r\n\t}\r\n\treturn ranged\r\n}\r"
            },
            "getNeighbours": {
                "Name": "getNeighbours",
                "Code": "func getNeighbours(pos []float32, height, ranged float32, skip *DtCrowdAgent, result []DtCrowdNeighbour, maxResult int,\r\n\tagents []*DtCrowdAgent, _ int, grid *DtProximityGrid) int {\r\n\tconst MAX_NEIS = 32\r\n\r\n\tvar n int\r\n\tvar ids [MAX_NEIS]uint16\r\n\tvar nids = grid.queryItems(pos[0]-ranged, pos[2]-ranged,\r\n\t\tpos[0]+ranged, pos[2]+ranged,\r\n\t\tids[:], MAX_NEIS)\r\n\r\n\tfor i := 0; i \u003c nids; i += 1 {\r\n\t\tvar ag = agents[ids[i]]\r\n\t\tif ag == skip {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\t// Check for overlap.\r\n\t\tvar diff [3]float32\r\n\t\tdetour.DtVsub(diff[:], pos, ag.npos[:])\r\n\t\tif detour.DtMathFabsf(diff[1]) \u003e= (height+ag.params.height)/2 {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdiff[1] = 0\r\n\t\tvar distSqr = detour.DtVlenSqr(diff[:])\r\n\t\tif distSqr \u003e detour.DtSqrFloat32(ranged) {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tn = addNeighbour(int(ids[i]), distSqr, result, n, maxResult)\r\n\t}\r\n\treturn n\r\n}\r"
            },
            "hashPos2": {
                "Name": "hashPos2",
                "Code": "func hashPos2(x int, y int, n int) int {\n\treturn ((x * 73856093) ^ (y * 19349663)) \u0026 (n - 1)\n}\n"
            },
            "integrate": {
                "Name": "integrate",
                "Code": "func integrate(ag *DtCrowdAgent, dt float32) {\r\n\t// Fake dynamic constraint.\r\n\tvar maxDelta = ag.params.maxAcceleration * dt\r\n\tvar dv [3]float32\r\n\tdetour.DtVsub(dv[:], ag.nvel[:], ag.vel[:])\r\n\tvar ds = detour.DtVlen(dv[:])\r\n\tif ds \u003e maxDelta {\r\n\t\tdetour.DtVscale(dv[:], dv[:], maxDelta/ds)\r\n\t}\r\n\tdetour.DtVadd(ag.vel[:], ag.vel[:], dv[:])\r\n\r\n\t// Integrate\r\n\tif detour.DtVlen(ag.vel[:]) \u003e 0.0001 {\r\n\t\tdetour.DtVmad(ag.npos[:], ag.npos[:], ag.vel[:], dt)\r\n\t} else {\r\n\t\tdetour.DtVset(ag.vel[:], 0, 0, 0)\r\n\t}\r\n}\r"
            },
            "isectRaySeg": {
                "Name": "isectRaySeg",
                "Code": "func isectRaySeg(ap, u, bp, bq []float32, t *float32) int {\n\tvar v, w [3]float32\n\tdetour.DtVsub(v[:], bq, bp)\n\tdetour.DtVsub(w[:], ap, bp)\n\tvar d = detour.DtVperp2D(u, v[:])\n\tif detour.DtMathFabsf(d) \u003c 1e-6 {\n\t\treturn 0\n\t}\n\td = 1.0 / d\n\t*t = detour.DtVperp2D(v[:], w[:]) * d\n\tif *t \u003c 0 || *t \u003e 1 {\n\t\treturn 0\n\t}\n\tvar s = detour.DtVperp2D(u, w[:]) * d\n\tif s \u003c 0 || s \u003e 1 {\n\t\treturn 0\n\t}\n\treturn 1\n}\n"
            },
            "normalizeArray": {
                "Name": "normalizeArray",
                "Code": "func normalizeArray(arr []float32, n int) {\n\t// Normalize penaly range.\n\tvar minPen = float32(math.MaxFloat32)\n\tvar maxPen = -float32(math.MaxFloat32)\n\tfor i := 0; i \u003c n; i++ {\n\t\tminPen = detour.DtMinFloat32(minPen, arr[i])\n\t\tmaxPen = detour.DtMaxFloat32(maxPen, arr[i])\n\t}\n\tvar penRange = maxPen - minPen\n\tvar s = float32(1)\n\tif penRange \u003e 0.001 {\n\t\ts = 1 / penRange\n\t}\n\tfor i := 0; i \u003c n; i += 1 {\n\t\tarr[i] = detour.DtClampFloat32((arr[i]-minPen)*s, 0, 1)\n\t}\n}\n"
            },
            "overOffmeshConnection": {
                "Name": "overOffmeshConnection",
                "Code": "func overOffmeshConnection(ag *DtCrowdAgent, radius float32) bool {\r\n\tif ag.ncorners \u003c= 0 {\r\n\t\treturn false\r\n\t}\r\n\r\n\tvar offMeshConnection bool\r\n\tif ag.cornerFlags[ag.ncorners-1]\u0026detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION \u003e 0 {\r\n\t\toffMeshConnection = true\r\n\t}\r\n\tif offMeshConnection {\r\n\t\tvar distSq = detour.DtVdist2DSqr(ag.npos[:], ag.cornerVerts[(ag.ncorners-1)*3:])\r\n\t\tif distSq \u003c radius*radius {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r"
            },
            "sweepCircleCircle": {
                "Name": "sweepCircleCircle",
                "Code": "func sweepCircleCircle(c0 []float32, r0 float32, v []float32,\n\tc1 []float32, r1 float32,\n\ttmin *float32, tmax *float32) int {\n\tconst EPS float32 = 0.0001\n\tvar s [3]float32\n\tdetour.DtVsub(s[:], c1, c0)\n\tvar r = r0 + r1\n\tvar c = detour.DtVdot2D(s[:], s[:]) - r*r\n\tvar a = detour.DtVdot2D(v, v)\n\tif a \u003c EPS {\n\t\treturn 0\n\t} // not moving\n\n\t// Overlap, calc time to exit.\n\tvar b = detour.DtVdot2D(v, s[:])\n\tvar d = b*b - a*c\n\tif d \u003c 0.0 {\n\t\treturn 0 // no intersection.\n\t}\n\ta = 1.0 / a\n\tvar rd = detour.DtMathSqrtf(d)\n\t*tmin = (b - rd) * a\n\t*tmax = (b + rd) * a\n\treturn 1\n}\n"
            },
            "tween": {
                "Name": "tween",
                "Code": "func tween(t, t0, t1 float32) float32 {\r\n\treturn detour.DtClampFloat32((t-t0)/(t1-t0), 0, 1)\r\n}\r"
            }
        }
    },
    {
        "Name": "debugger",
        "Structs": {
            "DebugDrawerPrimitive": {
                "Name": "DebugDrawerPrimitive",
                "Code": "type DebugDrawerPrimitive struct {\r\n\tPrimitiveType duDebugDrawPrimitives `json:\"type\"`\r\n\tVertices      [][7]float32          `json:\"vertices\"`\r\n}\r",
                "Methods": {}
            },
            "DrawNavMeshFlags": {
                "Name": "DrawNavMeshFlags",
                "Code": "type DrawNavMeshFlags int\r",
                "Methods": {}
            },
            "NavInfo": {
                "Name": "NavInfo",
                "Code": "type NavInfo struct {\r\n\tPrimitives []*DebugDrawerPrimitive `json:\"primitives\"`\r\n\tAgents     []*ServerAgent          `json:\"agents\"`\r\n\tParams     *ServerAgentParams      `json:\"agent_params\"`\r\n}\r",
                "Methods": {}
            },
            "Server": {
                "Name": "Server",
                "Code": "type Server struct {\r\n\tmutex       sync.RWMutex\r\n\tdispList    *duDisplayList\r\n\tnavmesh     *detour.DtNavMesh\r\n\ttilecache   *dtcache.DtTileCache\r\n\tcrowd       *dtcrowd.DtCrowd\r\n\tagents      []*ServerAgent\r\n\tagentParams ServerAgentParams\r\n}\r",
                "Methods": {
                    "AddAgent": {
                        "Name": "AddAgent",
                        "Code": "func (s *Server) AddAgent(x, y, z, r, h, speed, acc float32) int {\r\n\ts.mutex.Lock()\r\n\tdefer s.mutex.Unlock()\r\n\r\n\tif s.crowd == nil || s.navmesh == nil {\r\n\t\treturn -1\r\n\t}\r\n\r\n\tvar agentParams = dtcrowd.DtAllocCrowdAgentParams().\r\n\t\tSetRadius(r).\r\n\t\tSetHeight(h).\r\n\t\tSetMaxAcceleration(acc).\r\n\t\tSetMaxSpeed(speed).\r\n\t\tSetCollisionQueryRange(0.3 * 12).\r\n\t\tSetPathOptimizationRange(0.3 * 30)\r\n\ts.agentParams.Radius = r\r\n\ts.agentParams.Height = h\r\n\ts.agentParams.MaxSpeed = speed\r\n\ts.agentParams.MaxAcceleration = acc\r\n\r\n\tidx := s.crowd.AddAgent([]float32{x, y, z}, agentParams)\r\n\tif idx \u003c 0 {\r\n\t\treturn -1\r\n\t}\r\n\r\n\tagent := s.crowd.GetAgent(idx)\r\n\tif agent == nil {\r\n\t\treturn -1\r\n\t}\r\n\r\n\tvar serverAgent *ServerAgent\r\n\tfor _, sa := range s.agents {\r\n\t\tif sa.Id == uint32(idx) {\r\n\t\t\tserverAgent = sa\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif serverAgent == nil {\r\n\t\tserverAgent = \u0026ServerAgent{Id: uint32(idx)}\r\n\t\ts.agents = append(s.agents, serverAgent)\r\n\t}\r\n\r\n\tpos := agent.GetCurrentPos()\r\n\tif len(pos) == 3 {\r\n\t\tdetour.DtVcopy(serverAgent.Pos[:], pos)\r\n\t}\r\n\r\n\treturn idx\r\n}\r"
                    },
                    "ClearAgent": {
                        "Name": "ClearAgent",
                        "Code": "func (s *Server) ClearAgent() {\r\n\tif s.crowd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\ts.mutex.Lock()\r\n\tdefer s.mutex.Unlock()\r\n\r\n\tfor _, sa := range s.agents {\r\n\t\ts.crowd.RemoveAgent(int(sa.Id))\r\n\t}\r\n}\r"
                    },
                    "GetInfo": {
                        "Name": "GetInfo",
                        "Code": "func (s *Server) GetInfo(addMesh bool, flags DrawNavMeshFlags) *NavInfo {\r\n\ts.mutex.RLock()\r\n\tdefer s.mutex.RUnlock()\r\n\r\n\tinfo := \u0026NavInfo{\r\n\t\tParams: \u0026s.agentParams,\r\n\t}\r\n\r\n\tfor _, sa := range s.agents {\r\n\t\tagent := s.crowd.GetAgent(int(sa.Id))\r\n\t\tif agent == nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\ttmp := \u0026ServerAgent{\r\n\t\t\tId: sa.Id,\r\n\t\t}\r\n\t\tpos := agent.GetCurrentPos()\r\n\t\tif len(pos) == 3 {\r\n\t\t\tdetour.DtVcopy(tmp.Pos[:], pos)\r\n\t\t}\r\n\t\tinfo.Agents = append(info.Agents, tmp)\r\n\t}\r\n\r\n\tif s.navmesh != nil \u0026\u0026 addMesh {\r\n\t\tduDebugDrawNavMesh(s.dispList, s.navmesh, DU_DRAWNAVMESH_COLOR_TILES)\r\n\t\tinfo.Primitives = s.dispList.flush()\r\n\t}\r\n\r\n\treturn info\r\n}\r"
                    },
                    "HandleAgentAdd": {
                        "Name": "HandleAgentAdd",
                        "Code": "func (s *Server) HandleAgentAdd(ctx *gin.Context) {\r\n\ttype Params struct {\r\n\t\tPos struct {\r\n\t\t\tX float32 `json:\"x\"`\r\n\t\t\tY float32 `json:\"y\"`\r\n\t\t\tZ float32 `json:\"z\"`\r\n\t\t} `json:\"pos\"`\r\n\t\tRadius          float32 `json:\"radius\"`\r\n\t\tHeight          float32 `json:\"height\"`\r\n\t\tMaxSpeed        float32 `json:\"max_speed\"`\r\n\t\tMaxAcceleration float32 `json:\"max_acceleration\"`\r\n\t}\r\n\r\n\tp := \u0026Params{}\r\n\tif err := ctx.ShouldBindJSON(p); err != nil {\r\n\t\ts.Response(ctx, 3, \"bad params.\", nil)\r\n\t\treturn\r\n\t}\r\n\r\n\ts.ClearAgent()\r\n\tif s.AddAgent(p.Pos.X, p.Pos.Y, p.Pos.Z, p.Radius, p.Height, p.MaxSpeed, p.MaxAcceleration) \u003c 0 {\r\n\t\ts.Response(ctx, 4, \"navmesh not init.\", nil)\r\n\t\treturn\r\n\t}\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(false, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "HandleAgentMove": {
                        "Name": "HandleAgentMove",
                        "Code": "func (s *Server) HandleAgentMove(ctx *gin.Context) {\r\n\ttype Params struct {\r\n\t\tX float32 `json:\"x\"`\r\n\t\tY float32 `json:\"y\"`\r\n\t\tZ float32 `json:\"z\"`\r\n\t}\r\n\r\n\tp := \u0026Params{}\r\n\tif err := ctx.ShouldBindJSON(p); err != nil {\r\n\t\ts.Response(ctx, 3, \"bad params.\", nil)\r\n\t\treturn\r\n\t}\r\n\r\n\ts.SetAgentTarget(p.X, p.Y, p.Z)\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(false, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "HandleAgentTeleport": {
                        "Name": "HandleAgentTeleport",
                        "Code": "func (s *Server) HandleAgentTeleport(ctx *gin.Context) {\r\n\ttype Params struct {\r\n\t\tX float32 `json:\"x\"`\r\n\t\tY float32 `json:\"y\"`\r\n\t\tZ float32 `json:\"z\"`\r\n\t}\r\n\r\n\tp := \u0026Params{}\r\n\tif err := ctx.ShouldBindJSON(p); err != nil {\r\n\t\ts.Response(ctx, 3, \"bad params.\", nil)\r\n\t\treturn\r\n\t}\r\n\r\n\ts.TeleportAgent(p.X, p.Y, p.Z)\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(false, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "HandleAgentUpdate": {
                        "Name": "HandleAgentUpdate",
                        "Code": "func (s *Server) HandleAgentUpdate(ctx *gin.Context) {\r\n\ts.UpdateAgents()\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(false, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "HandleInfo": {
                        "Name": "HandleInfo",
                        "Code": "func (s *Server) HandleInfo(ctx *gin.Context) {\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(true, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "HandleLoad": {
                        "Name": "HandleLoad",
                        "Code": "func (s *Server) HandleLoad(ctx *gin.Context) {\r\n\tnavType := ctx.PostForm(\"type\")\r\n\t// single file\r\n\tfile, _ := ctx.FormFile(\"file\")\r\n\r\n\tfmt.Println(navType, file.Filename)\r\n\tf, err := file.Open()\r\n\tif err != nil {\r\n\t\ts.Response(ctx, 1, \"read file failed.\", nil)\r\n\t\treturn\r\n\t}\r\n\tdefer f.Close()\r\n\r\n\tdata, err := io.ReadAll(f)\r\n\tif err != nil {\r\n\t\ts.Response(ctx, 1, \"read binary data from file failed.\", nil)\r\n\t\treturn\r\n\t}\r\n\r\n\ts.mutex.Lock()\r\n\r\n\tswitch navType {\r\n\tcase \"tilemesh\":\r\n\t\ts.navmesh = loader.LoadTileMeshByBytes(data)\r\n\t\tif s.navmesh == nil {\r\n\t\t\ts.Response(ctx, 2, \"load tile mesh failed.\", nil)\r\n\t\t\treturn\r\n\t\t}\r\n\t\ts.crowd = dtcrowd.DtAllocCrowd()\r\n\t\ts.crowd.Init(1, 10, s.navmesh)\r\n\tcase \"tmpobstacles\":\r\n\t\ts.navmesh, s.tilecache = loader.LoadTempObstaclesByBytes(data)\r\n\t\tif s.navmesh == nil || s.tilecache == nil {\r\n\t\t\ts.Response(ctx, 2, \"load tmpobstacles failed.\", nil)\r\n\t\t\treturn\r\n\t\t}\r\n\t\ts.crowd = dtcrowd.DtAllocCrowd()\r\n\t\ts.crowd.Init(1, 10, s.navmesh)\r\n\t}\r\n\ts.mutex.Unlock()\r\n\r\n\ts.Response(ctx, 0, \"ok\", s.GetInfo(true, DU_DRAWNAVMESH_COLOR_TILES))\r\n}\r"
                    },
                    "Response": {
                        "Name": "Response",
                        "Code": "func (s *Server) Response(ctx *gin.Context, code int, msg string, data any) {\r\n\tctx.JSON(http.StatusOK, gin.H{\r\n\t\t\"code\": code,\r\n\t\t\"msg\":  msg,\r\n\t\t\"data\": data,\r\n\t})\r\n}\r"
                    },
                    "SetAgentTarget": {
                        "Name": "SetAgentTarget",
                        "Code": "func (s *Server) SetAgentTarget(x, y, z float32) {\r\n\tif s.crowd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\ts.mutex.Lock()\r\n\tdefer s.mutex.Unlock()\r\n\r\n\tfor _, sa := range s.agents {\r\n\t\ts.crowd.AgentGoto(int(sa.Id), []float32{x, y, z})\r\n\t}\r\n}\r"
                    },
                    "TeleportAgent": {
                        "Name": "TeleportAgent",
                        "Code": "func (s *Server) TeleportAgent(x, y, z float32) bool {\r\n\tif s.crowd == nil {\r\n\t\treturn false\r\n\t}\r\n\r\n\ts.mutex.Lock()\r\n\tdefer s.mutex.Unlock()\r\n\r\n\tfor _, sa := range s.agents {\r\n\t\ts.crowd.TeleportAgent(int(sa.Id), []float32{x, y, z})\r\n\t}\r\n\treturn true\r\n}\r"
                    },
                    "UpdateAgents": {
                        "Name": "UpdateAgents",
                        "Code": "func (s *Server) UpdateAgents() {\r\n\ts.mutex.Lock()\r\n\tdefer s.mutex.Unlock()\r\n\r\n\tif s.crowd == nil {\r\n\t\treturn\r\n\t}\r\n\t// todo update once\r\n\ts.crowd.Update(0.025, nil)\r\n\r\n\tfor _, sa := range s.agents {\r\n\t\tagent := s.crowd.GetAgent(int(sa.Id))\r\n\t\tif agent == nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tpos := agent.GetCurrentPos()\r\n\t\tif len(pos) == 3 {\r\n\t\t\tdetour.DtVcopy(sa.Pos[:], pos)\r\n\t\t}\r\n\t}\r\n}\r"
                    }
                }
            },
            "ServerAgent": {
                "Name": "ServerAgent",
                "Code": "type ServerAgent struct {\r\n\tId  uint32     `json:\"id\"`\r\n\tPos [3]float32 `json:\"pos\"`\r\n}\r",
                "Methods": {}
            },
            "ServerAgentParams": {
                "Name": "ServerAgentParams",
                "Code": "type ServerAgentParams struct {\r\n\tRadius          float32 `json:\"radius\"`\r\n\tHeight          float32 `json:\"height\"`\r\n\tMaxSpeed        float32 `json:\"max_speed\"`\r\n\tMaxAcceleration float32 `json:\"max_acceleration\"`\r\n}\r",
                "Methods": {}
            },
            "duDebugDraw": {
                "Name": "duDebugDraw",
                "Code": "type duDebugDraw interface {\r\n\tdepthMask(state bool)\r\n\ttexture(state bool)\r\n\tbegin(prim duDebugDrawPrimitives, size float32)\r\n\tvertex0(pos []float32, color uint32)\r\n\tvertex1(x, y, z float32, color uint32)\r\n\tvertex2(pos []float32, color uint32, uv []float32)\r\n\tvertex3(x, y, z float32, color uint32, u, v float32)\r\n\tend()\r\n\tareaToCol(area uint32) uint32\r\n}\r",
                "Methods": {}
            },
            "duDebugDrawPrimitives": {
                "Name": "duDebugDrawPrimitives",
                "Code": "type duDebugDrawPrimitives int\r",
                "Methods": {}
            },
            "duDisplayList": {
                "Name": "duDisplayList",
                "Code": "type duDisplayList struct {\r\n\tm_pos   []float32\r\n\tm_color []uint32\r\n\tm_size  int\r\n\tm_cap   int\r\n\r\n\tm_prim      duDebugDrawPrimitives\r\n\tm_primSize  float32\r\n\tm_depthMask bool\r\n\tm_primList  []*DebugDrawerPrimitive\r\n}\r",
                "Methods": {
                    "areaToCol": {
                        "Name": "areaToCol",
                        "Code": "func (disp *duDisplayList) areaToCol(area uint32) uint32 {\r\n\tif area == 0 {\r\n\t\t// Treat zero area type as default.\r\n\t\treturn duRGBA(0, 192, 255, 255)\r\n\t} else {\r\n\t\treturn duIntToCol(area, 255)\r\n\t}\r\n}\r"
                    },
                    "begin": {
                        "Name": "begin",
                        "Code": "func (disp *duDisplayList) begin(prim duDebugDrawPrimitives, size float32) {\r\n\tdisp.clear()\r\n\tdisp.m_prim = prim\r\n\tdisp.m_primSize = size\r\n}\r"
                    },
                    "clear": {
                        "Name": "clear",
                        "Code": "func (disp *duDisplayList) clear() {\r\n\tdisp.m_size = 0\r\n}\r"
                    },
                    "depthMask": {
                        "Name": "depthMask",
                        "Code": "func (disp *duDisplayList) depthMask(state bool) {\r\n\tdisp.m_depthMask = state\r\n}\r"
                    },
                    "draw": {
                        "Name": "draw",
                        "Code": "func (disp *duDisplayList) draw(dd duDebugDraw) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tif disp.m_size \u003c= 0 {\r\n\t\treturn\r\n\t}\r\n\tdd.depthMask(disp.m_depthMask)\r\n\tdd.begin(disp.m_prim, disp.m_primSize)\r\n\tfor i := 0; i \u003c disp.m_size; i += 1 {\r\n\t\tdd.vertex0(disp.m_pos[i*3:], disp.m_color[i])\r\n\t}\r\n\tdd.end()\r\n}\r"
                    },
                    "end": {
                        "Name": "end",
                        "Code": "func (disp *duDisplayList) end() {\r\n\r\n\ttmp := \u0026DebugDrawerPrimitive{\r\n\t\tPrimitiveType: disp.m_prim,\r\n\t}\r\n\tfor i := 0; i \u003c disp.m_size; i += 1 {\r\n\t\ttmp.Vertices = append(tmp.Vertices,\r\n\t\t\t[7]float32{disp.m_pos[i*3],\r\n\t\t\t\tdisp.m_pos[i*3+1],\r\n\t\t\t\tdisp.m_pos[i*3+2],\r\n\t\t\t\tfloat32(disp.m_color[i]\u00260xff) / 255,\r\n\t\t\t\tfloat32((disp.m_color[i]\u003e\u003e8)\u00260xff) / 255,\r\n\t\t\t\tfloat32((disp.m_color[i]\u003e\u003e16)\u00260xff) / 255,\r\n\t\t\t\tfloat32((disp.m_color[i]\u003e\u003e24)\u00260xff) / 255,\r\n\t\t\t},\r\n\t\t)\r\n\t}\r\n\tdisp.m_primList = append(disp.m_primList, tmp)\r\n}\r"
                    },
                    "flush": {
                        "Name": "flush",
                        "Code": "func (disp *duDisplayList) flush() []*DebugDrawerPrimitive {\r\n\tcur := disp.m_primList\r\n\tdisp.m_primList = nil\r\n\treturn cur\r\n}\r"
                    },
                    "resize": {
                        "Name": "resize",
                        "Code": "func (disp *duDisplayList) resize(cap int) {\r\n\tnewPos := make([]float32, cap*3)\r\n\tif len(disp.m_pos) \u003e 0 {\r\n\t\tcopy(newPos, disp.m_pos)\r\n\t}\r\n\tdisp.m_pos = newPos\r\n\r\n\tnewColor := make([]uint32, cap)\r\n\tif len(disp.m_color) \u003e 0 {\r\n\t\tcopy(newColor, disp.m_color)\r\n\t}\r\n\tdisp.m_color = newColor\r\n\r\n\tdisp.m_cap = cap\r\n}\r"
                    },
                    "texture": {
                        "Name": "texture",
                        "Code": "func (disp *duDisplayList) texture(state bool) {\r\n\r\n}\r"
                    },
                    "vertex0": {
                        "Name": "vertex0",
                        "Code": "func (disp *duDisplayList) vertex0(pos []float32, color uint32) {\r\n\tdisp.vertex1(pos[0], pos[1], pos[2], color)\r\n}\r"
                    },
                    "vertex1": {
                        "Name": "vertex1",
                        "Code": "func (disp *duDisplayList) vertex1(x, y, z float32, color uint32) {\r\n\tif disp.m_size+1 \u003e= disp.m_cap {\r\n\t\tdisp.resize(disp.m_cap * 2)\r\n\t}\r\n\tvar p = disp.m_pos[disp.m_size*3:]\r\n\tp[0] = x\r\n\tp[1] = y\r\n\tp[2] = z\r\n\tdisp.m_color[disp.m_size] = color\r\n\tdisp.m_size += 1\r\n}\r"
                    },
                    "vertex2": {
                        "Name": "vertex2",
                        "Code": "func (disp *duDisplayList) vertex2(pos []float32, color uint32, uv []float32) {\r\n\r\n}\r"
                    },
                    "vertex3": {
                        "Name": "vertex3",
                        "Code": "func (disp *duDisplayList) vertex3(x, y, z float32, color uint32, u, v float32) {\r\n\r\n}\r"
                    }
                }
            }
        },
        "Functions": {
            "NewDisplayList": {
                "Name": "NewDisplayList",
                "Code": "func NewDisplayList(cap int) *duDisplayList {\r\n\tdisp := \u0026duDisplayList{\r\n\t\tm_prim:      DU_DRAW_LINES,\r\n\t\tm_primSize:  1,\r\n\t\tm_depthMask: true,\r\n\t}\r\n\tif cap \u003c 8 {\r\n\t\tcap = 8\r\n\t}\r\n\tdisp.resize(cap)\r\n\treturn disp\r\n}\r"
            },
            "NewServer": {
                "Name": "NewServer",
                "Code": "func NewServer(r *gin.Engine) *Server {\r\n\tserver := \u0026Server{\r\n\t\tdispList: NewDisplayList(256),\r\n\t\tagentParams: ServerAgentParams{\r\n\t\t\tRadius:          0.3,\r\n\t\t\tHeight:          2,\r\n\t\t\tMaxSpeed:        6,\r\n\t\t\tMaxAcceleration: 20,\r\n\t\t},\r\n\t}\r\n\tr.GET(\"/info\", server.HandleInfo)\r\n\tr.POST(\"/load\", server.HandleLoad)\r\n\r\n\tagentGroup := r.Group(\"/agent\")\r\n\t{\r\n\t\tagentGroup.POST(\"/add\", server.HandleAgentAdd)\r\n\t\tagentGroup.POST(\"/move\", server.HandleAgentMove)\r\n\t\tagentGroup.POST(\"/update\", server.HandleAgentUpdate)\r\n\t\tagentGroup.POST(\"/teleport\", server.HandleAgentTeleport)\r\n\t}\r\n\r\n\treturn server\r\n}\r"
            },
            "appendArrowHead": {
                "Name": "appendArrowHead",
                "Code": "func appendArrowHead(dd duDebugDraw, p, q []float32, s float32, col uint32) {\r\n\tconst eps = 0.001\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tif vdistSqr(p, q) \u003c eps*eps {\r\n\t\treturn\r\n\t}\r\n\tvar ax = [3]float32{0, 1, 0}\r\n\tvar ay = [3]float32{0, 1, 0}\r\n\tvar az = [3]float32{0, 0, 0}\r\n\tvsub(az[:], q, p)\r\n\tvnormalize(az[:])\r\n\tvcross(ax[:], ay[:], az[:])\r\n\tvcross(ay[:], az[:], ax[:])\r\n\tvnormalize(ay[:])\r\n\r\n\tdd.vertex0(p, col)\r\n\t//\tdd.vertex(p[0]+az[0]*s+ay[0]*s/2, p[1]+az[1]*s+ay[1]*s/2, p[2]+az[2]*s+ay[2]*s/2, col);\r\n\tdd.vertex1(p[0]+az[0]*s+ax[0]*s/3, p[1]+az[1]*s+ax[1]*s/3, p[2]+az[2]*s+ax[2]*s/3, col)\r\n\r\n\tdd.vertex0(p, col)\r\n\t//\tdd.vertex(p[0]+az[0]*s-ay[0]*s/2, p[1]+az[1]*s-ay[1]*s/2, p[2]+az[2]*s-ay[2]*s/2, col);\r\n\tdd.vertex1(p[0]+az[0]*s-ax[0]*s/3, p[1]+az[1]*s-ax[1]*s/3, p[2]+az[2]*s-ax[2]*s/3, col)\r\n\r\n}\r"
            },
            "bit": {
                "Name": "bit",
                "Code": "func bit(a, b uint32) uint32 {\r\n\treturn (a \u0026 (1 \u003c\u003c b)) \u003e\u003e b\r\n}\r"
            },
            "distancePtLine2d": {
                "Name": "distancePtLine2d",
                "Code": "func distancePtLine2d(pt, p, q []float32) float32 {\r\n\tvar pqx = q[0] - p[0]\r\n\tvar pqz = q[2] - p[2]\r\n\tvar dx = pt[0] - p[0]\r\n\tvar dz = pt[2] - p[2]\r\n\tvar d = pqx*pqx + pqz*pqz\r\n\tvar t = pqx*dx + pqz*dz\r\n\tif d != 0 {\r\n\t\tt /= d\r\n\t}\r\n\tdx = p[0] + t*pqx - pt[0]\r\n\tdz = p[2] + t*pqz - pt[2]\r\n\treturn dx*dx + dz*dz\r\n}\r"
            },
            "drawMeshTile": {
                "Name": "drawMeshTile",
                "Code": "func drawMeshTile(dd duDebugDraw, mesh *detour.DtNavMesh, query *detour.DtNavMeshQuery, tile *detour.DtMeshTile, flags DrawNavMeshFlags) {\r\n\tvar base = mesh.GetPolyRefBase(tile)\r\n\tvar tileNum = mesh.DecodePolyIdTile(base)\r\n\tvar tileColor = duIntToCol(tileNum, 128)\r\n\r\n\tdd.depthMask(false)\r\n\tdd.begin(DU_DRAW_TRIS, 1)\r\n\r\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i += 1 {\r\n\t\tvar p = \u0026tile.Polys[i]\r\n\t\tif p.GetType() == detour.DT_POLYTYPE_OFFMESH_CONNECTION {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar pd = \u0026tile.DetailMeshes[i]\r\n\t\tvar col uint32\r\n\t\tif query != nil \u0026\u0026 query.IsInClosedList(base|detour.DtPolyRef(i)) {\r\n\t\t\tcol = duRGBA(255, 196, 0, 64)\r\n\t\t} else {\r\n\t\t\tif flags\u0026DU_DRAWNAVMESH_COLOR_TILES \u003e 0 {\r\n\t\t\t\tcol = tileColor\r\n\t\t\t} else {\r\n\t\t\t\tcol = duTransCol(dd.areaToCol(uint32(p.GetArea())), 64)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor j := 0; j \u003c int(pd.TriCount); j += 1 {\r\n\t\t\tvar t = tile.DetailTris[(int(pd.TriBase)+j)*4:]\r\n\t\t\tfor k := 0; k \u003c 3; k += 1 {\r\n\t\t\t\tif t[k] \u003c p.VertCount {\r\n\t\t\t\t\tdd.vertex0(tile.Verts[p.Verts[t[k]]*3:], col)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdd.vertex0(tile.DetailVerts[(int(pd.VertBase)+int(t[k])-int(p.VertCount))*3:], col)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdd.end()\r\n\r\n\t// Draw inter poly boundaries\r\n\tdrawPolyBoundaries(dd, tile, duRGBA(0, 48, 64, 32), 1.5, true)\r\n\r\n\t// Draw outer poly boundaries\r\n\tdrawPolyBoundaries(dd, tile, duRGBA(0, 48, 64, 220), 2.5, false)\r\n\r\n\tif flags\u0026DU_DRAWNAVMESH_OFFMESHCONS \u003e 0 {\r\n\t\tdd.begin(DU_DRAW_LINES, 2.0)\r\n\t\tfor i := 0; i \u003c int(tile.Header.PolyCount); i += 1 {\r\n\t\t\tvar p = \u0026tile.Polys[i]\r\n\t\t\tif p.GetType() == detour.DT_POLYTYPE_OFFMESH_CONNECTION {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tvar col1, col2 uint32\r\n\t\t\tif query != nil \u0026\u0026 query.IsInClosedList(base|detour.DtPolyRef(i)) {\r\n\t\t\t\tcol1 = duRGBA(255, 196, 0, 220)\r\n\t\t\t} else {\r\n\t\t\t\tcol1 = duDarkenCol(duTransCol(dd.areaToCol(uint32(p.GetArea())), 220))\r\n\t\t\t}\r\n\r\n\t\t\tvar con = \u0026tile.OffMeshCons[i-int(tile.Header.OffMeshBase)]\r\n\t\t\tvar va = tile.Verts[p.Verts[0]*3:]\r\n\t\t\tvar vb = tile.Verts[p.Verts[1]*3:]\r\n\r\n\t\t\tvar startSet bool\r\n\t\t\tvar endSet bool\r\n\t\t\tfor k := p.FirstLink; k != detour.DT_NULL_LINK; k = tile.Links[k].Next {\r\n\t\t\t\tif tile.Links[k].Edge \u003c= 0 {\r\n\t\t\t\t\tstartSet = true\r\n\t\t\t\t}\r\n\t\t\t\tif tile.Links[k].Edge == 1 {\r\n\t\t\t\t\tendSet = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// End points and their on-mesh locations.\r\n\t\t\tdd.vertex1(va[0], va[1], va[2], col1)\r\n\t\t\tdd.vertex1(con.Pos[0], con.Pos[1], con.Pos[2], col1)\r\n\t\t\tcol2 = duRGBA(220, 32, 16, 196)\r\n\t\t\tif startSet {\r\n\t\t\t\tcol2 = col1\r\n\t\t\t}\r\n\t\t\tduAppendCircle(dd, con.Pos[0], con.Pos[1]+0.1, con.Pos[2], con.Rad, col2)\r\n\r\n\t\t\tdd.vertex1(vb[0], vb[1], vb[2], col1)\r\n\t\t\tdd.vertex1(con.Pos[3], con.Pos[4], con.Pos[5], col1)\r\n\t\t\tcol2 = duRGBA(220, 32, 16, 196)\r\n\t\t\tif endSet {\r\n\t\t\t\tcol2 = col1\r\n\t\t\t}\r\n\t\t\tduAppendCircle(dd, con.Pos[3], con.Pos[4]+0.1, con.Pos[5], con.Rad, col2)\r\n\r\n\t\t\t// End point vertices.\r\n\t\t\tdd.vertex1(con.Pos[0], con.Pos[1], con.Pos[2], duRGBA(0, 48, 64, 196))\r\n\t\t\tdd.vertex1(con.Pos[0], con.Pos[1]+0.2, con.Pos[2], duRGBA(0, 48, 64, 196))\r\n\r\n\t\t\tdd.vertex1(con.Pos[3], con.Pos[4], con.Pos[5], duRGBA(0, 48, 64, 196))\r\n\t\t\tdd.vertex1(con.Pos[3], con.Pos[4]+0.2, con.Pos[5], duRGBA(0, 48, 64, 196))\r\n\r\n\t\t\t// Connection arc.\r\n\t\t\tvar as1 = float32(0)\r\n\t\t\tif con.Flags\u00261 \u003e 0 {\r\n\t\t\t\tas1 = 0.6\r\n\t\t\t}\r\n\t\t\tduAppendArc(dd, con.Pos[0], con.Pos[1], con.Pos[2], con.Pos[3], con.Pos[4], con.Pos[5], 0.25, as1, 0.6, col1)\r\n\t\t}\r\n\t\tdd.end()\r\n\t}\r\n\r\n\tvar vcol = duRGBA(0, 0, 0, 196)\r\n\tdd.begin(DU_DRAW_POINTS, 3.0)\r\n\tfor i := 0; i \u003c int(tile.Header.VertCount); i += 1 {\r\n\t\tvar v = tile.Verts[i*3:]\r\n\t\tdd.vertex0(v, vcol)\r\n\t}\r\n\tdd.end()\r\n\r\n\tdd.depthMask(true)\r\n}\r"
            },
            "drawPolyBoundaries": {
                "Name": "drawPolyBoundaries",
                "Code": "func drawPolyBoundaries(dd duDebugDraw, tile *detour.DtMeshTile, col uint32, linew float32, inner bool) {\r\n\tconst thr = 0.01 * 0.01\r\n\tdd.begin(DU_DRAW_LINES, linew)\r\n\r\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i += 1 {\r\n\t\tvar p = \u0026tile.Polys[i]\r\n\t\tif p.GetType() == detour.DT_POLYTYPE_OFFMESH_CONNECTION {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tvar pd = \u0026tile.DetailMeshes[i]\r\n\r\n\t\tfor j, nj := 0, p.VertCount; j \u003c int(nj); j += 1 {\r\n\t\t\tvar c = col\r\n\t\t\tif inner {\r\n\t\t\t\tif p.Neis[j] \u003c= 0 {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tif p.Neis[j]\u0026detour.DT_EXT_LINK \u003e 0 {\r\n\t\t\t\t\tvar con bool\r\n\t\t\t\t\tfor k := uint32(p.FirstLink); k != detour.DT_NULL_LINK; k = tile.Links[k].Next {\r\n\t\t\t\t\t\tif tile.Links[k].Edge == uint8(j) {\r\n\t\t\t\t\t\t\tcon = true\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif con {\r\n\t\t\t\t\t\tc = duRGBA(255, 255, 255, 48)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tc = duRGBA(0, 0, 0, 48)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tc = duRGBA(0, 48, 64, 32)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif p.Neis[j] != 0 {\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar v0 = tile.Verts[p.Verts[j]*3:]\r\n\t\t\tvar v1 = tile.Verts[p.Verts[(j+1)%int(nj)]*3:]\r\n\r\n\t\t\tfor k := 0; k \u003c int(pd.TriCount); k += 1 {\r\n\t\t\t\tvar t = tile.DetailTris[(int(pd.TriBase)+k)*4:]\r\n\t\t\t\tvar tv [3][]float32\r\n\t\t\t\tfor m := 0; m \u003c 3; m += 1 {\r\n\t\t\t\t\tif t[m] \u003c p.VertCount {\r\n\t\t\t\t\t\ttv[m] = tile.Verts[p.Verts[t[m]]*3:]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttv[m] = tile.DetailVerts[(int(pd.VertBase)+int(t[m])-int(p.VertCount))*3:]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor m, n := 0, 2; m \u003c 3; m, n = m+1, m {\r\n\t\t\t\t\tif detour.DtGetDetailTriEdgeFlags(t[3], n)\u0026int(detour.DT_DETAIL_EDGE_BOUNDARY) == 0 {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif distancePtLine2d(tv[n], v0, v1) \u003c thr \u0026\u0026 distancePtLine2d(tv[m], v0, v1) \u003c thr {\r\n\t\t\t\t\t\tdd.vertex0(tv[n], c)\r\n\t\t\t\t\t\tdd.vertex0(tv[m], c)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tdd.end()\r\n}\r"
            },
            "duAppendArc": {
                "Name": "duAppendArc",
                "Code": "func duAppendArc(dd duDebugDraw, x0, y0, z0, x1, y1, z1, h, as0, as1 float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tconst NUM_ARC_PTS = 8\r\n\tconst PAD = 0.05\r\n\tconst ARC_PTS_SCALE = (1.0 - PAD*2) / NUM_ARC_PTS\r\n\tvar dx = x1 - x0\r\n\tvar dy = y1 - y0\r\n\tvar dz = z1 - z0\r\n\tvar len = float32(math.Sqrt(float64(dx*dx + dy*dy + dz*dz)))\r\n\tvar prev [3]float32\r\n\tevalArc(x0, y0, z0, dx, dy, dz, len*h, PAD, prev[:])\r\n\tfor i := 1; i \u003c= NUM_ARC_PTS; i += 1 {\r\n\t\tvar u = PAD + float32(i)*ARC_PTS_SCALE\r\n\t\tvar pt [3]float32\r\n\t\tevalArc(x0, y0, z0, dx, dy, dz, len*h, u, pt[:])\r\n\t\tdd.vertex1(prev[0], prev[1], prev[2], col)\r\n\t\tdd.vertex1(pt[0], pt[1], pt[2], col)\r\n\t\tprev[0] = pt[0]\r\n\t\tprev[1] = pt[1]\r\n\t\tprev[2] = pt[2]\r\n\t}\r\n\r\n\t// End arrows\r\n\tif as0 \u003e 0.001 {\r\n\t\tvar p, q [3]float32\r\n\t\tevalArc(x0, y0, z0, dx, dy, dz, len*h, PAD, p[:])\r\n\t\tevalArc(x0, y0, z0, dx, dy, dz, len*h, PAD+0.05, q[:])\r\n\t\tappendArrowHead(dd, p[:], q[:], as0, col)\r\n\t}\r\n\r\n\tif as1 \u003e 0.001 {\r\n\t\tvar p, q [3]float32\r\n\t\tevalArc(x0, y0, z0, dx, dy, dz, len*h, 1-PAD, p[:])\r\n\t\tevalArc(x0, y0, z0, dx, dy, dz, len*h, 1-(PAD+0.05), q[:])\r\n\t\tappendArrowHead(dd, p[:], q[:], as1, col)\r\n\t}\r\n}\r"
            },
            "duAppendArrow": {
                "Name": "duAppendArrow",
                "Code": "func duAppendArrow(dd duDebugDraw, x0, y0, z0, x1, y1, z1, as0, as1 float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.vertex1(x0, y0, z0, col)\r\n\tdd.vertex1(x1, y1, z1, col)\r\n\r\n\t// End arrows\r\n\tvar p = [3]float32{x0, y0, z0}\r\n\tvar q = [3]float32{x1, y1, z1}\r\n\tif as0 \u003e 0.001 {\r\n\t\tappendArrowHead(dd, p[:], q[:], as0, col)\r\n\t}\r\n\tif as1 \u003e 0.001 {\r\n\t\tappendArrowHead(dd, q[:], p[:], as1, col)\r\n\t}\r\n}\r"
            },
            "duAppendBox": {
                "Name": "duAppendBox",
                "Code": "func duAppendBox(dd duDebugDraw, minx, miny, minz,\r\n\tmaxx, maxy, maxz float32, fcol []uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tvar verts = [8 * 3]float32{\r\n\t\tminx, miny, minz,\r\n\t\tmaxx, miny, minz,\r\n\t\tmaxx, miny, maxz,\r\n\t\tminx, miny, maxz,\r\n\t\tminx, maxy, minz,\r\n\t\tmaxx, maxy, minz,\r\n\t\tmaxx, maxy, maxz,\r\n\t\tminx, maxy, maxz,\r\n\t}\r\n\tvar inds = [6 * 4]uint8{\r\n\t\t7, 6, 5, 4,\r\n\t\t0, 1, 2, 3,\r\n\t\t1, 5, 6, 2,\r\n\t\t3, 7, 4, 0,\r\n\t\t2, 6, 7, 3,\r\n\t\t0, 4, 5, 1,\r\n\t}\r\n\r\n\tvar in = 0\r\n\tfor i := 0; i \u003c 6; i += 1 {\r\n\t\tdd.vertex0(verts[inds[in]*3:], fcol[i])\r\n\t\tin++\r\n\t\tdd.vertex0(verts[inds[in]*3:], fcol[i])\r\n\t\tin++\r\n\t\tdd.vertex0(verts[inds[in]*3:], fcol[i])\r\n\t\tin++\r\n\t\tdd.vertex0(verts[inds[in]*3:], fcol[i])\r\n\t\tin++\r\n\t}\r\n}\r"
            },
            "duAppendBoxPoints": {
                "Name": "duAppendBoxPoints",
                "Code": "func duAppendBoxPoints(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\t// Top\r\n\tdd.vertex1(minx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, maxz, col)\r\n\tdd.vertex1(maxx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, minz, col)\r\n\r\n\t// bottom\r\n\tdd.vertex1(minx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, maxz, col)\r\n\tdd.vertex1(maxx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, minz, col)\r\n}\r"
            },
            "duAppendBoxWire": {
                "Name": "duAppendBoxWire",
                "Code": "func duAppendBoxWire(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\t// Top\r\n\tdd.vertex1(minx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, minz, col)\r\n\tdd.vertex1(maxx, miny, maxz, col)\r\n\tdd.vertex1(maxx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, maxz, col)\r\n\tdd.vertex1(minx, miny, minz, col)\r\n\r\n\t// bottom\r\n\tdd.vertex1(minx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, minz, col)\r\n\tdd.vertex1(maxx, maxy, maxz, col)\r\n\tdd.vertex1(maxx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, maxz, col)\r\n\tdd.vertex1(minx, maxy, minz, col)\r\n\r\n\t// Sides\r\n\tdd.vertex1(minx, miny, minz, col)\r\n\tdd.vertex1(minx, maxy, minz, col)\r\n\tdd.vertex1(maxx, miny, minz, col)\r\n\tdd.vertex1(maxx, maxy, minz, col)\r\n\tdd.vertex1(maxx, miny, maxz, col)\r\n\tdd.vertex1(maxx, maxy, maxz, col)\r\n\tdd.vertex1(minx, miny, maxz, col)\r\n\tdd.vertex1(minx, maxy, maxz, col)\r\n}\r"
            },
            "duAppendCircle": {
                "Name": "duAppendCircle",
                "Code": "func duAppendCircle(dd duDebugDraw, x, y, z, r float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tconst NUM_SEG = 40\r\n\tvar dir [40 * 2]float32\r\n\tvar init = false\r\n\tif !init {\r\n\t\tinit = true\r\n\t\tfor i := 0; i \u003c NUM_SEG; i += 1 {\r\n\t\t\tvar a = float32(i) / float32(NUM_SEG) * DU_PI * 2\r\n\t\t\tdir[i*2] = detour.DtMathCosf(a)\r\n\t\t\tdir[i*2+1] = detour.DtMathCosf(a)\r\n\t\t}\r\n\t}\r\n\r\n\tfor i, j := 0, NUM_SEG-1; i \u003c NUM_SEG; i = i + 1 {\r\n\t\tdd.vertex1(x+dir[j*2+0]*r, y, z+dir[j*2+1]*r, col)\r\n\t\tdd.vertex1(x+dir[i*2+0]*r, y, z+dir[i*2+1]*r, col)\r\n\t\tj = i\r\n\t}\r\n}\r"
            },
            "duAppendCross": {
                "Name": "duAppendCross",
                "Code": "func duAppendCross(dd duDebugDraw, x, y, z, s float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tdd.vertex1(x-s, y, z, col)\r\n\tdd.vertex1(x+s, y, z, col)\r\n\tdd.vertex1(x, y-s, z, col)\r\n\tdd.vertex1(x, y+s, z, col)\r\n\tdd.vertex1(x, y, z-s, col)\r\n\tdd.vertex1(x, y, z+s, col)\r\n}\r"
            },
            "duAppendCylinder": {
                "Name": "duAppendCylinder",
                "Code": "func duAppendCylinder(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tconst NUM_SEG = 16\r\n\tvar dir [NUM_SEG * 2]float32\r\n\tvar init = false\r\n\tif !init {\r\n\t\tinit = true\r\n\t\tfor i := 0; i \u003c NUM_SEG; i += 1 {\r\n\t\t\tvar a = float32(i) / float32(NUM_SEG) * DU_PI * 2\r\n\t\t\tdir[i*2] = detour.DtMathCosf(a)\r\n\t\t\tdir[i*2+1] = detour.DtMathSinf(a)\r\n\t\t}\r\n\t}\r\n\r\n\tvar col2 = duMultCol(col, 160)\r\n\r\n\tvar cx = (maxx + minx) / 2\r\n\tvar cz = (maxz + minz) / 2\r\n\tvar rx = (maxx - minx) / 2\r\n\tvar rz = (maxz - minz) / 2\r\n\r\n\tfor i := 2; i \u003c NUM_SEG; i += 1 {\r\n\t\tvar a = 0\r\n\t\tvar b = i - 1\r\n\t\tvar c = i\r\n\t\tdd.vertex1(cx+dir[a*2+0]*rx, miny, cz+dir[a*2+1]*rz, col2)\r\n\t\tdd.vertex1(cx+dir[b*2+0]*rx, miny, cz+dir[b*2+1]*rz, col2)\r\n\t\tdd.vertex1(cx+dir[c*2+0]*rx, miny, cz+dir[c*2+1]*rz, col2)\r\n\t}\r\n\tfor i := 2; i \u003c NUM_SEG; i += 1 {\r\n\t\tvar a = 0\r\n\t\tvar b = i\r\n\t\tvar c = i - 1\r\n\t\tdd.vertex1(cx+dir[a*2+0]*rx, maxy, cz+dir[a*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[b*2+0]*rx, maxy, cz+dir[b*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[c*2+0]*rx, maxy, cz+dir[c*2+1]*rz, col)\r\n\t}\r\n\tfor i, j := 0, NUM_SEG-1; i \u003c NUM_SEG; i = i + 1 {\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, miny, cz+dir[i*2+1]*rz, col2)\r\n\t\tdd.vertex1(cx+dir[j*2+0]*rx, miny, cz+dir[j*2+1]*rz, col2)\r\n\t\tdd.vertex1(cx+dir[j*2+0]*rx, maxy, cz+dir[j*2+1]*rz, col)\r\n\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, miny, cz+dir[i*2+1]*rz, col2)\r\n\t\tdd.vertex1(cx+dir[j*2+0]*rx, maxy, cz+dir[j*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, maxy, cz+dir[i*2+1]*rz, col)\r\n\r\n\t\tj = i\r\n\t}\r\n}\r"
            },
            "duAppendCylinderWire": {
                "Name": "duAppendCylinderWire",
                "Code": "func duAppendCylinderWire(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst NUM_SEG = 16\r\n\tvar dir [NUM_SEG * 2]float32\r\n\tvar init = false\r\n\tif !init {\r\n\t\tinit = true\r\n\t\tfor i := 0; i \u003c NUM_SEG; i += 1 {\r\n\t\t\tvar a = float32(i) / float32(NUM_SEG) * DU_PI * 2\r\n\t\t\tdir[i*2] = detour.DtMathCosf(a)\r\n\t\t\tdir[i*2+1] = detour.DtMathSinf(a)\r\n\t\t}\r\n\t}\r\n\r\n\tvar cx = (maxx + minx) / 2\r\n\tvar cz = (maxz + minz) / 2\r\n\tvar rx = (maxx - minx) / 2\r\n\tvar rz = (maxz - minz) / 2\r\n\r\n\tfor i, j := 0, NUM_SEG-1; i \u003c NUM_SEG; i += 1 {\r\n\t\tdd.vertex1(cx+dir[j*2+0]*rx, miny, cz+dir[j*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, miny, cz+dir[i*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[j*2+0]*rx, maxy, cz+dir[j*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, maxy, cz+dir[i*2+1]*rz, col)\r\n\t\tj = i\r\n\t}\r\n\tfor i := 0; i \u003c NUM_SEG; i += NUM_SEG / 4 {\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, miny, cz+dir[i*2+1]*rz, col)\r\n\t\tdd.vertex1(cx+dir[i*2+0]*rx, maxy, cz+dir[i*2+1]*rz, col)\r\n\t}\r\n}\r"
            },
            "duCalcBoxColors": {
                "Name": "duCalcBoxColors",
                "Code": "func duCalcBoxColors(colors []uint32, colTop, colSide uint32) {\r\n\tif len(colors) \u003c= 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\tcolors[0] = duMultCol(colTop, 250)\r\n\tcolors[1] = duMultCol(colSide, 140)\r\n\tcolors[2] = duMultCol(colSide, 165)\r\n\tcolors[3] = duMultCol(colSide, 217)\r\n\tcolors[4] = duMultCol(colSide, 165)\r\n\tcolors[5] = duMultCol(colSide, 217)\r\n}\r"
            },
            "duDarkenCol": {
                "Name": "duDarkenCol",
                "Code": "func duDarkenCol(col uint32) uint32 {\r\n\treturn ((col \u003e\u003e 1) \u0026 0x007f7f7f) | (col \u0026 0xff000000)\r\n}\r"
            },
            "duDebugDrawArc": {
                "Name": "duDebugDrawArc",
                "Code": "func duDebugDrawArc(dd duDebugDraw, x0, y0, z0, x1, y1, z1, h, as0, as1 float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendArc(dd, x0, y0, z0, x1, y1, z1, h, as0, as1, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawArrow": {
                "Name": "duDebugDrawArrow",
                "Code": "func duDebugDrawArrow(dd duDebugDraw, x0, y0, z0, x1, y1, z1, as0, as1 float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendArrow(dd, x0, y0, z0, x1, y1, z1, as0, as1, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawBox": {
                "Name": "duDebugDrawBox",
                "Code": "func duDebugDrawBox(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, fcol []uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, 1)\r\n\tduAppendBox(dd, minx, miny, minz, maxx, maxy, maxz, fcol)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawBoxWire": {
                "Name": "duDebugDrawBoxWire",
                "Code": "func duDebugDrawBoxWire(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendBoxWire(dd, minx, miny, minz, maxx, maxy, maxz, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawCircle": {
                "Name": "duDebugDrawCircle",
                "Code": "func duDebugDrawCircle(dd duDebugDraw, x, y, z, r float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendCircle(dd, x, y, z, r, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawCross": {
                "Name": "duDebugDrawCross",
                "Code": "func duDebugDrawCross(dd duDebugDraw, x, y, z, size float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendCross(dd, x, y, z, size, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawCylinder": {
                "Name": "duDebugDrawCylinder",
                "Code": "func duDebugDrawCylinder(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, 1)\r\n\tduAppendCylinder(dd, minx, miny, minz, maxx, maxy, maxz, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawCylinderWire": {
                "Name": "duDebugDrawCylinderWire",
                "Code": "func duDebugDrawCylinderWire(dd duDebugDraw, minx, miny, minz, maxx, maxy, maxz float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tduAppendCylinderWire(dd, minx, miny, minz, maxx, maxy, maxz, col)\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawGridXZ": {
                "Name": "duDebugDrawGridXZ",
                "Code": "func duDebugDrawGridXZ(dd duDebugDraw, ox, oy, oz, w, h, size float32, col uint32, lineWidth float32) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdd.begin(DU_DRAW_LINES, lineWidth)\r\n\tfor i := float32(0); i \u003c= h; i += 1 {\r\n\t\tdd.vertex1(ox, oy, oz+i*size, col)\r\n\t\tdd.vertex1(ox+w*size, oy, oz+i*size, col)\r\n\t}\r\n\tfor i := float32(0); i \u003c= w; i += 1 {\r\n\t\tdd.vertex1(ox+i*size, oy, oz, col)\r\n\t\tdd.vertex1(ox+i*size, oy, oz+h*size, col)\r\n\t}\r\n\r\n\tdd.end()\r\n}\r"
            },
            "duDebugDrawNavMesh": {
                "Name": "duDebugDrawNavMesh",
                "Code": "func duDebugDrawNavMesh(dd duDebugDraw, mesh *detour.DtNavMesh, flags DrawNavMeshFlags) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tfor i := 0; i \u003c int(mesh.GetMaxTiles()); i += 1 {\r\n\t\tvar tile = mesh.GetTile(i)\r\n\t\tif tile.Header == nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdrawMeshTile(dd, mesh, nil, tile, flags)\r\n\t}\r\n}\r"
            },
            "duDebugDrawNavMeshWithClosedList": {
                "Name": "duDebugDrawNavMeshWithClosedList",
                "Code": "func duDebugDrawNavMeshWithClosedList(dd duDebugDraw, mesh *detour.DtNavMesh, query *detour.DtNavMeshQuery, flags DrawNavMeshFlags) {\r\n\tif dd == nil {\r\n\t\treturn\r\n\t}\r\n\tvar q *detour.DtNavMeshQuery\r\n\tif flags\u0026DU_DRAWNAVMESH_CLOSEDLIST \u003e 0 {\r\n\t\tq = query\r\n\t}\r\n\r\n\tfor i := 0; i \u003c int(mesh.GetMaxTiles()); i += 1 {\r\n\t\tvar tile = mesh.GetTile(i)\r\n\t\tif tile.Header == nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdrawMeshTile(dd, mesh, q, tile, flags)\r\n\t}\r\n}\r"
            },
            "duIntToCol": {
                "Name": "duIntToCol",
                "Code": "func duIntToCol(i, a uint32) uint32 {\r\n\tvar r = bit(i, 1) + bit(i, 3)*2 + 1\r\n\tvar g = bit(i, 2) + bit(i, 4)*2 + 1\r\n\tvar b = bit(i, 0) + bit(i, 5)*2 + 1\r\n\treturn duRGBA(r*63, g*63, b*63, a)\r\n}\r"
            },
            "duIntToColFloat32": {
                "Name": "duIntToColFloat32",
                "Code": "func duIntToColFloat32(i uint32, col []float32) {\r\n\tvar r = bit(i, 0) + bit(i, 3)*2 + 1\r\n\tvar g = bit(i, 1) + bit(i, 4)*2 + 1\r\n\tvar b = bit(i, 2) + bit(i, 5)*2 + 1\r\n\tcol[0] = 1 - float32(r)*63.0/255.0\r\n\tcol[1] = 1 - float32(g)*63.0/255.0\r\n\tcol[2] = 1 - float32(b)*63.0/255.0\r\n}\r"
            },
            "duLerpCol": {
                "Name": "duLerpCol",
                "Code": "func duLerpCol(ca, cb, u uint32) uint32 {\r\n\tvar ra = ca \u0026 0xff\r\n\tvar ga = (ca \u003e\u003e 8) \u0026 0xff\r\n\tvar ba = (ca \u003e\u003e 16) \u0026 0xff\r\n\tvar aa = (ca \u003e\u003e 24) \u0026 0xff\r\n\tvar rb = cb \u0026 0xff\r\n\tvar gb = (cb \u003e\u003e 8) \u0026 0xff\r\n\tvar bb = (cb \u003e\u003e 16) \u0026 0xff\r\n\tvar ab = (cb \u003e\u003e 24) \u0026 0xff\r\n\r\n\tvar r = (ra*(255-u) + rb*u) / 255\r\n\tvar g = (ga*(255-u) + gb*u) / 255\r\n\tvar b = (ba*(255-u) + bb*u) / 255\r\n\tvar a = (aa*(255-u) + ab*u) / 255\r\n\treturn duRGBA(r, g, b, a)\r\n}\r"
            },
            "duMultCol": {
                "Name": "duMultCol",
                "Code": "func duMultCol(col, d uint32) uint32 {\r\n\tvar r = col \u0026 0xff\r\n\tvar g = (col \u003e\u003e 8) \u0026 0xff\r\n\tvar b = (col \u003e\u003e 16) \u0026 0xff\r\n\tvar a = (col \u003e\u003e 24) \u0026 0xff\r\n\treturn duRGBA((r*d)\u003e\u003e8, (g*d)\u003e\u003e8, (b*d)\u003e\u003e8, a)\r\n}\r"
            },
            "duRGBA": {
                "Name": "duRGBA",
                "Code": "func duRGBA(r, g, b, a uint32) uint32 {\r\n\treturn uint32(r) | uint32(g)\u003c\u003c8 | uint32(b)\u003c\u003c16 | uint32(a)\u003c\u003c24\r\n}\r"
            },
            "duRGBAf": {
                "Name": "duRGBAf",
                "Code": "func duRGBAf(fr, fg, fb, fa float32) uint32 {\r\n\tvar r = uint32(fr * 255)\r\n\tvar g = uint32(fg * 255)\r\n\tvar b = uint32(fb * 255)\r\n\tvar a = uint32(fa * 255)\r\n\treturn duRGBA(r, g, b, a)\r\n}\r"
            },
            "duTransCol": {
                "Name": "duTransCol",
                "Code": "func duTransCol(c, a uint32) uint32 {\r\n\treturn (a \u003c\u003c 24) | (c \u0026 0x00ffffff)\r\n}\r"
            },
            "evalArc": {
                "Name": "evalArc",
                "Code": "func evalArc(x0, y0, z0, dx, dy, dz, h, u float32, res []float32) {\r\n\tres[0] = x0 + dx*u\r\n\tres[1] = y0 + dy*u + h*(1-(u*2-1)*(u*2-1))\r\n\tres[2] = z0 + dz*u\r\n}\r"
            },
            "vcross": {
                "Name": "vcross",
                "Code": "func vcross(dest, v1, v2 []float32) {\r\n\tdest[0] = v1[1]*v2[2] - v1[2]*v2[1]\r\n\tdest[1] = v1[2]*v2[0] - v1[0]*v2[2]\r\n\tdest[2] = v1[0]*v2[1] - v1[1]*v2[0]\r\n}\r"
            },
            "vdistSqr": {
                "Name": "vdistSqr",
                "Code": "func vdistSqr(v1, v2 []float32) float32 {\r\n\tvar x = v1[0] - v2[0]\r\n\tvar y = v1[1] - v2[1]\r\n\tvar z = v1[2] - v2[2]\r\n\treturn x*x + y*y + z*z\r\n}\r"
            },
            "vnormalize": {
                "Name": "vnormalize",
                "Code": "func vnormalize(v []float32) {\r\n\tvar d = 1.0 / float32(math.Sqrt(float64((v[0]*v[0] + v[1]*v[1] + v[2]*v[2]))))\r\n\tv[0] *= d\r\n\tv[1] *= d\r\n\tv[2] *= d\r\n}\r"
            },
            "vsub": {
                "Name": "vsub",
                "Code": "func vsub(dest, v1, v2 []float32) {\r\n\tdest[0] = v1[0] - v2[0]\r\n\tdest[1] = v1[1] - v2[1]\r\n\tdest[2] = v1[2] - v2[2]\r\n}\r"
            }
        }
    },
    {
        "Name": "detour",
        "Structs": {
            "BVItem": {
                "Name": "BVItem",
                "Code": "type BVItem struct {\n\tbmin [3]uint16\n\tbmax [3]uint16\n\ti    int\n}\n",
                "Methods": {}
            },
            "DtAssertFailFunc": {
                "Name": "DtAssertFailFunc",
                "Code": "// / An assertion failure function.\n//\n//\t@param[in]\t\texpression  asserted expression.\n//\t@param[in]\t\tfile  Filename of the failed assertion.\n//\t@param[in]\t\tline  Line number of the failed assertion.\n//\n// /  @see dtAssertFailSetCustom\ntype DtAssertFailFunc func(expression bool)\n",
                "Methods": {}
            },
            "DtBVNode": {
                "Name": "DtBVNode",
                "Code": "// / Bounding volume node.\n// / @note This structure is rarely if ever used by the end user.\n// / @see dtMeshTile\ntype DtBVNode struct {\n\tBmin [3]uint16 ///\u003c Minimum bounds of the node's AABB. [(x, y, z)]\n\tBmax [3]uint16 ///\u003c Maximum bounds of the node's AABB. [(x, y, z)]\n\tI    int32     ///\u003c The node's index. (Negative for escape sequence.)\n}\n",
                "Methods": {}
            },
            "DtDetailTriEdgeFlags": {
                "Name": "DtDetailTriEdgeFlags",
                "Code": "type DtDetailTriEdgeFlags int\n",
                "Methods": {}
            },
            "DtFindPathOptions": {
                "Name": "DtFindPathOptions",
                "Code": "// / Options for dtNavMeshQuery::initSlicedFindPath and updateSlicedFindPath\ntype DtFindPathOptions int\n",
                "Methods": {}
            },
            "DtLink": {
                "Name": "DtLink",
                "Code": "// / Defines a link between polygons.\n// / @note This structure is rarely if ever used by the end user.\n// / @see dtMeshTile\ntype DtLink struct {\n\tRef  DtPolyRef ///\u003c Neighbour reference. (The neighbor that is linked to.)\n\tNext uint32    ///\u003c Index of the next link.\n\tEdge uint8     ///\u003c Index of the polygon edge that owns this link.\n\tSide uint8     ///\u003c If a boundary link, defines on which side the link is.\n\tBmin uint8     ///\u003c If a boundary link, defines the minimum sub-edge area.\n\tBmax uint8     ///\u003c If a boundary link, defines the maximum sub-edge area.\n}\n",
                "Methods": {}
            },
            "DtMeshHeader": {
                "Name": "DtMeshHeader",
                "Code": "// / Provides high level information related to a dtMeshTile object.\n// / @ingroup detour\ntype DtMeshHeader struct {\n\tMagic           int32  ///\u003c Tile magic number. (Used to identify the data format.)\n\tVersion         int32  ///\u003c Tile data format version number.\n\tX               int32  ///\u003c The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n\tY               int32  ///\u003c The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n\tLayer           int32  ///\u003c The layer of the tile within the dtNavMesh tile grid. (x, y, layer)\n\tUserId          uint32 ///\u003c The user defined id of the tile.\n\tPolyCount       int32  ///\u003c The number of polygons in the tile.\n\tVertCount       int32  ///\u003c The number of vertices in the tile.\n\tMaxLinkCount    int32  ///\u003c The number of allocated links.\n\tDetailMeshCount int32  ///\u003c The number of sub-meshes in the detail mesh.\n\n\t/// The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)\n\tDetailVertCount int32\n\n\tDetailTriCount  int32      ///\u003c The number of triangles in the detail mesh.\n\tBvNodeCount     int32      ///\u003c The number of bounding volume nodes. (Zero if bounding volumes are disabled.)\n\tOffMeshConCount int32      ///\u003c The number of off-mesh connections.\n\tOffMeshBase     int32      ///\u003c The index of the first polygon which is an off-mesh connection.\n\tWalkableHeight  float32    ///\u003c The height of the agents using the tile.\n\tWalkableRadius  float32    ///\u003c The radius of the agents using the tile.\n\tWalkableClimb   float32    ///\u003c The maximum climb height of the agents using the tile.\n\tBmin            [3]float32 ///\u003c The minimum bounds of the tile's AABB. [(x, y, z)]\n\tBmax            [3]float32 ///\u003c The maximum bounds of the tile's AABB. [(x, y, z)]\n\n\t/// The bounding volume quantization factor.\n\tBvQuantFactor float32\n}\n",
                "Methods": {}
            },
            "DtMeshTile": {
                "Name": "DtMeshTile",
                "Code": "// / Defines a navigation mesh tile.\n// / @ingroup detour\ntype DtMeshTile struct {\n\tSalt uint32 ///\u003c Counter describing modifications to the tile.\n\n\tLinksFreeList uint32         ///\u003c Index to the next free link.\n\tHeader        *DtMeshHeader  ///\u003c The tile header.\n\tPolys         []DtPoly       ///\u003c The tile polygons. [Size: dtMeshHeader::polyCount]\n\tVerts         []float32      ///\u003c The tile vertices. [Size: dtMeshHeader::vertCount]\n\tLinks         []DtLink       ///\u003c The tile links. [Size: dtMeshHeader::maxLinkCount]\n\tDetailMeshes  []DtPolyDetail ///\u003c The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]\n\n\t/// The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]\n\tDetailVerts []float32\n\n\t/// The detail mesh's triangles. [(vertA, vertB, vertC) * dtMeshHeader::detailTriCount]\n\tDetailTris []uint8\n\n\t/// The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]\n\t/// (Will be null if bounding volumes are disabled.)\n\tBvTree []DtBVNode\n\n\tOffMeshCons []DtOffMeshConnection ///\u003c The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]\n\n\tData     []byte      ///\u003c The tile data. (Not directly accessed under normal situations.)\n\tDataSize int32       ///\u003c Size of the tile data.\n\tFlags    DtTileFlags ///\u003c Tile flags. (See: #dtTileFlags)\n\tNext     *DtMeshTile ///\u003c The next free tile, or the next tile in the spatial grid.\n}\n",
                "Methods": {}
            },
            "DtNavMesh": {
                "Name": "DtNavMesh",
                "Code": "// / A navigation mesh based on tiles of convex polygons.\n// / @ingroup detour\ntype DtNavMesh struct {\n\tm_params                  DtNavMeshParams ///\u003c Current initialization params. TODO: do not store this info twice.\n\tm_orig                    [3]float32      ///\u003c Origin of the tile (0,0)\n\tm_tileWidth, m_tileHeight float32         ///\u003c Dimensions of each tile.\n\tm_maxTiles                int32           ///\u003c Max number of tiles.\n\tm_tileLutSize             int32           ///\u003c Tile hash lookup size (must be pot).\n\tm_tileLutMask             int32           ///\u003c Tile hash lookup mask.\n\n\tm_posLookup []*DtMeshTile ///\u003c Tile hash lookup.\n\tm_nextFree  *DtMeshTile   ///\u003c Freelist of tiles.\n\tm_tiles     []DtMeshTile  ///\u003c List of tiles.\n\n\tm_saltBits uint32 ///\u003c Number of salt bits in the tile ID.\n\tm_tileBits uint32 ///\u003c Number of tile bits in the tile ID.\n\tm_polyBits uint32 ///\u003c Number of poly bits in the tile ID.\n}\n",
                "Methods": {
                    "AddTile": {
                        "Name": "AddTile",
                        "Code": "func (this *DtNavMesh) AddTile(data []byte, dataSize int, flags DtTileFlags,\n\tlastRef DtTileRef, result *DtTileRef) DtStatus {\n\n\t// Make sure the data is in right format.\n\tif dataSize \u003c DtAlign4(int(unsafe.Sizeof(DtMeshHeader{}))) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\theader := (*DtMeshHeader)(unsafe.Pointer(\u0026(data[0])))\n\tif header.Magic != DT_NAVMESH_MAGIC {\n\t\treturn DT_FAILURE | DT_WRONG_MAGIC\n\t}\n\tif header.Version != DT_NAVMESH_VERSION {\n\t\treturn DT_FAILURE | DT_WRONG_VERSION\n\t}\n\n\t// Make sure the location is free.\n\tif this.GetTileAt(header.X, header.Y, header.Layer) != nil {\n\t\treturn DT_FAILURE | DT_ALREADY_OCCUPIED\n\t}\n\n\t// Allocate a tile.\n\tvar tile *DtMeshTile = nil\n\tif lastRef == 0 {\n\t\tif this.m_nextFree != nil {\n\t\t\ttile = this.m_nextFree\n\t\t\tthis.m_nextFree = tile.Next\n\t\t\ttile.Next = nil\n\t\t}\n\t} else {\n\t\t// Try to relocate the tile to specific index with same salt.\n\t\ttileIndex := this.DecodePolyIdTile(DtPolyRef(lastRef))\n\t\tif tileIndex \u003e= uint32(this.m_maxTiles) {\n\t\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t\t}\n\t\t// Try to find the specific tile id from the free list.\n\t\ttarget := \u0026this.m_tiles[tileIndex]\n\t\tvar prev *DtMeshTile = nil\n\t\ttile = this.m_nextFree\n\t\tfor tile != nil \u0026\u0026 tile != target {\n\t\t\tprev = tile\n\t\t\ttile = tile.Next\n\t\t}\n\t\t// Could not find the correct location.\n\t\tif tile != target {\n\t\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t\t}\n\t\t// Remove from freelist\n\t\tif prev == nil {\n\t\t\tthis.m_nextFree = tile.Next\n\t\t} else {\n\t\t\tprev.Next = tile.Next\n\t\t}\n\t\t// Restore salt.\n\t\ttile.Salt = this.DecodePolyIdSalt(DtPolyRef(lastRef))\n\t}\n\n\t// Make sure we could allocate a tile.\n\tif tile == nil {\n\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t}\n\t// Insert tile into the position lut.\n\th := computeTileHash(header.X, header.Y, int32(this.m_tileLutMask))\n\ttile.Next = this.m_posLookup[h]\n\tthis.m_posLookup[h] = tile\n\n\t// Patch header pointers.\n\theaderSize := DtAlign4(int(unsafe.Sizeof(DtMeshHeader{})))\n\tvertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(header.VertCount))\n\tpolysSize := DtAlign4(int(unsafe.Sizeof(DtPoly{})) * int(header.PolyCount))\n\tlinksSize := DtAlign4(int(unsafe.Sizeof(DtLink{})) * int(header.MaxLinkCount))\n\tdetailMeshesSize := DtAlign4(int(unsafe.Sizeof(DtPolyDetail{})) * int(header.DetailMeshCount))\n\tdetailVertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(header.DetailVertCount))\n\tdetailTrisSize := DtAlign4(int(unsafe.Sizeof(uint8(1))) * 4 * int(header.DetailTriCount))\n\tbvtreeSize := DtAlign4(int(unsafe.Sizeof(DtBVNode{})) * int(header.BvNodeCount))\n\toffMeshLinksSize := DtAlign4(int(unsafe.Sizeof(DtOffMeshConnection{})) * int(header.OffMeshConCount))\n\n\td := 0 + headerSize\n\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.Verts))))\n\tsliceHeader.Cap = 3 * int(header.VertCount)\n\tsliceHeader.Len = 3 * int(header.VertCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += vertsSize\n\n\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.Polys))))\n\tsliceHeader.Cap = int(header.PolyCount)\n\tsliceHeader.Len = int(header.PolyCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += polysSize\n\n\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.Links))))\n\tsliceHeader.Cap = int(header.MaxLinkCount)\n\tsliceHeader.Len = int(header.MaxLinkCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += linksSize\n\n\tif header.DetailMeshCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.DetailMeshes))))\n\t\tsliceHeader.Cap = int(header.DetailMeshCount)\n\t\tsliceHeader.Len = int(header.DetailMeshCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailMeshesSize\n\t}\n\n\tif header.DetailVertCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.DetailVerts))))\n\t\tsliceHeader.Cap = 3 * int(header.DetailVertCount)\n\t\tsliceHeader.Len = 3 * int(header.DetailVertCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailVertsSize\n\t}\n\n\tif header.DetailTriCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.DetailTris))))\n\t\tsliceHeader.Cap = 4 * int(header.DetailTriCount)\n\t\tsliceHeader.Len = 4 * int(header.DetailTriCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailTrisSize\n\t}\n\n\tif header.BvNodeCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.BvTree))))\n\t\tsliceHeader.Cap = int(header.BvNodeCount)\n\t\tsliceHeader.Len = int(header.BvNodeCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += bvtreeSize\n\t}\n\n\tif header.OffMeshConCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026(tile.OffMeshCons))))\n\t\tsliceHeader.Cap = int(header.OffMeshConCount)\n\t\tsliceHeader.Len = int(header.OffMeshConCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += offMeshLinksSize\n\t}\n\n\t// If there are no items in the bvtree, reset the tree pointer.\n\tif header.BvNodeCount == 0 {\n\t\ttile.BvTree = nil\n\t}\n\n\t// Build links freelist\n\ttile.LinksFreeList = 0\n\ttile.Links[header.MaxLinkCount-1].Next = DT_NULL_LINK\n\tfor i := 0; i \u003c int(header.MaxLinkCount-1); i++ {\n\t\ttile.Links[i].Next = uint32(i + 1)\n\t}\n\n\t// Init tile.\n\ttile.Header = header\n\ttile.Data = data\n\ttile.DataSize = int32(dataSize)\n\ttile.Flags = flags\n\n\tthis.connectIntLinks(tile)\n\n\t// Base off-mesh connections to their starting polygons and connect connections inside the tile.\n\tthis.baseOffMeshLinks(tile)\n\tthis.connectExtOffMeshLinks(tile, tile, -1)\n\n\t// Create connections with neighbour tiles.\n\tconst MAX_NEIS int = 32\n\tvar neis [MAX_NEIS]*DtMeshTile\n\tvar nneis int\n\n\t// Connect with layers in current tile.\n\tnneis = this.GetTilesAt(header.X, header.Y, neis[:], MAX_NEIS)\n\tfor j := 0; j \u003c nneis; j++ {\n\t\tif neis[j] == tile {\n\t\t\tcontinue\n\t\t}\n\t\tthis.connectExtLinks(tile, neis[j], -1)\n\t\tthis.connectExtLinks(neis[j], tile, -1)\n\t\tthis.connectExtOffMeshLinks(tile, neis[j], -1)\n\t\tthis.connectExtOffMeshLinks(neis[j], tile, -1)\n\t}\n\n\t// Connect with neighbour tiles.\n\tfor i := 0; i \u003c 8; i++ {\n\t\tnneis = this.GetNeighbourTilesAt(header.X, header.Y, i, neis[:], MAX_NEIS)\n\t\tfor j := 0; j \u003c nneis; j++ {\n\t\t\tthis.connectExtLinks(tile, neis[j], i)\n\t\t\tthis.connectExtLinks(neis[j], tile, DtOppositeTile(i))\n\t\t\tthis.connectExtOffMeshLinks(tile, neis[j], i)\n\t\t\tthis.connectExtOffMeshLinks(neis[j], tile, DtOppositeTile(i))\n\t\t}\n\t}\n\n\tif result != nil {\n\t\t*result = this.GetTileRef(tile)\n\t}\n\treturn DT_SUCCESS\n}\n"
                    },
                    "CalcTileLoc": {
                        "Name": "CalcTileLoc",
                        "Code": "func (this *DtNavMesh) CalcTileLoc(pos []float32, tx, ty *int32) {\n\t*tx = (int32)(math.Floor(float64(pos[0]-this.m_orig[0]) / float64(this.m_tileWidth)))\n\t*ty = (int32)(math.Floor(float64(pos[2]-this.m_orig[2]) / float64(this.m_tileHeight)))\n}\n"
                    },
                    "DecodePolyId": {
                        "Name": "DecodePolyId",
                        "Code": "func (this *DtNavMesh) DecodePolyId(ref DtPolyRef, salt, it, ip *uint32) {\n\tsaltMask := (uint32(1) \u003c\u003c this.m_saltBits) - 1\n\ttileMask := (uint32(1) \u003c\u003c this.m_tileBits) - 1\n\tpolyMask := (uint32(1) \u003c\u003c this.m_polyBits) - 1\n\t*salt = ((uint32(ref) \u003e\u003e (this.m_polyBits + this.m_tileBits)) \u0026 saltMask)\n\t*it = ((uint32(ref) \u003e\u003e this.m_polyBits) \u0026 tileMask)\n\t*ip = (uint32(ref) \u0026 polyMask)\n}\n"
                    },
                    "DecodePolyIdPoly": {
                        "Name": "DecodePolyIdPoly",
                        "Code": "func (this *DtNavMesh) DecodePolyIdPoly(ref DtPolyRef) uint32 {\n\tpolyMask := (uint32(1) \u003c\u003c this.m_polyBits) - 1\n\treturn (uint32(ref) \u0026 polyMask)\n}\n"
                    },
                    "DecodePolyIdSalt": {
                        "Name": "DecodePolyIdSalt",
                        "Code": "func (this *DtNavMesh) DecodePolyIdSalt(ref DtPolyRef) uint32 {\n\tsaltMask := (uint32(1) \u003c\u003c this.m_saltBits) - 1\n\treturn ((uint32(ref) \u003e\u003e (this.m_polyBits + this.m_tileBits)) \u0026 saltMask)\n}\n"
                    },
                    "DecodePolyIdTile": {
                        "Name": "DecodePolyIdTile",
                        "Code": "func (this *DtNavMesh) DecodePolyIdTile(ref DtPolyRef) uint32 {\n\ttileMask := (uint32(1) \u003c\u003c this.m_tileBits) - 1\n\treturn ((uint32(ref) \u003e\u003e this.m_polyBits) \u0026 tileMask)\n}\n"
                    },
                    "EncodePolyId": {
                        "Name": "EncodePolyId",
                        "Code": "func (this *DtNavMesh) EncodePolyId(salt, it, ip uint32) DtPolyRef {\n\treturn DtPolyRef((salt \u003c\u003c (this.m_polyBits + this.m_tileBits)) | (it \u003c\u003c this.m_polyBits) | ip)\n}\n"
                    },
                    "GetDebugMesh": {
                        "Name": "GetDebugMesh",
                        "Code": "func (this *DtNavMesh) GetDebugMesh() ([]float32, []int) {\n\tvar positions []float32\n\tvar indices []int\n\tvar tri int\n\tvar maxTiles = this.GetMaxTiles()\n\n\tfor tileIndex := 0; tileIndex \u003c int(maxTiles); tileIndex += 1 {\n\t\tvar tile = this.GetTile(tileIndex)\n\t\tvar tileHeader = tile.Header\n\n\t\tif tileHeader == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar tilePolyCount = tileHeader.PolyCount\n\t\tfor tilePolyIndex := 0; tilePolyIndex \u003c int(tilePolyCount); tilePolyIndex += 1 {\n\t\t\tvar poly = \u0026tile.Polys[tilePolyIndex]\n\n\t\t\t// ignore offmesh connection\n\t\t\tif poly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar polyVertCount = poly.VertCount\n\t\t\tvar polyDetail = \u0026tile.DetailMeshes[tilePolyIndex]\n\t\t\tvar polyDetailTriBase = polyDetail.TriBase\n\t\t\tvar polyDetailTriCount = polyDetail.TriCount\n\n\t\t\tfor polyDetailTriIndex := uint32(0); polyDetailTriIndex \u003c uint32(polyDetailTriCount); polyDetailTriIndex += 1 {\n\t\t\t\tvar detailTrisBaseIndex = int(polyDetailTriBase+polyDetailTriIndex) * 4\n\n\t\t\t\tfor trianglePoint := int(0); trianglePoint \u003c 3; trianglePoint += 1 {\n\n\t\t\t\t\tif tile.DetailTris[detailTrisBaseIndex+trianglePoint] \u003c polyVertCount {\n\t\t\t\t\t\tvar tileVertsBaseIndex = poly.Verts[tile.DetailTris[detailTrisBaseIndex+trianglePoint]] * 3\n\t\t\t\t\t\tpositions = append(positions, tile.Verts[tileVertsBaseIndex:tileVertsBaseIndex+3]...)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar tileVertsBaseIndex = (polyDetail.VertBase +\n\t\t\t\t\t\t\tuint32(tile.DetailTris[detailTrisBaseIndex+trianglePoint]) -\n\t\t\t\t\t\t\tuint32(poly.VertCount)) * 3\n\t\t\t\t\t\tpositions = append(positions, tile.DetailVerts[tileVertsBaseIndex:tileVertsBaseIndex+3]...)\n\t\t\t\t\t}\n\n\t\t\t\t\tindices = append(indices, tri)\n\t\t\t\t\ttri += 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn positions, indices\n}\n"
                    },
                    "GetMaxTiles": {
                        "Name": "GetMaxTiles",
                        "Code": "func (this *DtNavMesh) GetMaxTiles() int32 {\n\treturn this.m_maxTiles\n}\n"
                    },
                    "GetNeighbourTilesAt": {
                        "Name": "GetNeighbourTilesAt",
                        "Code": "func (this *DtNavMesh) GetNeighbourTilesAt(x, y int32, side int, tiles []*DtMeshTile, maxTiles int) int {\n\tnx := x\n\tny := y\n\tswitch side {\n\tcase 0:\n\t\tnx++\n\tcase 1:\n\t\tnx++\n\t\tny++\n\tcase 2:\n\t\tny++\n\tcase 3:\n\t\tnx--\n\t\tny++\n\tcase 4:\n\t\tnx--\n\tcase 5:\n\t\tnx--\n\t\tny--\n\tcase 6:\n\t\tny--\n\tcase 7:\n\t\tnx++\n\t\tny--\n\t}\n\treturn this.GetTilesAt(nx, ny, tiles, maxTiles)\n}\n"
                    },
                    "GetOffMeshConnectionByRef": {
                        "Name": "GetOffMeshConnectionByRef",
                        "Code": "func (this *DtNavMesh) GetOffMeshConnectionByRef(ref DtPolyRef) *DtOffMeshConnection {\n\tvar salt, it, ip uint32\n\n\tif ref == 0 {\n\t\treturn nil\n\t}\n\n\t// Get current polygon\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn nil\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn nil\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn nil\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\t// Make sure that the current poly is indeed off-mesh link.\n\tif poly.GetType() != DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\treturn nil\n\t}\n\n\tidx := ip - uint32(tile.Header.OffMeshBase)\n\tDtAssert(idx \u003c uint32(tile.Header.OffMeshConCount))\n\treturn \u0026tile.OffMeshCons[idx]\n}\n"
                    },
                    "GetOffMeshConnectionPolyEndPoints": {
                        "Name": "GetOffMeshConnectionPolyEndPoints",
                        "Code": "func (this *DtNavMesh) GetOffMeshConnectionPolyEndPoints(prevRef, polyRef DtPolyRef, startPos, endPos []float32) DtStatus {\n\tvar salt, it, ip uint32\n\n\tif polyRef == 0 {\n\t\treturn DT_FAILURE\n\t}\n\t// Get current polygon\n\tthis.DecodePolyId(polyRef, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\t// Make sure that the current poly is indeed off-mesh link.\n\tif poly.GetType() != DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\treturn DT_FAILURE\n\t}\n\t// Figure out which way to hand out the vertices.\n\tidx0 := 0\n\tidx1 := 1\n\n\t// Find link that points to first vertex.\n\tfor i := poly.FirstLink; i != DT_NULL_LINK; i = tile.Links[i].Next {\n\t\tif tile.Links[i].Edge == 0 {\n\t\t\tif tile.Links[i].Ref != prevRef {\n\t\t\t\tidx0 = 1\n\t\t\t\tidx1 = 0\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tDtVcopy(startPos, tile.Verts[poly.Verts[idx0]*3:])\n\tDtVcopy(endPos, tile.Verts[poly.Verts[idx1]*3:])\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "GetParams": {
                        "Name": "GetParams",
                        "Code": "func (this *DtNavMesh) GetParams() *DtNavMeshParams {\n\treturn \u0026this.m_params\n}\n"
                    },
                    "GetPolyArea": {
                        "Name": "GetPolyArea",
                        "Code": "func (this *DtNavMesh) GetPolyArea(ref DtPolyRef, resultArea *uint8) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\t*resultArea = poly.GetArea()\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "GetPolyFlags": {
                        "Name": "GetPolyFlags",
                        "Code": "func (this *DtNavMesh) GetPolyFlags(ref DtPolyRef, resultFlags *uint16) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\t*resultFlags = poly.Flags\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "GetPolyRefBase": {
                        "Name": "GetPolyRefBase",
                        "Code": "func (this *DtNavMesh) GetPolyRefBase(tile *DtMeshTile) DtPolyRef {\n\tif tile == nil {\n\t\treturn 0\n\t}\n\ttileBase := uintptr(unsafe.Pointer(\u0026(this.m_tiles[0])))\n\tcurrent := uintptr(unsafe.Pointer(tile))\n\tit := (uint32)(current-tileBase) / sizeofMeshTile\n\treturn this.EncodePolyId(tile.Salt, it, 0)\n}\n"
                    },
                    "GetTile": {
                        "Name": "GetTile",
                        "Code": "func (this *DtNavMesh) GetTile(i int) *DtMeshTile {\n\treturn \u0026this.m_tiles[i]\n}\n"
                    },
                    "GetTileAndPolyByRef": {
                        "Name": "GetTileAndPolyByRef",
                        "Code": "func (this *DtNavMesh) GetTileAndPolyByRef(ref DtPolyRef, tile **DtMeshTile, poly **DtPoly) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif ip \u003e= (uint32)(this.m_tiles[it].Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t*tile = \u0026(this.m_tiles[it])\n\t*poly = \u0026(this.m_tiles[it].Polys[ip])\n\treturn DT_SUCCESS\n}\n"
                    },
                    "GetTileAndPolyByRefUnsafe": {
                        "Name": "GetTileAndPolyByRefUnsafe",
                        "Code": "func (this *DtNavMesh) GetTileAndPolyByRefUnsafe(ref DtPolyRef, tile **DtMeshTile, poly **DtPoly) {\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\t*tile = \u0026(this.m_tiles[it])\n\t*poly = \u0026(this.m_tiles[it].Polys[ip])\n}\n"
                    },
                    "GetTileAt": {
                        "Name": "GetTileAt",
                        "Code": "func (this *DtNavMesh) GetTileAt(x, y, layer int32) *DtMeshTile {\n\t// Find tile based on hash.\n\th := computeTileHash(x, y, int32(this.m_tileLutMask))\n\ttile := this.m_posLookup[h]\n\tfor tile != nil {\n\t\tif tile.Header != nil \u0026\u0026\n\t\t\ttile.Header.X == int32(x) \u0026\u0026\n\t\t\ttile.Header.Y == int32(y) \u0026\u0026\n\t\t\ttile.Header.Layer == int32(layer) {\n\t\t\treturn tile\n\t\t}\n\t\ttile = tile.Next\n\t}\n\treturn nil\n}\n"
                    },
                    "GetTileByRef": {
                        "Name": "GetTileByRef",
                        "Code": "func (this *DtNavMesh) GetTileByRef(ref DtTileRef) *DtMeshTile {\n\tif ref == 0 {\n\t\treturn nil\n\t}\n\ttileIndex := this.DecodePolyIdTile((DtPolyRef)(ref))\n\ttileSalt := this.DecodePolyIdSalt((DtPolyRef)(ref))\n\tif (int32)(tileIndex) \u003e= this.m_maxTiles {\n\t\treturn nil\n\t}\n\ttile := \u0026this.m_tiles[tileIndex]\n\tif tile.Salt != tileSalt {\n\t\treturn nil\n\t}\n\treturn tile\n}\n"
                    },
                    "GetTileRef": {
                        "Name": "GetTileRef",
                        "Code": "func (this *DtNavMesh) GetTileRef(tile *DtMeshTile) DtTileRef {\n\tif tile == nil {\n\t\treturn 0\n\t}\n\ttileBase := uintptr(unsafe.Pointer(\u0026(this.m_tiles[0])))\n\tcurrent := uintptr(unsafe.Pointer(tile))\n\tit := (uint32)(current-tileBase) / sizeofMeshTile\n\treturn (DtTileRef)(this.EncodePolyId(tile.Salt, it, 0))\n}\n"
                    },
                    "GetTileRefAt": {
                        "Name": "GetTileRefAt",
                        "Code": "func (this *DtNavMesh) GetTileRefAt(x, y, layer int32) DtTileRef {\n\t// Find tile based on hash.\n\th := computeTileHash(x, y, this.m_tileLutMask)\n\ttile := this.m_posLookup[h]\n\tfor tile != nil {\n\t\tif tile.Header != nil \u0026\u0026\n\t\t\ttile.Header.X == x \u0026\u0026\n\t\t\ttile.Header.Y == y \u0026\u0026\n\t\t\ttile.Header.Layer == layer {\n\t\t\treturn this.GetTileRef(tile)\n\t\t}\n\t\ttile = tile.Next\n\t}\n\treturn 0\n}\n"
                    },
                    "GetTileStateSize": {
                        "Name": "GetTileStateSize",
                        "Code": "func (this *DtNavMesh) GetTileStateSize(tile *DtMeshTile) int {\n\tif tile == nil {\n\t\treturn 0\n\t}\n\theaderSize := DtAlign4(int(unsafe.Sizeof(dtTileState{})))\n\tpolyStateSize := DtAlign4(int(unsafe.Sizeof(dtPolyState{})) * int(tile.Header.PolyCount))\n\treturn headerSize + polyStateSize\n}\n"
                    },
                    "GetTilesAt": {
                        "Name": "GetTilesAt",
                        "Code": "func (this *DtNavMesh) GetTilesAt(x, y int32, tiles []*DtMeshTile, maxTiles int) int {\n\tn := 0\n\n\t// Find tile based on hash.\n\th := computeTileHash(x, y, this.m_tileLutMask)\n\ttile := this.m_posLookup[h]\n\tfor tile != nil {\n\t\tif tile.Header != nil \u0026\u0026\n\t\t\ttile.Header.X == x \u0026\u0026\n\t\t\ttile.Header.Y == y {\n\t\t\tif n \u003c maxTiles {\n\t\t\t\ttiles[n] = tile\n\t\t\t\tn++\n\t\t\t}\n\t\t}\n\t\ttile = tile.Next\n\t}\n\n\treturn n\n}\n"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtNavMesh) Init(params *DtNavMeshParams) DtStatus {\n\tthis.m_params = *params\n\tDtVcopy(this.m_orig[:], params.Orig[:])\n\tthis.m_tileWidth = params.TileWidth\n\tthis.m_tileHeight = params.TileHeight\n\n\t// Init tiles\n\tthis.m_maxTiles = int32(params.MaxTiles)\n\tthis.m_tileLutSize = int32(DtNextPow2(params.MaxTiles / 4))\n\tif this.m_tileLutSize == 0 {\n\t\tthis.m_tileLutSize = 1\n\t}\n\tthis.m_tileLutMask = this.m_tileLutSize - 1\n\n\tthis.m_tiles = make([]DtMeshTile, this.m_maxTiles)\n\tif this.m_tiles == nil {\n\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t}\n\tthis.m_posLookup = make([]*DtMeshTile, this.m_tileLutSize)\n\tif this.m_posLookup == nil {\n\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t}\n\n\tthis.m_nextFree = nil\n\tfor i := int(this.m_maxTiles - 1); i \u003e= 0; i-- {\n\t\tthis.m_tiles[i].Salt = 1\n\t\tthis.m_tiles[i].Next = this.m_nextFree\n\t\tthis.m_nextFree = \u0026this.m_tiles[i]\n\t}\n\n\t// Init ID generator values.\n\tthis.m_tileBits = DtIlog2(DtNextPow2(params.MaxTiles))\n\tthis.m_polyBits = DtIlog2(DtNextPow2(params.MaxPolys))\n\t// Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow.\n\tthis.m_saltBits = DtMinUInt32(31, 32-this.m_tileBits-this.m_polyBits)\n\n\tif this.m_saltBits \u003c 10 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\treturn DT_SUCCESS\n}\n"
                    },
                    "Init2": {
                        "Name": "Init2",
                        "Code": "func (this *DtNavMesh) Init2(data []byte, dataSize int, flags DtTileFlags) DtStatus {\n\t// Make sure the data is in right format.\n\tif dataSize \u003c DtAlign4(int(unsafe.Sizeof(DtMeshHeader{}))) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\theader := (*DtMeshHeader)(unsafe.Pointer(\u0026(data[0])))\n\tif header.Magic != DT_NAVMESH_MAGIC {\n\t\treturn DT_FAILURE | DT_WRONG_MAGIC\n\t}\n\tif header.Version != DT_NAVMESH_VERSION {\n\t\treturn DT_FAILURE | DT_WRONG_VERSION\n\t}\n\tvar params DtNavMeshParams\n\tDtVcopy(params.Orig[:], header.Bmin[:])\n\tparams.TileWidth = header.Bmax[0] - header.Bmin[0]\n\tparams.TileHeight = header.Bmax[2] - header.Bmin[2]\n\tparams.MaxTiles = 1\n\tparams.MaxPolys = uint32(header.PolyCount)\n\n\tstatus := this.Init(\u0026params)\n\tif DtStatusFailed(status) {\n\t\treturn status\n\t}\n\treturn this.AddTile(data, dataSize, flags, 0, nil)\n}\n"
                    },
                    "IsValidPolyRef": {
                        "Name": "IsValidPolyRef",
                        "Code": "func (this *DtNavMesh) IsValidPolyRef(ref DtPolyRef) bool {\n\tif ref == 0 {\n\t\treturn false\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn false\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn false\n\t}\n\tif ip \u003e= (uint32)(this.m_tiles[it].Header.PolyCount) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
                    },
                    "RemoveTile": {
                        "Name": "RemoveTile",
                        "Code": "func (this *DtNavMesh) RemoveTile(ref DtTileRef, data *[]byte, dataSize *int) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttileIndex := this.DecodePolyIdTile((DtPolyRef)(ref))\n\ttileSalt := this.DecodePolyIdSalt((DtPolyRef)(ref))\n\tif (int32)(tileIndex) \u003e= this.m_maxTiles {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[tileIndex]\n\tif tile.Salt != tileSalt {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// Remove tile from hash lookup.\n\th := computeTileHash(tile.Header.X, tile.Header.Y, this.m_tileLutMask)\n\tvar prev *DtMeshTile = nil\n\tcur := this.m_posLookup[h]\n\tfor cur != nil {\n\t\tif cur == tile {\n\t\t\tif prev != nil {\n\t\t\t\tprev.Next = cur.Next\n\t\t\t} else {\n\t\t\t\tthis.m_posLookup[h] = cur.Next\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tprev = cur\n\t\tcur = cur.Next\n\t}\n\n\t// Remove connections to neighbour tiles.\n\tconst MAX_NEIS int = 32\n\tvar neis [MAX_NEIS]*DtMeshTile\n\tvar nneis int\n\n\t// Disconnect from other layers in current tile.\n\tnneis = this.GetTilesAt(tile.Header.X, tile.Header.Y, neis[:], MAX_NEIS)\n\tfor j := 0; j \u003c nneis; j++ {\n\t\tif neis[j] == tile {\n\t\t\tcontinue\n\t\t}\n\t\tthis.unconnectLinks(neis[j], tile)\n\t}\n\n\t// Disconnect from neighbour tiles.\n\tfor i := 0; i \u003c 8; i++ {\n\t\tnneis = this.GetNeighbourTilesAt(tile.Header.X, tile.Header.Y, i, neis[:], MAX_NEIS)\n\t\tfor j := 0; j \u003c nneis; j++ {\n\t\t\tthis.unconnectLinks(neis[j], tile)\n\t\t}\n\t}\n\n\t// Reset tile.\n\tif (tile.Flags \u0026 DT_TILE_FREE_DATA) != 0 {\n\t\t// Owns data\n\t\ttile.Data = nil\n\t\ttile.DataSize = 0\n\t\tif data != nil {\n\t\t\t*data = nil\n\t\t}\n\t\tif dataSize != nil {\n\t\t\t*dataSize = 0\n\t\t}\n\t} else {\n\t\tif data != nil {\n\t\t\t*data = tile.Data\n\t\t}\n\t\tif dataSize != nil {\n\t\t\t*dataSize = int(tile.DataSize)\n\t\t}\n\t}\n\n\ttile.Header = nil\n\ttile.Flags = 0\n\ttile.LinksFreeList = 0\n\ttile.Polys = nil\n\ttile.Verts = nil\n\ttile.Links = nil\n\ttile.DetailMeshes = nil\n\ttile.DetailVerts = nil\n\ttile.DetailTris = nil\n\ttile.BvTree = nil\n\ttile.OffMeshCons = nil\n\n\t// Update salt, salt should never be zero.\n\ttile.Salt = (tile.Salt + 1) \u0026 ((1 \u003c\u003c this.m_saltBits) - 1)\n\tif tile.Salt == 0 {\n\t\ttile.Salt++\n\t}\n\t// Add to free list.\n\ttile.Next = this.m_nextFree\n\tthis.m_nextFree = tile\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "RestoreTileState": {
                        "Name": "RestoreTileState",
                        "Code": "func (this *DtNavMesh) RestoreTileState(tile *DtMeshTile, data []byte, maxDataSize int) DtStatus {\n\t// Make sure there is enough space to store the state.\n\tsizeReq := this.GetTileStateSize(tile)\n\tif maxDataSize \u003c sizeReq {\n\t\treturn DT_FAILURE | DT_BUFFER_TOO_SMALL\n\t}\n\n\ttileState := (*dtTileState)(unsafe.Pointer(\u0026(data[0])))\n\tvar polyStates []dtPolyState\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026polyStates)))\n\tsliceHeader.Cap = int(tile.Header.PolyCount)\n\tsliceHeader.Len = int(tile.Header.PolyCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[DtAlign4(int(unsafe.Sizeof(dtTileState{})))])))\n\n\t// Check that the restore is possible.\n\tif tileState.magic != DT_NAVMESH_STATE_MAGIC {\n\t\treturn DT_FAILURE | DT_WRONG_MAGIC\n\t}\n\tif tileState.version != DT_NAVMESH_STATE_VERSION {\n\t\treturn DT_FAILURE | DT_WRONG_VERSION\n\t}\n\tif tileState.ref != this.GetTileRef(tile) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\n\t// Restore per poly state.\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tp := \u0026tile.Polys[i]\n\t\ts := \u0026polyStates[i]\n\t\tp.Flags = s.flags\n\t\tp.SetArea(s.area)\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "SetPolyArea": {
                        "Name": "SetPolyArea",
                        "Code": "func (this *DtNavMesh) SetPolyArea(ref DtPolyRef, area uint8) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\tpoly.SetArea(area)\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "SetPolyFlags": {
                        "Name": "SetPolyFlags",
                        "Code": "func (this *DtNavMesh) SetPolyFlags(ref DtPolyRef, flags uint16) DtStatus {\n\tif ref == 0 {\n\t\treturn DT_FAILURE\n\t}\n\tvar salt, it, ip uint32\n\tthis.DecodePolyId(ref, \u0026salt, \u0026it, \u0026ip)\n\tif it \u003e= (uint32)(this.m_maxTiles) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif this.m_tiles[it].Salt != salt || this.m_tiles[it].Header == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[it]\n\tif ip \u003e= (uint32)(tile.Header.PolyCount) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tpoly := \u0026tile.Polys[ip]\n\n\t// Change flags.\n\tpoly.Flags = flags\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "StoreTileState": {
                        "Name": "StoreTileState",
                        "Code": "func (this *DtNavMesh) StoreTileState(tile *DtMeshTile, data []byte, maxDataSize int) DtStatus {\n\t// Make sure there is enough space to store the state.\n\tsizeReq := this.GetTileStateSize(tile)\n\tif maxDataSize \u003c sizeReq {\n\t\treturn DT_FAILURE | DT_BUFFER_TOO_SMALL\n\t}\n\n\ttileState := (*dtTileState)(unsafe.Pointer(\u0026(data[0])))\n\tvar polyStates []dtPolyState\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026polyStates)))\n\tsliceHeader.Cap = int(tile.Header.PolyCount)\n\tsliceHeader.Len = int(tile.Header.PolyCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[DtAlign4(int(unsafe.Sizeof(dtTileState{})))])))\n\n\t// Store tile state.\n\ttileState.magic = DT_NAVMESH_STATE_MAGIC\n\ttileState.version = DT_NAVMESH_STATE_VERSION\n\ttileState.ref = this.GetTileRef(tile)\n\n\t// Store per poly state.\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tp := \u0026tile.Polys[i]\n\t\ts := \u0026polyStates[i]\n\t\ts.flags = p.Flags\n\t\ts.area = p.GetArea()\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "baseOffMeshLinks": {
                        "Name": "baseOffMeshLinks",
                        "Code": "func (this *DtNavMesh) baseOffMeshLinks(tile *DtMeshTile) {\n\tif tile == nil {\n\t\treturn\n\t}\n\n\tbase := this.GetPolyRefBase(tile)\n\n\t// Base off-mesh connection start points.\n\tfor i := 0; i \u003c int(tile.Header.OffMeshConCount); i++ {\n\t\tcon := \u0026tile.OffMeshCons[i]\n\t\tpoly := \u0026tile.Polys[con.Poly]\n\n\t\thalfExtents := [3]float32{con.Rad, tile.Header.WalkableClimb, con.Rad}\n\n\t\t// Find polygon to connect to.\n\t\tp := con.Pos[:] // First vertex\n\t\tvar nearestPt [3]float32\n\t\tref := this.findNearestPolyInTile(tile, p, halfExtents[:], nearestPt[:])\n\t\tif ref == 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// findNearestPoly may return too optimistic results, further check to make sure.\n\t\tif DtSqrFloat32(nearestPt[0]-p[0])+DtSqrFloat32(nearestPt[2]-p[2]) \u003e DtSqrFloat32(con.Rad) {\n\t\t\tcontinue\n\t\t}\n\t\t// Make sure the location is on current mesh.\n\t\tv := tile.Verts[poly.Verts[0]*3:]\n\t\tDtVcopy(v, nearestPt[:])\n\n\t\t// Link off-mesh connection to target poly.\n\t\tidx := allocLink(tile)\n\t\tif idx != DT_NULL_LINK {\n\t\t\tlink := \u0026tile.Links[idx]\n\t\t\tlink.Ref = ref\n\t\t\tlink.Edge = 0\n\t\t\tlink.Side = 0xff\n\t\t\tlink.Bmin = 0\n\t\t\tlink.Bmax = 0\n\t\t\t// Add to linked list.\n\t\t\tlink.Next = poly.FirstLink\n\t\t\tpoly.FirstLink = idx\n\t\t}\n\n\t\t// Start end-point is always connect back to off-mesh connection.\n\t\ttidx := allocLink(tile)\n\t\tif tidx != DT_NULL_LINK {\n\t\t\tlandPolyIdx := (uint16)(this.DecodePolyIdPoly(ref))\n\t\t\tlandPoly := \u0026tile.Polys[landPolyIdx]\n\t\t\tlink := \u0026tile.Links[tidx]\n\t\t\tlink.Ref = base | (DtPolyRef)(con.Poly)\n\t\t\tlink.Edge = 0xff\n\t\t\tlink.Side = 0xff\n\t\t\tlink.Bmin = 0\n\t\t\tlink.Bmax = 0\n\t\t\t// Add to linked list.\n\t\t\tlink.Next = landPoly.FirstLink\n\t\t\tlandPoly.FirstLink = tidx\n\t\t}\n\t}\n}\n"
                    },
                    "closestPointOnPoly": {
                        "Name": "closestPointOnPoly",
                        "Code": "func (this *DtNavMesh) closestPointOnPoly(ref DtPolyRef, pos, closest []float32, posOverPoly *bool) {\n\tvar tile *DtMeshTile = nil\n\tvar poly *DtPoly = nil\n\tthis.GetTileAndPolyByRefUnsafe(ref, \u0026tile, \u0026poly)\n\n\t// Off-mesh connections don't have detail polygons.\n\tif poly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\tv0 := tile.Verts[poly.Verts[0]*3:]\n\t\tv1 := tile.Verts[poly.Verts[1]*3:]\n\t\td0 := DtVdist(pos, v0)\n\t\td1 := DtVdist(pos, v1)\n\t\tu := d0 / (d0 + d1)\n\t\tDtVlerp(closest, v0, v1, u)\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = false\n\t\t}\n\t\treturn\n\t}\n\n\tpolysBase := uintptr(unsafe.Pointer(\u0026(tile.Polys[0])))\n\tcurrent := uintptr(unsafe.Pointer(poly))\n\tip := uint32(current-polysBase) / sizeofPoly\n\tpd := \u0026tile.DetailMeshes[ip]\n\n\t// Clamp point to be inside the polygon.\n\tvar verts [DT_VERTS_PER_POLYGON * 3]float32\n\tvar edged [DT_VERTS_PER_POLYGON]float32\n\tvar edget [DT_VERTS_PER_POLYGON]float32\n\tnv := int(poly.VertCount)\n\tfor i := 0; i \u003c nv; i++ {\n\t\tDtVcopy(verts[i*3:], tile.Verts[poly.Verts[i]*3:])\n\t}\n\tDtVcopy(closest, pos)\n\tif !DtDistancePtPolyEdgesSqr(pos, verts[:], nv, edged[:], edget[:]) {\n\t\t// Point is outside the polygon, dtClamp to nearest edge.\n\t\tdmin := edged[0]\n\t\timin := 0\n\t\tfor i := 1; i \u003c nv; i++ {\n\t\t\tif edged[i] \u003c dmin {\n\t\t\t\tdmin = edged[i]\n\t\t\t\timin = i\n\t\t\t}\n\t\t}\n\t\tva := verts[imin*3:]\n\t\tvb := verts[((imin+1)%nv)*3:]\n\t\tDtVlerp(closest, va, vb, edget[imin])\n\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = false\n\t\t}\n\t} else {\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = true\n\t\t}\n\t}\n\n\t// Find height at the location.\n\tfor j := 0; j \u003c int(pd.TriCount); j++ {\n\t\tt := tile.DetailTris[(int(pd.TriBase)+j)*4:]\n\t\tvar v [3][]float32\n\t\tfor k := 0; k \u003c 3; k++ {\n\t\t\tif t[k] \u003c poly.VertCount {\n\t\t\t\tv[k] = tile.Verts[poly.Verts[t[k]]*3:]\n\t\t\t} else {\n\t\t\t\tv[k] = tile.DetailVerts[(pd.VertBase+uint32(t[k]-poly.VertCount))*3:]\n\t\t\t}\n\t\t}\n\t\tvar h float32\n\t\tif DtClosestHeightPointTriangle(closest, v[0], v[1], v[2], \u0026h) {\n\t\t\tclosest[1] = h\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
                    },
                    "connectExtLinks": {
                        "Name": "connectExtLinks",
                        "Code": "func (this *DtNavMesh) connectExtLinks(tile, target *DtMeshTile, side int) {\n\tif tile == nil {\n\t\treturn\n\t}\n\n\t// Connect border links.\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tpoly := \u0026tile.Polys[i]\n\n\t\t// Create new links.\n\t\t//\t\tunsigned short m = DT_EXT_LINK | (unsigned short)side;\n\n\t\tnv := int(poly.VertCount)\n\t\tfor j := 0; j \u003c nv; j++ {\n\t\t\t// Skip non-portal edges.\n\t\t\tif (poly.Neis[j] \u0026 DT_EXT_LINK) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdir := (int)(poly.Neis[j] \u0026 0xff)\n\t\t\tif side != -1 \u0026\u0026 dir != side {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Create new links\n\t\t\tva := tile.Verts[poly.Verts[j]*3:]\n\t\t\tvb := tile.Verts[poly.Verts[(j+1)%nv]*3:]\n\t\t\tvar nei [4]DtPolyRef\n\t\t\tvar neia [4 * 2]float32\n\t\t\tnnei := this.findConnectingPolys(va, vb, target, DtOppositeTile(dir), nei[:], neia[:], 4)\n\t\t\tfor k := 0; k \u003c nnei; k++ {\n\t\t\t\tidx := allocLink(tile)\n\t\t\t\tif idx != DT_NULL_LINK {\n\t\t\t\t\tlink := \u0026tile.Links[idx]\n\t\t\t\t\tlink.Ref = nei[k]\n\t\t\t\t\tlink.Edge = (uint8)(j)\n\t\t\t\t\tlink.Side = (uint8)(dir)\n\n\t\t\t\t\tlink.Next = poly.FirstLink\n\t\t\t\t\tpoly.FirstLink = idx\n\n\t\t\t\t\t// Compress portal limits to a byte value.\n\t\t\t\t\tif dir == 0 || dir == 4 {\n\t\t\t\t\t\ttmin := (neia[k*2+0] - va[2]) / (vb[2] - va[2])\n\t\t\t\t\t\ttmax := (neia[k*2+1] - va[2]) / (vb[2] - va[2])\n\t\t\t\t\t\tif tmin \u003e tmax {\n\t\t\t\t\t\t\tDtSwapFloat32(\u0026tmin, \u0026tmax)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlink.Bmin = (uint8)(DtClampFloat32(tmin, 0.0, 1.0) * 255.0)\n\t\t\t\t\t\tlink.Bmax = (uint8)(DtClampFloat32(tmax, 0.0, 1.0) * 255.0)\n\t\t\t\t\t} else if dir == 2 || dir == 6 {\n\t\t\t\t\t\ttmin := (neia[k*2+0] - va[0]) / (vb[0] - va[0])\n\t\t\t\t\t\ttmax := (neia[k*2+1] - va[0]) / (vb[0] - va[0])\n\t\t\t\t\t\tif tmin \u003e tmax {\n\t\t\t\t\t\t\tDtSwapFloat32(\u0026tmin, \u0026tmax)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlink.Bmin = (uint8)(DtClampFloat32(tmin, 0.0, 1.0) * 255.0)\n\t\t\t\t\t\tlink.Bmax = (uint8)(DtClampFloat32(tmax, 0.0, 1.0) * 255.0)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
                    },
                    "connectExtOffMeshLinks": {
                        "Name": "connectExtOffMeshLinks",
                        "Code": "func (this *DtNavMesh) connectExtOffMeshLinks(tile, target *DtMeshTile, side int) {\n\tif tile == nil {\n\t\treturn\n\t}\n\n\t// Connect off-mesh links.\n\t// We are interested on links which land from target tile to this tile.\n\tvar oppositeSide uint16\n\tif side == -1 {\n\t\toppositeSide = 0xff\n\t} else {\n\t\toppositeSide = uint16(DtOppositeTile(side))\n\t}\n\n\tfor i := 0; i \u003c int(target.Header.OffMeshConCount); i++ {\n\t\ttargetCon := \u0026target.OffMeshCons[i]\n\t\tif uint16(targetCon.Side) != oppositeSide {\n\t\t\tcontinue\n\t\t}\n\t\ttargetPoly := \u0026target.Polys[targetCon.Poly]\n\t\t// Skip off-mesh connections which start location could not be connected at all.\n\t\tif targetPoly.FirstLink == DT_NULL_LINK {\n\t\t\tcontinue\n\t\t}\n\t\thalfExtents := [3]float32{targetCon.Rad, target.Header.WalkableClimb, targetCon.Rad}\n\n\t\t// Find polygon to connect to.\n\t\tp := targetCon.Pos[3:]\n\t\tvar nearestPt [3]float32\n\t\tref := this.findNearestPolyInTile(tile, p, halfExtents[:], nearestPt[:])\n\t\tif ref == 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// findNearestPoly may return too optimistic results, further check to make sure.\n\t\tif DtSqrFloat32(nearestPt[0]-p[0])+DtSqrFloat32(nearestPt[2]-p[2]) \u003e DtSqrFloat32(targetCon.Rad) {\n\t\t\tcontinue\n\t\t}\n\t\t// Make sure the location is on current mesh.\n\t\tv := target.Verts[targetPoly.Verts[1]*3:]\n\t\tDtVcopy(v, nearestPt[:])\n\n\t\t// Link off-mesh connection to target poly.\n\t\tidx := allocLink(target)\n\t\tif idx != DT_NULL_LINK {\n\t\t\tlink := \u0026target.Links[idx]\n\t\t\tlink.Ref = ref\n\t\t\tlink.Edge = 1\n\t\t\tlink.Side = uint8(oppositeSide)\n\t\t\tlink.Bmin = 0\n\t\t\tlink.Bmax = 0\n\t\t\t// Add to linked list.\n\t\t\tlink.Next = targetPoly.FirstLink\n\t\t\ttargetPoly.FirstLink = idx\n\t\t}\n\n\t\t// Link target poly to off-mesh connection.\n\t\tif (targetCon.Flags \u0026 DT_OFFMESH_CON_BIDIR) != 0 {\n\t\t\ttidx := allocLink(tile)\n\t\t\tif tidx != DT_NULL_LINK {\n\t\t\t\tlandPolyIdx := (uint16)(this.DecodePolyIdPoly(ref))\n\t\t\t\tlandPoly := \u0026tile.Polys[landPolyIdx]\n\t\t\t\tlink := \u0026tile.Links[tidx]\n\t\t\t\tlink.Ref = this.GetPolyRefBase(target) | (DtPolyRef)(targetCon.Poly)\n\t\t\t\tlink.Edge = 0xff\n\t\t\t\tif side == -1 {\n\t\t\t\t\tlink.Side = 0xff\n\t\t\t\t} else {\n\t\t\t\t\tlink.Side = uint8(side)\n\t\t\t\t}\n\t\t\t\tlink.Bmin = 0\n\t\t\t\tlink.Bmax = 0\n\t\t\t\t// Add to linked list.\n\t\t\t\tlink.Next = landPoly.FirstLink\n\t\t\t\tlandPoly.FirstLink = tidx\n\t\t\t}\n\t\t}\n\t}\n}\n"
                    },
                    "connectIntLinks": {
                        "Name": "connectIntLinks",
                        "Code": "func (this *DtNavMesh) connectIntLinks(tile *DtMeshTile) {\n\tif tile == nil {\n\t\treturn\n\t}\n\n\tbase := this.GetPolyRefBase(tile)\n\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tpoly := \u0026tile.Polys[i]\n\t\tpoly.FirstLink = DT_NULL_LINK\n\n\t\tif poly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Build edge links backwards so that the links will be\n\t\t// in the linked list from lowest index to highest.\n\t\tfor j := int(poly.VertCount - 1); j \u003e= 0; j-- {\n\t\t\t// Skip hard and non-internal edges.\n\t\t\tif poly.Neis[j] == 0 || (poly.Neis[j]\u0026DT_EXT_LINK) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tidx := allocLink(tile)\n\t\t\tif idx != DT_NULL_LINK {\n\t\t\t\tlink := \u0026tile.Links[idx]\n\t\t\t\tlink.Ref = base | (DtPolyRef)(poly.Neis[j]-1)\n\t\t\t\tlink.Edge = (uint8)(j)\n\t\t\t\tlink.Side = 0xff\n\t\t\t\tlink.Bmin = 0\n\t\t\t\tlink.Bmax = 0\n\t\t\t\t// Add to linked list.\n\t\t\t\tlink.Next = poly.FirstLink\n\t\t\t\tpoly.FirstLink = idx\n\t\t\t}\n\t\t}\n\t}\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *DtNavMesh) constructor() {\n\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtNavMesh) destructor() {\n\tfor i := 0; i \u003c int(this.m_maxTiles); i++ {\n\t\tif (this.m_tiles[i].Flags \u0026 DT_TILE_FREE_DATA) != 0 {\n\t\t\tthis.m_tiles[i].Data = nil\n\t\t\tthis.m_tiles[i].DataSize = 0\n\t\t}\n\t}\n\tthis.m_posLookup = nil\n\tthis.m_tiles = nil\n}\n"
                    },
                    "findConnectingPolys": {
                        "Name": "findConnectingPolys",
                        "Code": "func (this *DtNavMesh) findConnectingPolys(va, vb []float32, tile *DtMeshTile, side int, con []DtPolyRef, conarea []float32, maxcon int) int {\n\tif tile == nil {\n\t\treturn 0\n\t}\n\n\tvar amin, amax [2]float32\n\tcalcSlabEndPoints(va, vb, amin[:], amax[:], side)\n\tapos := getSlabCoord(va, side)\n\n\t// Remove links pointing to 'side' and compact the links array.\n\tvar bmin, bmax [2]float32\n\tm := DT_EXT_LINK | (uint16)(side)\n\tn := 0\n\n\tbase := this.GetPolyRefBase(tile)\n\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tpoly := \u0026tile.Polys[i]\n\t\tnv := int(poly.VertCount)\n\t\tfor j := 0; j \u003c nv; j++ {\n\t\t\t// Skip edges which do not point to the right side.\n\t\t\tif poly.Neis[j] != m {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvc := tile.Verts[poly.Verts[j]*3:]\n\t\t\tvd := tile.Verts[poly.Verts[(j+1)%nv]*3:]\n\t\t\tbpos := getSlabCoord(vc, side)\n\n\t\t\t// Segments are not close enough.\n\t\t\tif DtAbsFloat32(apos-bpos) \u003e 0.01 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Check if the segments touch.\n\t\t\tcalcSlabEndPoints(vc, vd, bmin[:], bmax[:], side)\n\n\t\t\tif !overlapSlabs(amin[:], amax[:], bmin[:], bmax[:], 0.01, tile.Header.WalkableClimb) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Add return value.\n\t\t\tif n \u003c maxcon {\n\t\t\t\tconarea[n*2+0] = DtMaxFloat32(amin[0], bmin[0])\n\t\t\t\tconarea[n*2+1] = DtMinFloat32(amax[0], bmax[0])\n\t\t\t\tcon[n] = base | (DtPolyRef)(i)\n\t\t\t\tn++\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn n\n}\n"
                    },
                    "findNearestPolyInTile": {
                        "Name": "findNearestPolyInTile",
                        "Code": "func (this *DtNavMesh) findNearestPolyInTile(tile *DtMeshTile, center, halfExtents, nearestPt []float32) DtPolyRef {\n\tvar bmin, bmax [3]float32\n\tDtVsub(bmin[:], center, halfExtents)\n\tDtVadd(bmax[:], center, halfExtents)\n\n\t// Get nearby polygons from proximity grid.\n\tvar polys [128]DtPolyRef\n\tpolyCount := this.queryPolygonsInTile(tile, bmin[:], bmax[:], polys[:], 128)\n\n\t// Find nearest polygon amongst the nearby polygons.\n\tvar nearest DtPolyRef = 0\n\tvar nearestDistanceSqr float32 = math.MaxFloat32\n\tfor i := 0; i \u003c polyCount; i++ {\n\t\tref := polys[i]\n\t\tvar closestPtPoly [3]float32\n\t\tvar diff [3]float32\n\t\tposOverPoly := false\n\t\tvar d float32\n\t\tthis.closestPointOnPoly(ref, center, closestPtPoly[:], \u0026posOverPoly)\n\n\t\t// If a point is directly over a polygon and closer than\n\t\t// climb height, favor that instead of straight line nearest point.\n\t\tDtVsub(diff[:], center, closestPtPoly[:])\n\t\tif posOverPoly {\n\t\t\td = DtAbsFloat32(diff[1]) - tile.Header.WalkableClimb\n\t\t\tif d \u003e 0 {\n\t\t\t\td = d * d\n\t\t\t} else {\n\t\t\t\td = 0\n\t\t\t}\n\t\t} else {\n\t\t\td = DtVlenSqr(diff[:])\n\t\t}\n\n\t\tif d \u003c nearestDistanceSqr {\n\t\t\tDtVcopy(nearestPt, closestPtPoly[:])\n\t\t\tnearestDistanceSqr = d\n\t\t\tnearest = ref\n\t\t}\n\t}\n\n\treturn nearest\n}\n"
                    },
                    "queryPolygonsInTile": {
                        "Name": "queryPolygonsInTile",
                        "Code": "func (this *DtNavMesh) queryPolygonsInTile(tile *DtMeshTile, qmin, qmax []float32, polys []DtPolyRef, maxPolys int) int {\n\tif tile.BvTree != nil {\n\t\tnodeIndex := 0\n\t\tendIndex := int(tile.Header.BvNodeCount)\n\t\ttbmin := tile.Header.Bmin[:]\n\t\ttbmax := tile.Header.Bmax[:]\n\t\tqfac := tile.Header.BvQuantFactor\n\n\t\t// Calculate quantized box\n\t\tvar bmin, bmax [3]uint16\n\t\t// dtClamp query box to world box.\n\t\tminx := DtClampFloat32(qmin[0], tbmin[0], tbmax[0]) - tbmin[0]\n\t\tminy := DtClampFloat32(qmin[1], tbmin[1], tbmax[1]) - tbmin[1]\n\t\tminz := DtClampFloat32(qmin[2], tbmin[2], tbmax[2]) - tbmin[2]\n\t\tmaxx := DtClampFloat32(qmax[0], tbmin[0], tbmax[0]) - tbmin[0]\n\t\tmaxy := DtClampFloat32(qmax[1], tbmin[1], tbmax[1]) - tbmin[1]\n\t\tmaxz := DtClampFloat32(qmax[2], tbmin[2], tbmax[2]) - tbmin[2]\n\t\t// Quantize\n\t\tbmin[0] = uint16(qfac*minx) \u0026 0xfffe\n\t\tbmin[1] = uint16(qfac*miny) \u0026 0xfffe\n\t\tbmin[2] = uint16(qfac*minz) \u0026 0xfffe\n\t\tbmax[0] = uint16(qfac*maxx+1) | 1\n\t\tbmax[1] = uint16(qfac*maxy+1) | 1\n\t\tbmax[2] = uint16(qfac*maxz+1) | 1\n\n\t\t// Traverse tree\n\t\tbase := this.GetPolyRefBase(tile)\n\t\tn := 0\n\t\tfor nodeIndex \u003c endIndex {\n\t\t\tnode := \u0026tile.BvTree[nodeIndex]\n\t\t\toverlap := DtOverlapQuantBounds(bmin[:], bmax[:], node.Bmin[:], node.Bmax[:])\n\t\t\tisLeafNode := (node.I \u003e= 0)\n\n\t\t\tif isLeafNode \u0026\u0026 overlap {\n\t\t\t\tif n \u003c maxPolys {\n\t\t\t\t\tpolys[n] = base | (DtPolyRef)(node.I)\n\t\t\t\t\tn = n + 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif overlap || isLeafNode {\n\t\t\t\tnodeIndex++\n\t\t\t} else {\n\t\t\t\tescapeIndex := int(-node.I)\n\t\t\t\tnodeIndex += escapeIndex\n\t\t\t}\n\t\t}\n\n\t\treturn n\n\t} else {\n\t\tvar bmin, bmax [3]float32\n\t\tn := 0\n\t\tbase := this.GetPolyRefBase(tile)\n\t\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\t\tp := \u0026tile.Polys[i]\n\t\t\t// Do not return off-mesh connection polygons.\n\t\t\tif p.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Calc polygon bounds.\n\t\t\tv := tile.Verts[p.Verts[0]*3:]\n\t\t\tDtVcopy(bmin[:], v)\n\t\t\tDtVcopy(bmax[:], v)\n\t\t\tfor j := 1; j \u003c int(p.VertCount); j++ {\n\t\t\t\tv = tile.Verts[p.Verts[j]*3:]\n\t\t\t\tDtVmin(bmin[:], v)\n\t\t\t\tDtVmax(bmax[:], v)\n\t\t\t}\n\t\t\tif DtOverlapBounds(qmin, qmax, bmin[:], bmax[:]) {\n\t\t\t\tif n \u003c maxPolys {\n\t\t\t\t\tpolys[n] = base | (DtPolyRef)(i)\n\t\t\t\t\tn = n + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn n\n\t}\n}\n"
                    },
                    "unconnectLinks": {
                        "Name": "unconnectLinks",
                        "Code": "func (this *DtNavMesh) unconnectLinks(tile, target *DtMeshTile) {\n\tif tile == nil || target == nil {\n\t\treturn\n\t}\n\n\ttargetNum := this.DecodePolyIdTile(DtPolyRef(this.GetTileRef(target)))\n\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tpoly := \u0026tile.Polys[i]\n\t\tj := poly.FirstLink\n\t\tpj := DT_NULL_LINK\n\t\tfor j != DT_NULL_LINK {\n\t\t\tif this.DecodePolyIdTile(tile.Links[j].Ref) == targetNum {\n\t\t\t\t// Remove link.\n\t\t\t\tnj := tile.Links[j].Next\n\t\t\t\tif pj == DT_NULL_LINK {\n\t\t\t\t\tpoly.FirstLink = nj\n\t\t\t\t} else {\n\t\t\t\t\ttile.Links[pj].Next = nj\n\t\t\t\t}\n\t\t\t\tfreeLink(tile, j)\n\t\t\t\tj = nj\n\t\t\t} else {\n\t\t\t\t// Advance\n\t\t\t\tpj = j\n\t\t\t\tj = tile.Links[j].Next\n\t\t\t}\n\t\t}\n\t}\n}\n"
                    }
                }
            },
            "DtNavMeshCreateParams": {
                "Name": "DtNavMeshCreateParams",
                "Code": "/// Represents the source data used to build an navigation mesh tile.\n/// @ingroup detour\ntype DtNavMeshCreateParams struct {\n\n\t/// @name Polygon Mesh Attributes\n\t/// Used to create the base navigation graph.\n\t/// See #rcPolyMesh for details related to these attributes.\n\t/// @{\n\n\tVerts     []uint16 ///\u003c The polygon mesh vertices. [(x, y, z) * #vertCount] [Unit: vx]\n\tVertCount int32    ///\u003c The number vertices in the polygon mesh. [Limit: \u003e= 3]\n\tPolys     []uint16 ///\u003c The polygon data. [Size: #polyCount * 2 * #nvp]\n\tPolyFlags []uint16 ///\u003c The user defined flags assigned to each polygon. [Size: #polyCount]\n\tPolyAreas []uint8  ///\u003c The user defined area ids assigned to each polygon. [Size: #polyCount]\n\tPolyCount int32    ///\u003c Number of polygons in the mesh. [Limit: \u003e= 1]\n\tNvp       int32    ///\u003c Number maximum number of vertices per polygon. [Limit: \u003e= 3]\n\n\t/// @}\n\t/// @name Height Detail Attributes (Optional)\n\t/// See #rcPolyMeshDetail for details related to these attributes.\n\t/// @{\n\n\tDetailMeshes     []uint32  ///\u003c The height detail sub-mesh data. [Size: 4 * #polyCount]\n\tDetailVerts      []float32 ///\u003c The detail mesh vertices. [Size: 3 * #detailVertsCount] [Unit: wu]\n\tDetailVertsCount int32     ///\u003c The number of vertices in the detail mesh.\n\tDetailTris       []uint8   ///\u003c The detail mesh triangles. [Size: 4 * #detailTriCount]\n\tDetailTriCount   int32     ///\u003c The number of triangles in the detail mesh.\n\n\t/// @}\n\t/// @name Off-Mesh Connections Attributes (Optional)\n\t/// Used to define a custom point-to-point edge within the navigation graph, an\n\t/// off-mesh connection is a user defined traversable connection made up to two vertices,\n\t/// at least one of which resides within a navigation mesh polygon.\n\t/// @{\n\n\t/// Off-mesh connection vertices. [(ax, ay, az, bx, by, bz) * #offMeshConCount] [Unit: wu]\n\tOffMeshConVerts []float32\n\t/// Off-mesh connection radii. [Size: #offMeshConCount] [Unit: wu]\n\tOffMeshConRad []float32\n\t/// User defined flags assigned to the off-mesh connections. [Size: #offMeshConCount]\n\tOffMeshConFlags []uint16\n\t/// User defined area ids assigned to the off-mesh connections. [Size: #offMeshConCount]\n\tOffMeshConAreas []uint8\n\t/// The permitted travel direction of the off-mesh connections. [Size: #offMeshConCount]\n\t///\n\t/// 0 = Travel only from endpoint A to endpoint B.\u003cbr/\u003e\n\t/// #DT_OFFMESH_CON_BIDIR = Bidirectional travel.\n\tOffMeshConDir []uint8\n\t/// The user defined ids of the off-mesh connection. [Size: #offMeshConCount]\n\tOffMeshConUserID []uint32\n\t/// The number of off-mesh connections. [Limit: \u003e= 0]\n\tOffMeshConCount int32\n\n\t/// @}\n\t/// @name Tile Attributes\n\t/// @note The tile grid/layer data can be left at zero if the destination is a single tile mesh.\n\t/// @{\n\n\tUserId    uint32     ///\u003c The user defined id of the tile.\n\tTileX     int32      ///\u003c The tile's x-grid location within the multi-tile destination mesh. (Along the x-axis.)\n\tTileY     int32      ///\u003c The tile's y-grid location within the multi-tile desitation mesh. (Along the z-axis.)\n\tTileLayer int32      ///\u003c The tile's layer within the layered destination mesh. [Limit: \u003e= 0] (Along the y-axis.)\n\tBmin      [3]float32 ///\u003c The minimum bounds of the tile. [(x, y, z)] [Unit: wu]\n\tBmax      [3]float32 ///\u003c The maximum bounds of the tile. [(x, y, z)] [Unit: wu]\n\n\t/// @}\n\t/// @name General Configuration Attributes\n\t/// @{\n\n\tWalkableHeight float32 ///\u003c The agent height. [Unit: wu]\n\tWalkableRadius float32 ///\u003c The agent radius. [Unit: wu]\n\tWalkableClimb  float32 ///\u003c The agent maximum traversable ledge. (Up/Down) [Unit: wu]\n\tCs             float32 ///\u003c The xz-plane cell size of the polygon mesh. [Limit: \u003e 0] [Unit: wu]\n\tCh             float32 ///\u003c The y-axis cell height of the polygon mesh. [Limit: \u003e 0] [Unit: wu]\n\n\t/// True if a bounding volume tree should be built for the tile.\n\t/// @note The BVTree is not normally needed for layered navigation meshes.\n\tBuildBvTree bool\n\n\t/// @}\n}\n",
                "Methods": {}
            },
            "DtNavMeshParams": {
                "Name": "DtNavMeshParams",
                "Code": "// / Configuration parameters used to define multi-tile navigation meshes.\n// / The values are used to allocate space during the initialization of a navigation mesh.\n// / @see dtNavMesh::init()\n// / @ingroup detour\ntype DtNavMeshParams struct {\n\tOrig       [3]float32 ///\u003c The world space origin of the navigation mesh's tile space. [(x, y, z)]\n\tTileWidth  float32    ///\u003c The width of each tile. (Along the x-axis.)\n\tTileHeight float32    ///\u003c The height of each tile. (Along the z-axis.)\n\tMaxTiles   uint32     ///\u003c The maximum number of tiles the navigation mesh can contain.\n\tMaxPolys   uint32     ///\u003c The maximum number of polygons each tile can contain.\n}\n",
                "Methods": {}
            },
            "DtNavMeshQuery": {
                "Name": "DtNavMeshQuery",
                "Code": "type DtNavMeshQuery struct {\n\tm_nav          *DtNavMesh   ///\u003c Pointer to navmesh data.\n\tm_query        dtQueryData  ///\u003c Sliced query state.\n\tm_tinyNodePool *DtNodePool  ///\u003c Pointer to small node pool.\n\tm_nodePool     *DtNodePool  ///\u003c Pointer to node pool.\n\tm_openList     *DtNodeQueue ///\u003c Pointer to open list queue.\n}\n",
                "Methods": {
                    "ClosestPointOnPoly": {
                        "Name": "ClosestPointOnPoly",
                        "Code": "func (this *DtNavMeshQuery) ClosestPointOnPoly(ref DtPolyRef, pos, closest []float32, posOverPoly *bool) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tvar tile *DtMeshTile\n\tvar poly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(ref, \u0026tile, \u0026poly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif tile == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// Off-mesh connections don't have detail polygons.\n\tif poly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\tv0 := tile.Verts[poly.Verts[0]*3:]\n\t\tv1 := tile.Verts[poly.Verts[1]*3:]\n\t\td0 := DtVdist(pos, v0)\n\t\td1 := DtVdist(pos, v1)\n\t\tu := d0 / (d0 + d1)\n\t\tDtVlerp(closest, v0, v1, u)\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = false\n\t\t}\n\t\treturn DT_SUCCESS\n\t}\n\n\tpolyBase := uintptr(unsafe.Pointer(\u0026(tile.Polys[0])))\n\tcurrent := uintptr(unsafe.Pointer(poly))\n\tip := (uint32)(current-polyBase) / sizeofPoly\n\tpd := \u0026tile.DetailMeshes[ip]\n\n\t// Clamp point to be inside the polygon.\n\tvar verts [DT_VERTS_PER_POLYGON * 3]float32\n\tvar edged [DT_VERTS_PER_POLYGON]float32\n\tvar edget [DT_VERTS_PER_POLYGON]float32\n\tnv := int(poly.VertCount)\n\tfor i := 0; i \u003c nv; i++ {\n\t\tDtVcopy(verts[i*3:], tile.Verts[poly.Verts[i]*3:])\n\t}\n\tDtVcopy(closest, pos)\n\tif !DtDistancePtPolyEdgesSqr(pos, verts[:], nv, edged[:], edget[:]) {\n\t\t// Point is outside the polygon, dtClamp to nearest edge.\n\t\tdmin := edged[0]\n\t\timin := 0\n\t\tfor i := 1; i \u003c nv; i++ {\n\t\t\tif edged[i] \u003c dmin {\n\t\t\t\tdmin = edged[i]\n\t\t\t\timin = i\n\t\t\t}\n\t\t}\n\t\tva := verts[imin*3:]\n\t\tvb := verts[((imin+1)%nv)*3:]\n\t\tDtVlerp(closest, va, vb, edget[imin])\n\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = false\n\t\t}\n\t} else {\n\t\tif posOverPoly != nil {\n\t\t\t*posOverPoly = true\n\t\t}\n\t}\n\n\t// Find height at the location.\n\tfor j := 0; j \u003c int(pd.TriCount); j++ {\n\t\tt := tile.DetailTris[(int(pd.TriBase)+j)*4:]\n\t\tvar v [3][]float32\n\t\tfor k := 0; k \u003c 3; k++ {\n\t\t\tif t[k] \u003c poly.VertCount {\n\t\t\t\tv[k] = tile.Verts[poly.Verts[t[k]]*3:]\n\t\t\t} else {\n\t\t\t\tv[k] = tile.DetailVerts[(pd.VertBase+uint32(t[k]-poly.VertCount))*3:]\n\t\t\t}\n\t\t}\n\t\tvar h float32\n\t\tif DtClosestHeightPointTriangle(closest, v[0], v[1], v[2], \u0026h) {\n\t\t\tclosest[1] = h\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "ClosestPointOnPolyBoundary": {
                        "Name": "ClosestPointOnPolyBoundary",
                        "Code": "func (this *DtNavMeshQuery) ClosestPointOnPolyBoundary(ref DtPolyRef, pos, closest []float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tvar tile *DtMeshTile\n\tvar poly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(ref, \u0026tile, \u0026poly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\n\t// Collect vertices.\n\tvar verts [DT_VERTS_PER_POLYGON * 3]float32\n\tvar edged [DT_VERTS_PER_POLYGON]float32\n\tvar edget [DT_VERTS_PER_POLYGON]float32\n\tnv := 0\n\tfor i := 0; i \u003c int(poly.VertCount); i++ {\n\t\tDtVcopy(verts[nv*3:], tile.Verts[poly.Verts[i]*3:])\n\t\tnv++\n\t}\n\n\tinside := DtDistancePtPolyEdgesSqr(pos, verts[:], nv, edged[:], edget[:])\n\tif inside {\n\t\t// Point is inside the polygon, return the point.\n\t\tDtVcopy(closest, pos)\n\t} else {\n\t\t// Point is outside the polygon, dtClamp to nearest edge.\n\t\tdmin := edged[0]\n\t\timin := 0\n\t\tfor i := 1; i \u003c nv; i++ {\n\t\t\tif edged[i] \u003c dmin {\n\t\t\t\tdmin = edged[i]\n\t\t\t\timin = i\n\t\t\t}\n\t\t}\n\t\tva := verts[imin*3:]\n\t\tvb := verts[((imin+1)%nv)*3:]\n\t\tDtVlerp(closest, va, vb, edget[imin])\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "FinalizeSlicedFindPath": {
                        "Name": "FinalizeSlicedFindPath",
                        "Code": "func (this *DtNavMeshQuery) FinalizeSlicedFindPath(path []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\t*pathCount = 0\n\n\tif DtStatusFailed(this.m_query.status) {\n\t\t// Reset query.\n\t\tthis.m_query = dtQueryData{}\n\t\treturn DT_FAILURE\n\t}\n\n\tn := 0\n\n\tif this.m_query.startRef == this.m_query.endRef {\n\t\t// Special case: the search starts and ends at same poly.\n\t\tpath[n] = this.m_query.startRef\n\t\tn++\n\t} else {\n\t\t// Reverse the path.\n\t\tDtAssert(this.m_query.lastBestNode != nil)\n\n\t\tif this.m_query.lastBestNode.Id != this.m_query.endRef {\n\t\t\tthis.m_query.status |= DT_PARTIAL_RESULT\n\t\t}\n\n\t\tvar prev *DtNode\n\t\tnode := this.m_query.lastBestNode\n\t\tvar prevRay DtNodeFlags\n\t\tfor node != nil {\n\t\t\tnext := this.m_nodePool.GetNodeAtIdx(node.Pidx)\n\t\t\tnode.Pidx = this.m_nodePool.GetNodeIdx(prev)\n\t\t\tprev = node\n\t\t\tnextRay := node.Flags \u0026 DT_NODE_PARENT_DETACHED                // keep track of whether parent is not adjacent (i.e. due to raycast shortcut)\n\t\t\tnode.Flags = (node.Flags \u0026 ^DT_NODE_PARENT_DETACHED) | prevRay // and store it in the reversed path's node\n\t\t\tprevRay = nextRay\n\t\t\tnode = next\n\t\t}\n\n\t\t// Store path\n\t\tnode = prev\n\t\tfor node != nil {\n\t\t\tnext := this.m_nodePool.GetNodeAtIdx(node.Pidx)\n\t\t\tvar status DtStatus\n\t\t\tif (node.Flags \u0026 DT_NODE_PARENT_DETACHED) != 0 {\n\t\t\t\tvar t float32\n\t\t\t\tvar normal [3]float32\n\t\t\t\tvar m int\n\t\t\t\tstatus = this.Raycast(node.Id, node.Pos[:], next.Pos[:], this.m_query.filter, \u0026t, normal[:], path[n:], \u0026m, maxPath-n)\n\t\t\t\tn += m\n\t\t\t\t// raycast ends on poly boundary and the path might include the next poly boundary.\n\t\t\t\tif path[n-1] == next.Id {\n\t\t\t\t\tn-- // remove to avoid duplicates\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath[n] = node.Id\n\t\t\t\tn++\n\t\t\t\tif n \u003e= maxPath {\n\t\t\t\t\tstatus = DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (status \u0026 DT_STATUS_DETAIL_MASK) != 0 {\n\t\t\t\tthis.m_query.status |= status \u0026 DT_STATUS_DETAIL_MASK\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = next\n\t\t}\n\t}\n\n\tdetails := this.m_query.status \u0026 DT_STATUS_DETAIL_MASK\n\n\t// Reset query.\n\tthis.m_query = dtQueryData{}\n\t*pathCount = n\n\n\treturn DT_SUCCESS | details\n}\n"
                    },
                    "FinalizeSlicedFindPathPartial": {
                        "Name": "FinalizeSlicedFindPathPartial",
                        "Code": "func (this *DtNavMeshQuery) FinalizeSlicedFindPathPartial(existing []DtPolyRef, existingSize int,\n\tpath []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\t*pathCount = 0\n\n\tif existingSize == 0 {\n\t\treturn DT_FAILURE\n\t}\n\n\tif DtStatusFailed(this.m_query.status) {\n\t\t// Reset query.\n\t\tthis.m_query = dtQueryData{}\n\t\treturn DT_FAILURE\n\t}\n\n\tn := 0\n\n\tif this.m_query.startRef == this.m_query.endRef {\n\t\t// Special case: the search starts and ends at same poly.\n\t\tpath[n] = this.m_query.startRef\n\t\tn++\n\t} else {\n\t\t// Find furthest existing node that was visited.\n\t\tvar prev *DtNode\n\t\tvar node *DtNode\n\t\tfor i := existingSize - 1; i \u003e= 0; i-- {\n\t\t\tvar tempNode [1]*DtNode\n\t\t\tbFind := this.m_nodePool.FindNodes(existing[i], tempNode[:], 1)\n\t\t\tif bFind \u003e 0 {\n\t\t\t\tnode = tempNode[0]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif node == nil {\n\t\t\tthis.m_query.status |= DT_PARTIAL_RESULT\n\t\t\tDtAssert(this.m_query.lastBestNode != nil)\n\t\t\tnode = this.m_query.lastBestNode\n\t\t}\n\n\t\t// Reverse the path.\n\t\tvar prevRay DtNodeFlags\n\t\tfor node != nil {\n\t\t\tnext := this.m_nodePool.GetNodeAtIdx(node.Pidx)\n\t\t\tnode.Pidx = this.m_nodePool.GetNodeIdx(prev)\n\t\t\tprev = node\n\t\t\tnextRay := node.Flags \u0026 DT_NODE_PARENT_DETACHED                // keep track of whether parent is not adjacent (i.e. due to raycast shortcut)\n\t\t\tnode.Flags = (node.Flags \u0026 ^DT_NODE_PARENT_DETACHED) | prevRay // and store it in the reversed path's node\n\t\t\tprevRay = nextRay\n\t\t\tnode = next\n\t\t}\n\n\t\t// Store path\n\t\tnode = prev\n\t\tfor node != nil {\n\t\t\tnext := this.m_nodePool.GetNodeAtIdx(node.Pidx)\n\t\t\tvar status DtStatus\n\t\t\tif (node.Flags \u0026 DT_NODE_PARENT_DETACHED) != 0 {\n\t\t\t\tvar t float32\n\t\t\t\tvar normal [3]float32\n\t\t\t\tvar m int\n\t\t\t\tstatus = this.Raycast(node.Id, node.Pos[:], next.Pos[:], this.m_query.filter, \u0026t, normal[:], path[n:], \u0026m, maxPath-n)\n\t\t\t\tn += m\n\t\t\t\t// raycast ends on poly boundary and the path might include the next poly boundary.\n\t\t\t\tif path[n-1] == next.Id {\n\t\t\t\t\tn-- // remove to avoid duplicates\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath[n] = node.Id\n\t\t\t\tn++\n\t\t\t\tif n \u003e= maxPath {\n\t\t\t\t\tstatus = DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (status \u0026 DT_STATUS_DETAIL_MASK) != 0 {\n\t\t\t\tthis.m_query.status |= status \u0026 DT_STATUS_DETAIL_MASK\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = next\n\t\t}\n\t}\n\n\tdetails := this.m_query.status \u0026 DT_STATUS_DETAIL_MASK\n\n\t// Reset query.\n\tthis.m_query = dtQueryData{}\n\t*pathCount = n\n\n\treturn DT_SUCCESS | details\n}\n"
                    },
                    "FindDistanceToWall": {
                        "Name": "FindDistanceToWall",
                        "Code": "func (this *DtNavMeshQuery) FindDistanceToWall(startRef DtPolyRef, centerPos []float32, maxRadius float32,\n\tfilter *DtQueryFilter,\n\thitDist *float32, hitPos []float32, hitNormal []float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], centerPos)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tradiusSqr := DtSqrFloat32(maxRadius)\n\n\tstatus := DT_SUCCESS\n\n\tfor !this.m_openList.Empty() {\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(bestRef, \u0026bestTile, \u0026bestPoly)\n\n\t\t// Get parent poly and tile.\n\t\tvar parentRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentRef = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx).Id\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(parentRef, \u0026parentTile, \u0026parentPoly)\n\t\t}\n\t\t// Hit test walls.\n\t\tfor i, j := 0, (int)(bestPoly.VertCount-1); i \u003c (int)(bestPoly.VertCount); j, i = i, i+1 {\n\t\t\t// Skip non-solid edges.\n\t\t\tif (bestPoly.Neis[j] \u0026 DT_EXT_LINK) != 0 {\n\t\t\t\t// Tile border.\n\t\t\t\tsolid := true\n\t\t\t\tfor k := bestPoly.FirstLink; k != DT_NULL_LINK; k = bestTile.Links[k].Next {\n\t\t\t\t\tlink := \u0026bestTile.Links[k]\n\t\t\t\t\tif link.Edge == uint8(j) {\n\t\t\t\t\t\tif link.Ref != 0 {\n\t\t\t\t\t\t\tvar neiTile *DtMeshTile\n\t\t\t\t\t\t\tvar neiPoly *DtPoly\n\t\t\t\t\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(link.Ref, \u0026neiTile, \u0026neiPoly)\n\t\t\t\t\t\t\tif filter.PassFilter(link.Ref, neiTile, neiPoly) {\n\t\t\t\t\t\t\t\tsolid = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !solid {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else if bestPoly.Neis[j] != 0 {\n\t\t\t\t// Internal edge\n\t\t\t\tidx := (uint32)(bestPoly.Neis[j] - 1)\n\t\t\t\tref := this.m_nav.GetPolyRefBase(bestTile) | DtPolyRef(idx)\n\t\t\t\tif filter.PassFilter(ref, bestTile, \u0026bestTile.Polys[idx]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Calc distance to the edge.\n\t\t\tvj := bestTile.Verts[bestPoly.Verts[j]*3:]\n\t\t\tvi := bestTile.Verts[bestPoly.Verts[i]*3:]\n\t\t\tvar tseg float32\n\t\t\tdistSqr := DtDistancePtSegSqr2D(centerPos, vj, vi, \u0026tseg)\n\n\t\t\t// Edge is too far, skip.\n\t\t\tif distSqr \u003e radiusSqr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Hit wall, update radius.\n\t\t\tradiusSqr = distSqr\n\t\t\t// Calculate hit pos.\n\t\t\thitPos[0] = vj[0] + (vi[0]-vj[0])*tseg\n\t\t\thitPos[1] = vj[1] + (vi[1]-vj[1])*tseg\n\t\t\thitPos[2] = vj[2] + (vi[2]-vj[2])*tseg\n\t\t}\n\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tlink := \u0026bestTile.Links[i]\n\t\t\tneighbourRef := link.Ref\n\t\t\t// Skip invalid neighbours and do not follow back to parent.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Expand to neighbour.\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\t// Skip off-mesh connections.\n\t\t\tif neighbourPoly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Calc distance to the edge.\n\t\t\tva := bestTile.Verts[bestPoly.Verts[link.Edge]*3:]\n\t\t\tvb := bestTile.Verts[bestPoly.Verts[(link.Edge+1)%bestPoly.VertCount]*3:]\n\t\t\tvar tseg float32\n\t\t\tdistSqr := DtDistancePtSegSqr2D(centerPos, va, vb, \u0026tseg)\n\n\t\t\t// If the circle is not touching the next polygon, skip it.\n\t\t\tif distSqr \u003e radiusSqr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tstatus |= DT_OUT_OF_NODES\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Cost\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tthis.getEdgeMidPoint2(bestRef, bestPoly, bestTile,\n\t\t\t\t\tneighbourRef, neighbourPoly, neighbourTile, neighbourNode.Pos[:])\n\t\t\t}\n\n\t\t\ttotal := bestNode.Total + DtVdist(bestNode.Pos[:], neighbourNode.Pos[:])\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Flags = (neighbourNode.Flags \u0026 ^DT_NODE_CLOSED)\n\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\tneighbourNode.Total = total\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\tneighbourNode.Flags |= DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calc hit normal.\n\tDtVsub(hitNormal, centerPos, hitPos)\n\tDtVnormalize(hitNormal)\n\n\t*hitDist = DtMathSqrtf(radiusSqr)\n\n\treturn status\n}\n"
                    },
                    "FindLocalNeighbourhood": {
                        "Name": "FindLocalNeighbourhood",
                        "Code": "func (this *DtNavMeshQuery) FindLocalNeighbourhood(startRef DtPolyRef, centerPos []float32, radius float32,\n\tfilter *DtQueryFilter,\n\tresultRef, resultParent []DtPolyRef,\n\tresultCount *int, maxResult int) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_tinyNodePool != nil)\n\n\t*resultCount = 0\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tconst MAX_STACK int = 48\n\tvar stack [MAX_STACK]*DtNode\n\tnstack := 0\n\n\tthis.m_tinyNodePool.Clear()\n\n\tstartNode := this.m_tinyNodePool.GetNode(startRef, 0)\n\tstartNode.Pidx = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_CLOSED\n\tstack[nstack] = startNode\n\tnstack++\n\n\tradiusSqr := DtSqrFloat32(radius)\n\n\tvar pa [DT_VERTS_PER_POLYGON * 3]float32\n\tvar pb [DT_VERTS_PER_POLYGON * 3]float32\n\n\tstatus := DT_SUCCESS\n\n\tn := 0\n\tif n \u003c maxResult {\n\t\tresultRef[n] = startNode.Id\n\t\tif resultParent != nil {\n\t\t\tresultParent[n] = 0\n\t\t}\n\t\tn++\n\t} else {\n\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t}\n\n\tfor nstack != 0 {\n\t\t// Pop front.\n\t\tcurNode := stack[0]\n\t\tfor i := 0; i \u003c nstack-1; i++ {\n\t\t\tstack[i] = stack[i+1]\n\t\t}\n\t\tnstack--\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tcurRef := curNode.Id\n\t\tvar curTile *DtMeshTile\n\t\tvar curPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(curRef, \u0026curTile, \u0026curPoly)\n\n\t\tfor i := curPoly.FirstLink; i != DT_NULL_LINK; i = curTile.Links[i].Next {\n\t\t\tlink := \u0026curTile.Links[i]\n\t\t\tneighbourRef := link.Ref\n\t\t\t// Skip invalid neighbours.\n\t\t\tif neighbourRef == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Skip if cannot alloca more nodes.\n\t\t\tneighbourNode := this.m_tinyNodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Skip visited.\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Expand to neighbour\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\t// Skip off-mesh connections.\n\t\t\tif neighbourPoly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Do not advance if the polygon is excluded by the filter.\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Find edge and calc distance to the edge.\n\t\t\tvar va, vb [3]float32\n\t\t\tif stat := this.getPortalPoints2(curRef, curPoly, curTile, neighbourRef, neighbourPoly, neighbourTile, va[:], vb[:]); DtStatusFailed(stat) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the circle is not touching the next polygon, skip it.\n\t\t\tvar tseg float32\n\t\t\tdistSqr := DtDistancePtSegSqr2D(centerPos, va[:], vb[:], \u0026tseg)\n\t\t\tif distSqr \u003e radiusSqr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Mark node visited, this is done before the overlap test so that\n\t\t\t// we will not visit the poly again if the test fails.\n\t\t\tneighbourNode.Flags |= DT_NODE_CLOSED\n\t\t\tneighbourNode.Pidx = this.m_tinyNodePool.GetNodeIdx(curNode)\n\n\t\t\t// Check that the polygon does not collide with existing polygons.\n\n\t\t\t// Collect vertices of the neighbour poly.\n\t\t\tnpa := int(neighbourPoly.VertCount)\n\t\t\tfor k := 0; k \u003c npa; k++ {\n\t\t\t\tDtVcopy(pa[k*3:], neighbourTile.Verts[neighbourPoly.Verts[k]*3:])\n\t\t\t}\n\t\t\toverlap := false\n\t\t\tfor j := 0; j \u003c n; j++ {\n\t\t\t\tpastRef := resultRef[j]\n\n\t\t\t\t// Connected polys do not overlap.\n\t\t\t\tconnected := false\n\t\t\t\tfor k := curPoly.FirstLink; k != DT_NULL_LINK; k = curTile.Links[k].Next {\n\t\t\t\t\tif curTile.Links[k].Ref == pastRef {\n\t\t\t\t\t\tconnected = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif connected {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Potentially overlapping.\n\t\t\t\tvar pastTile *DtMeshTile\n\t\t\t\tvar pastPoly *DtPoly\n\t\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(pastRef, \u0026pastTile, \u0026pastPoly)\n\n\t\t\t\t// Get vertices and test overlap\n\t\t\t\tnpb := int(pastPoly.VertCount)\n\t\t\t\tfor k := 0; k \u003c npb; k++ {\n\t\t\t\t\tDtVcopy(pb[k*3:], pastTile.Verts[pastPoly.Verts[k]*3:])\n\t\t\t\t}\n\t\t\t\tif DtOverlapPolyPoly2D(pa[:], npa, pb[:], npb) {\n\t\t\t\t\toverlap = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif overlap {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// This poly is fine, store and advance to the poly.\n\t\t\tif n \u003c maxResult {\n\t\t\t\tresultRef[n] = neighbourRef\n\t\t\t\tif resultParent != nil {\n\t\t\t\t\tresultParent[n] = curRef\n\t\t\t\t}\n\t\t\t\tn++\n\t\t\t} else {\n\t\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t\t}\n\n\t\t\tif nstack \u003c MAX_STACK {\n\t\t\t\tstack[nstack] = neighbourNode\n\t\t\t\tnstack++\n\t\t\t}\n\t\t}\n\t}\n\n\t*resultCount = n\n\n\treturn status\n}\n"
                    },
                    "FindNearestPoly": {
                        "Name": "FindNearestPoly",
                        "Code": "func (this *DtNavMeshQuery) FindNearestPoly(center, halfExtents []float32,\n\tfilter *DtQueryFilter,\n\tnearestRef *DtPolyRef, nearestPt []float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\tif nearestRef == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tquery := dtFindNearestPolyQuery{}\n\tquery.constructor(this, center)\n\n\tstatus := this.QueryPolygons2(center, halfExtents, filter, \u0026query)\n\tif DtStatusFailed(status) {\n\t\treturn status\n\t}\n\t*nearestRef = query.nearestRef()\n\t// Only override nearestPt if we actually found a poly so the nearest point\n\t// is valid.\n\tif nearestPt != nil \u0026\u0026 (*nearestRef) != 0 {\n\t\tDtVcopy(nearestPt, query.nearestPoint())\n\t}\n\treturn DT_SUCCESS\n}\n"
                    },
                    "FindPath": {
                        "Name": "FindPath",
                        "Code": "func (this *DtNavMeshQuery) FindPath(startRef, endRef DtPolyRef,\n\tstartPos, endPos []float32,\n\tfilter *DtQueryFilter,\n\tpath []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\tif pathCount != nil {\n\t\t*pathCount = 0\n\t}\n\t// Validate input\n\tif !this.m_nav.IsValidPolyRef(startRef) || !this.m_nav.IsValidPolyRef(endRef) ||\n\t\tstartPos == nil || endPos == nil || filter == nil || maxPath \u003c= 0 || path == nil || pathCount == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif startRef == endRef {\n\t\tpath[0] = startRef\n\t\t*pathCount = 1\n\t\treturn DT_SUCCESS\n\t}\n\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], startPos)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = DtVdist(startPos, endPos) * H_SCALE\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tlastBestNode := startNode\n\tlastBestNodeCost := startNode.Total\n\n\toutOfNodes := false\n\n\tfor !this.m_openList.Empty() {\n\t\t// Remove node from open list and put it in closed list.\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Reached the goal, stop searching.\n\t\tif bestNode.Id == endRef {\n\t\t\tlastBestNode = bestNode\n\t\t\tbreak\n\t\t}\n\n\t\t// Get current poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(bestRef, \u0026bestTile, \u0026bestPoly)\n\n\t\t// Get parent poly and tile.\n\t\tvar parentRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentRef = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx).Id\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(parentRef, \u0026parentTile, \u0026parentPoly)\n\t\t}\n\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tneighbourRef := bestTile.Links[i].Ref\n\n\t\t\t// Skip invalid ids and do not expand back to where we came from.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Get neighbour poly and tile.\n\t\t\t// The API input has been cheked already, skip checking internal data.\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// deal explicitly with crossing tile boundaries\n\t\t\tvar crossSide uint8\n\t\t\tif bestTile.Links[i].Side != 0xff {\n\t\t\t\tcrossSide = (bestTile.Links[i].Side \u003e\u003e 1)\n\t\t\t}\n\t\t\t// get the node\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, crossSide)\n\t\t\tif neighbourNode == nil {\n\t\t\t\toutOfNodes = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// If the node is visited the first time, calculate node position.\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tthis.getEdgeMidPoint2(bestRef, bestPoly, bestTile,\n\t\t\t\t\tneighbourRef, neighbourPoly, neighbourTile,\n\t\t\t\t\tneighbourNode.Pos[:])\n\t\t\t}\n\n\t\t\t// Calculate cost and heuristic.\n\t\t\tvar cost float32\n\t\t\tvar heuristic float32\n\n\t\t\t// Special case for last node.\n\t\t\tif neighbourRef == endRef {\n\t\t\t\t// Cost\n\t\t\t\tcurCost := filter.GetCost(bestNode.Pos[:], neighbourNode.Pos[:],\n\t\t\t\t\tparentRef, parentTile, parentPoly,\n\t\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\t\tneighbourRef, neighbourTile, neighbourPoly)\n\t\t\t\tendCost := filter.GetCost(neighbourNode.Pos[:], endPos,\n\t\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\t\tneighbourRef, neighbourTile, neighbourPoly,\n\t\t\t\t\t0, nil, nil)\n\n\t\t\t\tcost = bestNode.Cost + curCost + endCost\n\t\t\t\theuristic = 0\n\t\t\t} else {\n\t\t\t\t// Cost\n\t\t\t\tcurCost := filter.GetCost(bestNode.Pos[:], neighbourNode.Pos[:],\n\t\t\t\t\tparentRef, parentTile, parentPoly,\n\t\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\t\tneighbourRef, neighbourTile, neighbourPoly)\n\t\t\t\tcost = bestNode.Cost + curCost\n\t\t\t\theuristic = DtVdist(neighbourNode.Pos[:], endPos) * H_SCALE\n\t\t\t}\n\n\t\t\ttotal := cost + heuristic\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// The node is already visited and process, and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_CLOSED) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Add or update the node.\n\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Flags = (neighbourNode.Flags \u0026 ^DT_NODE_CLOSED)\n\t\t\tneighbourNode.Cost = cost\n\t\t\tneighbourNode.Total = total\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\t// Already in open, update node location.\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\t// Put the node in open list.\n\t\t\t\tneighbourNode.Flags |= DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\n\t\t\t// Update nearest node to target so far.\n\t\t\tif heuristic \u003c lastBestNodeCost {\n\t\t\t\tlastBestNodeCost = heuristic\n\t\t\t\tlastBestNode = neighbourNode\n\t\t\t}\n\t\t}\n\t}\n\n\tstatus := this.getPathToNode(lastBestNode, path, pathCount, maxPath)\n\n\tif lastBestNode.Id != endRef {\n\t\tstatus |= DT_PARTIAL_RESULT\n\t}\n\tif outOfNodes {\n\t\tstatus |= DT_OUT_OF_NODES\n\t}\n\treturn status\n}\n"
                    },
                    "FindPolysAroundCircle": {
                        "Name": "FindPolysAroundCircle",
                        "Code": "func (this *DtNavMeshQuery) FindPolysAroundCircle(startRef DtPolyRef, centerPos []float32, radius float32,\n\tfilter *DtQueryFilter,\n\tresultRef, resultParent []DtPolyRef, resultCost []float32,\n\tresultCount *int, maxResult int) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\t*resultCount = 0\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], centerPos)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tstatus := DT_SUCCESS\n\n\tn := 0\n\n\tradiusSqr := DtSqrFloat32(radius)\n\n\tfor !this.m_openList.Empty() {\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(bestRef, \u0026bestTile, \u0026bestPoly)\n\n\t\t// Get parent poly and tile.\n\t\tvar parentRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentRef = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx).Id\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(parentRef, \u0026parentTile, \u0026parentPoly)\n\t\t}\n\t\tif n \u003c maxResult {\n\t\t\tif resultRef != nil {\n\t\t\t\tresultRef[n] = bestRef\n\t\t\t}\n\t\t\tif resultParent != nil {\n\t\t\t\tresultParent[n] = parentRef\n\t\t\t}\n\t\t\tif resultCost != nil {\n\t\t\t\tresultCost[n] = bestNode.Total\n\t\t\t}\n\t\t\tn++\n\t\t} else {\n\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t}\n\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tlink := \u0026bestTile.Links[i]\n\t\t\tneighbourRef := link.Ref\n\t\t\t// Skip invalid neighbours and do not follow back to parent.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Expand to neighbour\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\t// Do not advance if the polygon is excluded by the filter.\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Find edge and calc distance to the edge.\n\t\t\tvar va, vb [3]float32\n\t\t\tif stat := this.getPortalPoints2(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va[:], vb[:]); DtStatusFailed(stat) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the circle is not touching the next polygon, skip it.\n\t\t\tvar tseg float32\n\t\t\tdistSqr := DtDistancePtSegSqr2D(centerPos, va[:], vb[:], \u0026tseg)\n\t\t\tif distSqr \u003e radiusSqr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tstatus |= DT_OUT_OF_NODES\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Cost\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tDtVlerp(neighbourNode.Pos[:], va[:], vb[:], 0.5)\n\t\t\t}\n\t\t\tcost := filter.GetCost(\n\t\t\t\tbestNode.Pos[:], neighbourNode.Pos[:],\n\t\t\t\tparentRef, parentTile, parentPoly,\n\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\tneighbourRef, neighbourTile, neighbourPoly)\n\n\t\t\ttotal := bestNode.Total + cost\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\tneighbourNode.Total = total\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\tneighbourNode.Flags = DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\t\t}\n\t}\n\n\t*resultCount = n\n\n\treturn status\n}\n"
                    },
                    "FindPolysAroundShape": {
                        "Name": "FindPolysAroundShape",
                        "Code": "func (this *DtNavMeshQuery) FindPolysAroundShape(startRef DtPolyRef, verts []float32, nverts int,\n\tfilter *DtQueryFilter,\n\tresultRef, resultParent []DtPolyRef, resultCost []float32,\n\tresultCount *int, maxResult int) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\t*resultCount = 0\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tvar centerPos [3]float32\n\tfor i := 0; i \u003c nverts; i++ {\n\t\tDtVadd(centerPos[:], centerPos[:], verts[i*3:])\n\t}\n\tDtVscale(centerPos[:], centerPos[:], 1.0/float32(nverts))\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], centerPos[:])\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tstatus := DT_SUCCESS\n\n\tn := 0\n\n\tfor !this.m_openList.Empty() {\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(bestRef, \u0026bestTile, \u0026bestPoly)\n\n\t\t// Get parent poly and tile.\n\t\tvar parentRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentRef = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx).Id\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(parentRef, \u0026parentTile, \u0026parentPoly)\n\t\t}\n\t\tif n \u003c maxResult {\n\t\t\tif resultRef != nil {\n\t\t\t\tresultRef[n] = bestRef\n\t\t\t}\n\t\t\tif resultParent != nil {\n\t\t\t\tresultParent[n] = parentRef\n\t\t\t}\n\t\t\tif resultCost != nil {\n\t\t\t\tresultCost[n] = bestNode.Total\n\t\t\t}\n\n\t\t\tn++\n\t\t} else {\n\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t}\n\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tlink := \u0026bestTile.Links[i]\n\t\t\tneighbourRef := link.Ref\n\t\t\t// Skip invalid neighbours and do not follow back to parent.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Expand to neighbour\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\t// Do not advance if the polygon is excluded by the filter.\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Find edge and calc distance to the edge.\n\t\t\tvar va, vb [3]float32\n\t\t\tif stat := this.getPortalPoints2(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va[:], vb[:]); DtStatusFailed(stat) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the poly is not touching the edge to the next polygon, skip the connection it.\n\t\t\tvar tmin, tmax float32\n\t\t\tvar segMin, segMax int\n\t\t\tif !DtIntersectSegmentPoly2D(va[:], vb[:], verts, nverts, \u0026tmin, \u0026tmax, \u0026segMin, \u0026segMax) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif tmin \u003e 1.0 || tmax \u003c 0.0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tstatus |= DT_OUT_OF_NODES\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Cost\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tDtVlerp(neighbourNode.Pos[:], va[:], vb[:], 0.5)\n\t\t\t}\n\t\t\tcost := filter.GetCost(\n\t\t\t\tbestNode.Pos[:], neighbourNode.Pos[:],\n\t\t\t\tparentRef, parentTile, parentPoly,\n\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\tneighbourRef, neighbourTile, neighbourPoly)\n\n\t\t\ttotal := bestNode.Total + cost\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\tneighbourNode.Total = total\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\tneighbourNode.Flags = DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\t\t}\n\t}\n\n\t*resultCount = n\n\n\treturn status\n}\n"
                    },
                    "FindRandomPoint": {
                        "Name": "FindRandomPoint",
                        "Code": "func (this *DtNavMeshQuery) FindRandomPoint(filter *DtQueryFilter, frand func() float32,\n\trandomRef *DtPolyRef, randomPt []float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\t// Randomly pick one tile. Assume that all tiles cover roughly the same area.\n\tvar tile *DtMeshTile\n\tvar tsum float32\n\tfor i := 0; i \u003c int(this.m_nav.GetMaxTiles()); i++ {\n\t\tt := this.m_nav.GetTile(i)\n\t\tif t == nil || t.Header == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Choose random tile using reservoi sampling.\n\t\tconst area float32 = 1.0 // Could be tile area too.\n\t\ttsum += area\n\t\tu := frand()\n\t\tif u*tsum \u003c= area {\n\t\t\ttile = t\n\t\t}\n\t}\n\tif tile == nil {\n\t\treturn DT_FAILURE\n\t}\n\t// Randomly pick one polygon weighted by polygon area.\n\tvar poly *DtPoly\n\tvar polyRef DtPolyRef\n\tbase := this.m_nav.GetPolyRefBase(tile)\n\n\tvar areaSum float32\n\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\tp := \u0026tile.Polys[i]\n\t\t// Do not return off-mesh connection polygons.\n\t\tif p.GetType() != DT_POLYTYPE_GROUND {\n\t\t\tcontinue\n\t\t}\n\t\t// Must pass filter\n\t\tref := base | (DtPolyRef)(i)\n\t\tif !filter.PassFilter(ref, tile, p) {\n\t\t\tcontinue\n\t\t}\n\t\t// Calc area of the polygon.\n\t\tvar polyArea float32\n\t\tfor j := 2; j \u003c int(p.VertCount); j++ {\n\t\t\tva := tile.Verts[p.Verts[0]*3:]\n\t\t\tvb := tile.Verts[p.Verts[j-1]*3:]\n\t\t\tvc := tile.Verts[p.Verts[j]*3:]\n\t\t\tpolyArea += DtTriArea2D(va, vb, vc)\n\t\t}\n\n\t\t// Choose random polygon weighted by area, using reservoi sampling.\n\t\tareaSum += polyArea\n\t\tu := frand()\n\t\tif u*areaSum \u003c= polyArea {\n\t\t\tpoly = p\n\t\t\tpolyRef = ref\n\t\t}\n\t}\n\n\tif poly == nil {\n\t\treturn DT_FAILURE\n\t}\n\t// Randomly pick point on polygon.\n\tv := tile.Verts[poly.Verts[0]*3:]\n\tvar verts [3 * DT_VERTS_PER_POLYGON]float32\n\tvar areas [DT_VERTS_PER_POLYGON]float32\n\tDtVcopy(verts[0*3:], v)\n\tfor j := 1; j \u003c int(poly.VertCount); j++ {\n\t\tv = tile.Verts[poly.Verts[j]*3:]\n\t\tDtVcopy(verts[j*3:], v)\n\t}\n\n\ts := frand()\n\tt := frand()\n\n\tvar pt [3]float32\n\tDtRandomPointInConvexPoly(verts[:], int(poly.VertCount), areas[:], s, t, pt[:])\n\n\tvar h float32\n\tstatus := this.GetPolyHeight(polyRef, pt[:], \u0026h)\n\tif DtStatusFailed(status) {\n\t\treturn status\n\t}\n\tpt[1] = h\n\n\tDtVcopy(randomPt, pt[:])\n\t*randomRef = polyRef\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "FindRandomPointAroundCircle": {
                        "Name": "FindRandomPointAroundCircle",
                        "Code": "func (this *DtNavMeshQuery) FindRandomPointAroundCircle(startRef DtPolyRef, centerPos []float32, maxRadius float32,\n\tfilter *DtQueryFilter, frand func() float32,\n\trandomRef *DtPolyRef, randomPt []float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tvar startTile *DtMeshTile\n\tvar startPoly *DtPoly\n\tthis.m_nav.GetTileAndPolyByRefUnsafe(startRef, \u0026startTile, \u0026startPoly)\n\tif !filter.PassFilter(startRef, startTile, startPoly) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], centerPos)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tstatus := DT_SUCCESS\n\n\tradiusSqr := DtSqrFloat32(maxRadius)\n\tvar areaSum float32\n\n\tvar randomTile *DtMeshTile\n\tvar randomPoly *DtPoly\n\tvar randomPolyRef DtPolyRef\n\n\tfor !this.m_openList.Empty() {\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(bestRef, \u0026bestTile, \u0026bestPoly)\n\n\t\t// Place random locations on on ground.\n\t\tif bestPoly.GetType() == DT_POLYTYPE_GROUND {\n\t\t\t// Calc area of the polygon.\n\t\t\tvar polyArea float32\n\t\t\tfor j := 2; j \u003c int(bestPoly.VertCount); j++ {\n\t\t\t\tva := bestTile.Verts[bestPoly.Verts[0]*3:]\n\t\t\t\tvb := bestTile.Verts[bestPoly.Verts[j-1]*3:]\n\t\t\t\tvc := bestTile.Verts[bestPoly.Verts[j]*3:]\n\t\t\t\tpolyArea += DtTriArea2D(va, vb, vc)\n\t\t\t}\n\t\t\t// Choose random polygon weighted by area, using reservoi sampling.\n\t\t\tareaSum += polyArea\n\t\t\tu := frand()\n\t\t\tif u*areaSum \u003c= polyArea {\n\t\t\t\trandomTile = bestTile\n\t\t\t\trandomPoly = bestPoly\n\t\t\t\trandomPolyRef = bestRef\n\t\t\t}\n\t\t}\n\n\t\t// Get parent poly and tile.\n\t\tvar parentRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentRef = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx).Id\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(parentRef, \u0026parentTile, \u0026parentPoly)\n\t\t}\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tlink := \u0026bestTile.Links[i]\n\t\t\tneighbourRef := link.Ref\n\t\t\t// Skip invalid neighbours and do not follow back to parent.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Expand to neighbour\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\t// Do not advance if the polygon is excluded by the filter.\n\t\t\tif !filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Find edge and calc distance to the edge.\n\t\t\tvar va, vb [3]float32\n\t\t\tif stat := this.getPortalPoints2(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va[:], vb[:]); DtStatusFailed(stat) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the circle is not touching the next polygon, skip it.\n\t\t\tvar tseg float32\n\t\t\tdistSqr := DtDistancePtSegSqr2D(centerPos, va[:], vb[:], \u0026tseg)\n\t\t\tif distSqr \u003e radiusSqr {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tstatus |= DT_OUT_OF_NODES\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Cost\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tDtVlerp(neighbourNode.Pos[:], va[:], vb[:], 0.5)\n\t\t\t}\n\t\t\ttotal := bestNode.Total + DtVdist(bestNode.Pos[:], neighbourNode.Pos[:])\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Flags = neighbourNode.Flags \u0026 ^DT_NODE_CLOSED\n\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\tneighbourNode.Total = total\n\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\tneighbourNode.Flags = DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\t\t}\n\t}\n\n\tif randomPoly == nil {\n\t\treturn DT_FAILURE\n\t}\n\t// Randomly pick point on polygon.\n\tv := randomTile.Verts[randomPoly.Verts[0]*3:]\n\tvar verts [3 * DT_VERTS_PER_POLYGON]float32\n\tvar areas [DT_VERTS_PER_POLYGON]float32\n\tDtVcopy(verts[0*3:], v[:])\n\tfor j := 1; j \u003c int(randomPoly.VertCount); j++ {\n\t\tv = randomTile.Verts[randomPoly.Verts[j]*3:]\n\t\tDtVcopy(verts[j*3:], v[:])\n\t}\n\n\ts := frand()\n\tt := frand()\n\n\tvar pt [3]float32\n\tDtRandomPointInConvexPoly(verts[:], int(randomPoly.VertCount), areas[:], s, t, pt[:])\n\n\tvar h float32\n\tstat := this.GetPolyHeight(randomPolyRef, pt[:], \u0026h)\n\tif DtStatusFailed(status) {\n\t\treturn stat\n\t}\n\tpt[1] = h\n\n\tDtVcopy(randomPt, pt[:])\n\t*randomRef = randomPolyRef\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "FindStraightPath": {
                        "Name": "FindStraightPath",
                        "Code": "func (this *DtNavMeshQuery) FindStraightPath(startPos, endPos []float32,\n\tpath []DtPolyRef, pathSize int,\n\tstraightPath []float32, straightPathFlags []DtStraightPathFlags, straightPathRefs []DtPolyRef,\n\tstraightPathCount *int, maxStraightPath int, options DtStraightPathOptions) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\t*straightPathCount = 0\n\n\tif maxStraightPath == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif path[0] == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tvar stat DtStatus\n\n\t// TODO: Should this be callers responsibility?\n\tvar closestStartPos [3]float32\n\tif DtStatusFailed(this.ClosestPointOnPolyBoundary(path[0], startPos, closestStartPos[:])) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tvar closestEndPos [3]float32\n\tif DtStatusFailed(this.ClosestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos[:])) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// Add start point.\n\tstat = this.appendVertex(closestStartPos[:], DT_STRAIGHTPATH_START, path[0],\n\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\tstraightPathCount, maxStraightPath)\n\tif stat != DT_IN_PROGRESS {\n\t\treturn stat\n\t}\n\tif pathSize \u003e 1 {\n\t\tvar portalApex, portalLeft, portalRight [3]float32\n\t\tDtVcopy(portalApex[:], closestStartPos[:])\n\t\tDtVcopy(portalLeft[:], portalApex[:])\n\t\tDtVcopy(portalRight[:], portalApex[:])\n\t\tvar apexIndex int\n\t\tvar leftIndex int\n\t\tvar rightIndex int\n\n\t\tvar leftPolyType DtPolyTypes\n\t\tvar rightPolyType DtPolyTypes\n\n\t\tleftPolyRef := path[0]\n\t\trightPolyRef := path[0]\n\n\t\tfor i := 0; i \u003c pathSize; i++ {\n\t\t\tvar left, right [3]float32\n\t\t\tvar toType DtPolyTypes\n\n\t\t\tif i+1 \u003c pathSize {\n\t\t\t\tvar fromType DtPolyTypes // fromType is ignored.\n\n\t\t\t\t// Next portal.\n\t\t\t\tif DtStatusFailed(this.getPortalPoints(path[i], path[i+1], left[:], right[:], \u0026fromType, \u0026toType)) {\n\t\t\t\t\t// Failed to get portal points, in practice this means that path[i+1] is invalid polygon.\n\t\t\t\t\t// Clamp the end point to path[i], and return the path so far.\n\n\t\t\t\t\tif DtStatusFailed(this.ClosestPointOnPolyBoundary(path[i], endPos, closestEndPos[:])) {\n\t\t\t\t\t\t// This should only happen when the first polygon is invalid.\n\t\t\t\t\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apeend portals along the current straight path segment.\n\t\t\t\t\tif (options \u0026 (DT_STRAIGHTPATH_AREA_CROSSINGS | DT_STRAIGHTPATH_ALL_CROSSINGS)) != 0 {\n\t\t\t\t\t\t// Ignore status return value as we're just about to return anyway.\n\t\t\t\t\t\tthis.appendPortals(apexIndex, i, closestEndPos[:], path,\n\t\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\t\tstraightPathCount, maxStraightPath, options)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Ignore status return value as we're just about to return anyway.\n\t\t\t\t\tthis.appendVertex(closestEndPos[:], 0, path[i],\n\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\tstraightPathCount, maxStraightPath)\n\n\t\t\t\t\tif *straightPathCount \u003e= maxStraightPath {\n\t\t\t\t\t\treturn DT_SUCCESS | DT_PARTIAL_RESULT | DT_BUFFER_TOO_SMALL\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn DT_SUCCESS | DT_PARTIAL_RESULT\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If starting really close the portal, advance.\n\t\t\t\tif i == 0 {\n\t\t\t\t\tvar t float32\n\t\t\t\t\tif DtDistancePtSegSqr2D(portalApex[:], left[:], right[:], \u0026t) \u003c DtSqrFloat32(0.001) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// End of the path.\n\t\t\t\tDtVcopy(left[:], closestEndPos[:])\n\t\t\t\tDtVcopy(right[:], closestEndPos[:])\n\n\t\t\t\ttoType = DT_POLYTYPE_GROUND\n\t\t\t}\n\n\t\t\t// Right vertex.\n\t\t\tif DtTriArea2D(portalApex[:], portalRight[:], right[:]) \u003c= 0.0 {\n\t\t\t\tif DtVequal(portalApex[:], portalRight[:]) || DtTriArea2D(portalApex[:], portalLeft[:], right[:]) \u003e 0.0 {\n\t\t\t\t\tDtVcopy(portalRight[:], right[:])\n\t\t\t\t\tif i+1 \u003c pathSize {\n\t\t\t\t\t\trightPolyRef = path[i+1]\n\t\t\t\t\t} else {\n\t\t\t\t\t\trightPolyRef = 0\n\t\t\t\t\t}\n\t\t\t\t\trightPolyType = toType\n\t\t\t\t\trightIndex = i\n\t\t\t\t} else {\n\t\t\t\t\t// Append portals along the current straight path segment.\n\t\t\t\t\tif (options \u0026 (DT_STRAIGHTPATH_AREA_CROSSINGS | DT_STRAIGHTPATH_ALL_CROSSINGS)) != 0 {\n\t\t\t\t\t\tstat = this.appendPortals(apexIndex, leftIndex, portalLeft[:], path,\n\t\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\t\tstraightPathCount, maxStraightPath, options)\n\t\t\t\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\t\t\t\treturn stat\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tDtVcopy(portalApex[:], portalLeft[:])\n\t\t\t\t\tapexIndex = leftIndex\n\n\t\t\t\t\tvar flags DtStraightPathFlags\n\t\t\t\t\tif leftPolyRef == 0 {\n\t\t\t\t\t\tflags = DT_STRAIGHTPATH_END\n\t\t\t\t\t} else if leftPolyType == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\t\t\tflags = DT_STRAIGHTPATH_OFFMESH_CONNECTION\n\t\t\t\t\t}\n\t\t\t\t\tref := leftPolyRef\n\n\t\t\t\t\t// Append or update vertex\n\t\t\t\t\tstat = this.appendVertex(portalApex[:], flags, ref,\n\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\tstraightPathCount, maxStraightPath)\n\t\t\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\t\t\treturn stat\n\t\t\t\t\t}\n\t\t\t\t\tDtVcopy(portalLeft[:], portalApex[:])\n\t\t\t\t\tDtVcopy(portalRight[:], portalApex[:])\n\t\t\t\t\tleftIndex = apexIndex\n\t\t\t\t\trightIndex = apexIndex\n\n\t\t\t\t\t// Restart\n\t\t\t\t\ti = apexIndex\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Left vertex.\n\t\t\tif DtTriArea2D(portalApex[:], portalLeft[:], left[:]) \u003e= 0.0 {\n\t\t\t\tif DtVequal(portalApex[:], portalLeft[:]) || DtTriArea2D(portalApex[:], portalRight[:], left[:]) \u003c 0.0 {\n\t\t\t\t\tDtVcopy(portalLeft[:], left[:])\n\t\t\t\t\tif i+1 \u003c pathSize {\n\t\t\t\t\t\tleftPolyRef = path[i+1]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tleftPolyRef = 0\n\t\t\t\t\t}\n\t\t\t\t\tleftPolyType = toType\n\t\t\t\t\tleftIndex = i\n\t\t\t\t} else {\n\t\t\t\t\t// Append portals along the current straight path segment.\n\t\t\t\t\tif (options \u0026 (DT_STRAIGHTPATH_AREA_CROSSINGS | DT_STRAIGHTPATH_ALL_CROSSINGS)) != 0 {\n\t\t\t\t\t\tstat = this.appendPortals(apexIndex, rightIndex, portalRight[:], path,\n\t\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\t\tstraightPathCount, maxStraightPath, options)\n\t\t\t\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\t\t\t\treturn stat\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tDtVcopy(portalApex[:], portalRight[:])\n\t\t\t\t\tapexIndex = rightIndex\n\n\t\t\t\t\tvar flags DtStraightPathFlags\n\t\t\t\t\tif rightPolyRef == 0 {\n\t\t\t\t\t\tflags = DT_STRAIGHTPATH_END\n\t\t\t\t\t} else if rightPolyType == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\t\t\tflags = DT_STRAIGHTPATH_OFFMESH_CONNECTION\n\t\t\t\t\t}\n\t\t\t\t\tref := rightPolyRef\n\n\t\t\t\t\t// Append or update vertex\n\t\t\t\t\tstat = this.appendVertex(portalApex[:], flags, ref,\n\t\t\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\t\t\tstraightPathCount, maxStraightPath)\n\t\t\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\t\t\treturn stat\n\t\t\t\t\t}\n\t\t\t\t\tDtVcopy(portalLeft[:], portalApex[:])\n\t\t\t\t\tDtVcopy(portalRight[:], portalApex[:])\n\t\t\t\t\tleftIndex = apexIndex\n\t\t\t\t\trightIndex = apexIndex\n\n\t\t\t\t\t// Restart\n\t\t\t\t\ti = apexIndex\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Append portals along the current straight path segment.\n\t\tif (options \u0026 (DT_STRAIGHTPATH_AREA_CROSSINGS | DT_STRAIGHTPATH_ALL_CROSSINGS)) != 0 {\n\t\t\tstat = this.appendPortals(apexIndex, pathSize-1, closestEndPos[:], path,\n\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\tstraightPathCount, maxStraightPath, options)\n\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\n\t// Ignore status return value as we're just about to return anyway.\n\tthis.appendVertex(closestEndPos[:], DT_STRAIGHTPATH_END, 0,\n\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\tstraightPathCount, maxStraightPath)\n\n\tif *straightPathCount \u003e= maxStraightPath {\n\t\treturn DT_SUCCESS | DT_BUFFER_TOO_SMALL\n\t} else {\n\t\treturn DT_SUCCESS\n\t}\n}\n"
                    },
                    "GetAttachedNavMesh": {
                        "Name": "GetAttachedNavMesh",
                        "Code": "func (this *DtNavMeshQuery) GetAttachedNavMesh() *DtNavMesh { return this.m_nav }\n"
                    },
                    "GetNodePool": {
                        "Name": "GetNodePool",
                        "Code": "func (this *DtNavMeshQuery) GetNodePool() *DtNodePool { return this.m_nodePool }\n"
                    },
                    "GetPathFromDijkstraSearch": {
                        "Name": "GetPathFromDijkstraSearch",
                        "Code": "func (this *DtNavMeshQuery) GetPathFromDijkstraSearch(endRef DtPolyRef, path []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\tif !this.m_nav.IsValidPolyRef(endRef) || path == nil || pathCount == nil || maxPath \u003c 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t*pathCount = 0\n\n\tvar endNode [1]*DtNode\n\tif this.m_nodePool.FindNodes(endRef, endNode[:], 1) != 1 ||\n\t\t(endNode[0].Flags\u0026DT_NODE_CLOSED) == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\treturn this.getPathToNode(endNode[0], path, pathCount, maxPath)\n}\n"
                    },
                    "GetPolyHeight": {
                        "Name": "GetPolyHeight",
                        "Code": "func (this *DtNavMeshQuery) GetPolyHeight(ref DtPolyRef, pos []float32, height *float32) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\tvar tile *DtMeshTile\n\tvar poly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(ref, \u0026tile, \u0026poly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif poly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\tv0 := tile.Verts[poly.Verts[0]*3:]\n\t\tv1 := tile.Verts[poly.Verts[1]*3:]\n\t\td0 := DtVdist2D(pos, v0)\n\t\td1 := DtVdist2D(pos, v1)\n\t\tu := d0 / (d0 + d1)\n\t\tif height != nil {\n\t\t\t*height = v0[1] + (v1[1]-v0[1])*u\n\t\t}\n\t\treturn DT_SUCCESS\n\t} else {\n\t\tpolyBase := uintptr(unsafe.Pointer(\u0026(tile.Polys[0])))\n\t\tcurrent := uintptr(unsafe.Pointer(poly))\n\t\tip := (uint32)(current-polyBase) / sizeofPoly\n\t\tpd := \u0026tile.DetailMeshes[ip]\n\t\tfor j := 0; j \u003c int(pd.TriCount); j++ {\n\t\t\tt := tile.DetailTris[(int(pd.TriBase)+j)*4:]\n\t\t\tvar v [3][]float32\n\t\t\tfor k := 0; k \u003c 3; k++ {\n\t\t\t\tif t[k] \u003c poly.VertCount {\n\t\t\t\t\tv[k] = tile.Verts[poly.Verts[t[k]]*3:]\n\t\t\t\t} else {\n\t\t\t\t\tv[k] = tile.DetailVerts[(pd.VertBase+uint32(t[k]-poly.VertCount))*3:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar h float32\n\t\t\tif DtClosestHeightPointTriangle(pos, v[0], v[1], v[2], \u0026h) {\n\t\t\t\tif height != nil {\n\t\t\t\t\t*height = h\n\t\t\t\t}\n\t\t\t\treturn DT_SUCCESS\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DT_FAILURE | DT_INVALID_PARAM\n}\n"
                    },
                    "GetPolyWallSegments": {
                        "Name": "GetPolyWallSegments",
                        "Code": "func (this *DtNavMeshQuery) GetPolyWallSegments(ref DtPolyRef, filter *DtQueryFilter,\n\tsegmentVerts []float32, segmentRefs []DtPolyRef, segmentCount *int,\n\tmaxSegments int) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\t*segmentCount = 0\n\n\tvar tile *DtMeshTile\n\tvar poly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(ref, \u0026tile, \u0026poly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tn := 0\n\tconst MAX_INTERVAL int = 16\n\tvar ints [MAX_INTERVAL]dtSegInterval\n\tvar nints int\n\n\tstorePortals := (segmentRefs != nil)\n\n\tstatus := DT_SUCCESS\n\n\tfor i, j := 0, (int)(poly.VertCount-1); i \u003c (int)(poly.VertCount); j, i = i, i+1 {\n\t\t// Skip non-solid edges.\n\t\tnints = 0\n\t\tif (poly.Neis[j] \u0026 DT_EXT_LINK) != 0 {\n\t\t\t// Tile border.\n\t\t\tfor k := poly.FirstLink; k != DT_NULL_LINK; k = tile.Links[k].Next {\n\t\t\t\tlink := \u0026tile.Links[k]\n\t\t\t\tif link.Edge == uint8(j) {\n\t\t\t\t\tif link.Ref != 0 {\n\t\t\t\t\t\tvar neiTile *DtMeshTile\n\t\t\t\t\t\tvar neiPoly *DtPoly\n\t\t\t\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(link.Ref, \u0026neiTile, \u0026neiPoly)\n\t\t\t\t\t\tif filter.PassFilter(link.Ref, neiTile, neiPoly) {\n\t\t\t\t\t\t\tinsertInterval(ints[:], \u0026nints, MAX_INTERVAL, int16(link.Bmin), int16(link.Bmax), link.Ref)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Internal edge\n\t\t\tvar neiRef DtPolyRef\n\t\t\tif poly.Neis[j] != 0 {\n\t\t\t\tidx := (uint32)(poly.Neis[j] - 1)\n\t\t\t\tneiRef = this.m_nav.GetPolyRefBase(tile) | DtPolyRef(idx)\n\t\t\t\tif !filter.PassFilter(neiRef, tile, \u0026tile.Polys[idx]) {\n\t\t\t\t\tneiRef = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the edge leads to another polygon and portals are not stored, skip.\n\t\t\tif neiRef != 0 \u0026\u0026 !storePortals {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif n \u003c maxSegments {\n\t\t\t\tvj := tile.Verts[poly.Verts[j]*3:]\n\t\t\t\tvi := tile.Verts[poly.Verts[i]*3:]\n\t\t\t\tseg := segmentVerts[n*6:]\n\t\t\t\tDtVcopy(seg[0:], vj)\n\t\t\t\tDtVcopy(seg[3:], vi)\n\t\t\t\tif segmentRefs != nil {\n\t\t\t\t\tsegmentRefs[n] = neiRef\n\t\t\t\t}\n\t\t\t\tn++\n\t\t\t} else {\n\t\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add sentinels\n\t\tinsertInterval(ints[:], \u0026nints, MAX_INTERVAL, -1, 0, 0)\n\t\tinsertInterval(ints[:], \u0026nints, MAX_INTERVAL, 255, 256, 0)\n\n\t\t// Store segments.\n\t\tvj := tile.Verts[poly.Verts[j]*3:]\n\t\tvi := tile.Verts[poly.Verts[i]*3:]\n\t\tfor k := 1; k \u003c nints; k++ {\n\t\t\t// Portal segment.\n\t\t\tif storePortals \u0026\u0026 ints[k].ref != 0 {\n\t\t\t\ttmin := ints[k].tmin / 255.0\n\t\t\t\ttmax := ints[k].tmax / 255.0\n\t\t\t\tif n \u003c maxSegments {\n\t\t\t\t\tseg := segmentVerts[n*6:]\n\t\t\t\t\tDtVlerp(seg[0:], vj, vi, float32(tmin))\n\t\t\t\t\tDtVlerp(seg[3:], vj, vi, float32(tmax))\n\t\t\t\t\tif segmentRefs != nil {\n\t\t\t\t\t\tsegmentRefs[n] = ints[k].ref\n\t\t\t\t\t}\n\t\t\t\t\tn++\n\t\t\t\t} else {\n\t\t\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Wall segment.\n\t\t\timin := ints[k-1].tmax\n\t\t\timax := ints[k].tmin\n\t\t\tif imin != imax {\n\t\t\t\ttmin := imin / 255.0\n\t\t\t\ttmax := imax / 255.0\n\t\t\t\tif n \u003c maxSegments {\n\t\t\t\t\tseg := segmentVerts[n*6:]\n\t\t\t\t\tDtVlerp(seg[0:], vj, vi, float32(tmin))\n\t\t\t\t\tDtVlerp(seg[3:], vj, vi, float32(tmax))\n\t\t\t\t\tif segmentRefs != nil {\n\t\t\t\t\t\tsegmentRefs[n] = 0\n\t\t\t\t\t}\n\t\t\t\t\tn++\n\t\t\t\t} else {\n\t\t\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*segmentCount = n\n\n\treturn status\n}\n"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtNavMeshQuery) Init(nav *DtNavMesh, maxNodes int) DtStatus {\n\tif maxNodes \u003e int(DT_NULL_IDX) || maxNodes \u003e int((1\u003c\u003cDT_NODE_PARENT_BITS)-1) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tthis.m_nav = nav\n\n\tif this.m_nodePool == nil || this.m_nodePool.GetMaxNodes() \u003c uint32(maxNodes) {\n\t\tif this.m_nodePool != nil {\n\t\t\tDtFreeNodePool(this.m_nodePool)\n\t\t\tthis.m_nodePool = nil\n\t\t}\n\t\tthis.m_nodePool = DtAllocNodePool(uint32(maxNodes), DtNextPow2(uint32(maxNodes/4)))\n\t\tif this.m_nodePool == nil {\n\t\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t\t}\n\t} else {\n\t\tthis.m_nodePool.Clear()\n\t}\n\n\tif this.m_tinyNodePool == nil {\n\t\tthis.m_tinyNodePool = DtAllocNodePool(64, 32)\n\t\tif this.m_tinyNodePool == nil {\n\t\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t\t}\n\t} else {\n\t\tthis.m_tinyNodePool.Clear()\n\t}\n\n\tif this.m_openList == nil || this.m_openList.GetCapacity() \u003c maxNodes {\n\t\tif this.m_openList != nil {\n\t\t\tDtFreeNodeQueue(this.m_openList)\n\t\t\tthis.m_openList = nil\n\t\t}\n\t\tthis.m_openList = DtAllocNodeQueue(maxNodes)\n\t\tif this.m_openList == nil {\n\t\t\treturn DT_FAILURE | DT_OUT_OF_MEMORY\n\t\t}\n\t} else {\n\t\tthis.m_openList.Clear()\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "InitSlicedFindPath": {
                        "Name": "InitSlicedFindPath",
                        "Code": "func (this *DtNavMeshQuery) InitSlicedFindPath(startRef, endRef DtPolyRef,\n\tstartPos, endPos []float32,\n\tfilter *DtQueryFilter, options DtFindPathOptions) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_nodePool != nil)\n\tDtAssert(this.m_openList != nil)\n\n\t// Init path state.\n\tthis.m_query = dtQueryData{}\n\tthis.m_query.status = DT_FAILURE\n\tthis.m_query.startRef = startRef\n\tthis.m_query.endRef = endRef\n\tDtVcopy(this.m_query.startPos[:], startPos)\n\tDtVcopy(this.m_query.endPos[:], endPos)\n\tthis.m_query.filter = filter\n\tthis.m_query.options = options\n\tthis.m_query.raycastLimitSqr = float32(math.MaxFloat32)\n\n\tif startRef == 0 || endRef == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// Validate input\n\tif !this.m_nav.IsValidPolyRef(startRef) || !this.m_nav.IsValidPolyRef(endRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// trade quality with performance?\n\tif (options \u0026 DT_FINDPATH_ANY_ANGLE) != 0 {\n\t\t// limiting to several times the character radius yields nice results. It is not sensitive\n\t\t// so it is enough to compute it from the first tile.\n\t\ttile := this.m_nav.GetTileByRef(DtTileRef(startRef))\n\t\tagentRadius := tile.Header.WalkableRadius\n\t\tthis.m_query.raycastLimitSqr = DtSqrFloat32(agentRadius * DT_RAY_CAST_LIMIT_PROPORTIONS)\n\t}\n\n\tif startRef == endRef {\n\t\tthis.m_query.status = DT_SUCCESS\n\t\treturn DT_SUCCESS\n\t}\n\n\tthis.m_nodePool.Clear()\n\tthis.m_openList.Clear()\n\n\tstartNode := this.m_nodePool.GetNode(startRef, 0)\n\tDtVcopy(startNode.Pos[:], startPos)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = DtVdist(startPos, endPos) * H_SCALE\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_OPEN\n\tthis.m_openList.Push(startNode)\n\n\tthis.m_query.status = DT_IN_PROGRESS\n\tthis.m_query.lastBestNode = startNode\n\tthis.m_query.lastBestNodeCost = startNode.Total\n\n\treturn this.m_query.status\n}\n"
                    },
                    "IsInClosedList": {
                        "Name": "IsInClosedList",
                        "Code": "func (this *DtNavMeshQuery) IsInClosedList(ref DtPolyRef) bool {\n\tif this.m_nodePool == nil {\n\t\treturn false\n\t}\n\n\tvar nodes [DT_MAX_STATES_PER_NODE]*DtNode\n\tn := this.m_nodePool.FindNodes(ref, nodes[:], uint32(DT_MAX_STATES_PER_NODE))\n\n\tfor i := 0; i \u003c int(n); i++ {\n\t\tif (nodes[i].Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
                    },
                    "IsValidPolyRef": {
                        "Name": "IsValidPolyRef",
                        "Code": "func (this *DtNavMeshQuery) IsValidPolyRef(ref DtPolyRef, filter *DtQueryFilter) bool {\n\tvar tile *DtMeshTile\n\tvar poly *DtPoly\n\tstatus := this.m_nav.GetTileAndPolyByRef(ref, \u0026tile, \u0026poly)\n\t// If cannot get polygon, assume it does not exists and boundary is invalid.\n\tif DtStatusFailed(status) {\n\t\treturn false\n\t}\n\t// If cannot pass filter, assume flags has changed and boundary is invalid.\n\tif !filter.PassFilter(ref, tile, poly) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
                    },
                    "MoveAlongSurface": {
                        "Name": "MoveAlongSurface",
                        "Code": "func (this *DtNavMeshQuery) MoveAlongSurface(startRef DtPolyRef, startPos, endPos []float32,\n\tfilter *DtQueryFilter,\n\tresultPos []float32, visited []DtPolyRef, visitedCount *int, maxVisitedSize int,\n\tbHit *bool) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\tDtAssert(this.m_tinyNodePool != nil)\n\n\t*visitedCount = 0\n\n\t// Validate input\n\tif startRef == 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tstatus := DT_SUCCESS\n\n\tconst MAX_STACK int = 48\n\tvar stack [MAX_STACK]*DtNode\n\tvar nstack int\n\n\tthis.m_tinyNodePool.Clear()\n\n\tstartNode := this.m_tinyNodePool.GetNode(startRef, 0)\n\tstartNode.Pidx = 0\n\tstartNode.Cost = 0\n\tstartNode.Total = 0\n\tstartNode.Id = startRef\n\tstartNode.Flags = DT_NODE_CLOSED\n\tstack[nstack] = startNode\n\tnstack++\n\n\tvar bestPos [3]float32\n\tbestDist := float32(math.MaxFloat32)\n\tvar bestNode *DtNode\n\tDtVcopy(bestPos[:], startPos)\n\n\t// Search constraints\n\tvar searchPos [3]float32\n\tvar searchRadSqr float32\n\tDtVlerp(searchPos[:], startPos, endPos, 0.5)\n\tsearchRadSqr = DtSqrFloat32(DtVdist(startPos, endPos)/2.0 + 0.001)\n\n\tvar verts [DT_VERTS_PER_POLYGON * 3]float32\n\n\tvar wallNode *DtNode\n\tfor nstack != 0 {\n\t\t// Pop front.\n\t\tcurNode := stack[0]\n\t\tfor i := 0; i \u003c nstack-1; i++ {\n\t\t\tstack[i] = stack[i+1]\n\t\t}\n\t\tnstack--\n\n\t\t// Get poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tcurRef := curNode.Id\n\t\tvar curTile *DtMeshTile\n\t\tvar curPoly *DtPoly\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(curRef, \u0026curTile, \u0026curPoly)\n\n\t\t// Collect vertices.\n\t\tnverts := int(curPoly.VertCount)\n\t\tfor i := 0; i \u003c nverts; i++ {\n\t\t\tDtVcopy(verts[i*3:], curTile.Verts[curPoly.Verts[i]*3:])\n\t\t}\n\t\t// If target is inside the poly, stop search.\n\t\tif DtPointInPolygon(endPos, verts[:], nverts) {\n\t\t\tbestNode = curNode\n\t\t\tDtVcopy(bestPos[:], endPos)\n\t\t\tbreak\n\t\t}\n\n\t\t// Find wall edges and find nearest point inside the walls.\n\t\tfor i, j := 0, (int)(curPoly.VertCount-1); i \u003c (int)(curPoly.VertCount); j, i = i, i+1 {\n\t\t\t// Find links to neighbours.\n\t\t\tconst MAX_NEIS int = 8\n\t\t\tnneis := 0\n\t\t\tvar neis [MAX_NEIS]DtPolyRef\n\n\t\t\tif (curPoly.Neis[j] \u0026 DT_EXT_LINK) != 0 {\n\t\t\t\t// Tile border.\n\t\t\t\tfor k := curPoly.FirstLink; k != DT_NULL_LINK; k = curTile.Links[k].Next {\n\t\t\t\t\tlink := \u0026curTile.Links[k]\n\t\t\t\t\tif link.Edge == uint8(j) {\n\t\t\t\t\t\tif link.Ref != 0 {\n\t\t\t\t\t\t\tvar neiTile *DtMeshTile\n\t\t\t\t\t\t\tvar neiPoly *DtPoly\n\t\t\t\t\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(link.Ref, \u0026neiTile, \u0026neiPoly)\n\t\t\t\t\t\t\tif filter.PassFilter(link.Ref, neiTile, neiPoly) {\n\t\t\t\t\t\t\t\tif nneis \u003c MAX_NEIS {\n\t\t\t\t\t\t\t\t\tneis[nneis] = link.Ref\n\t\t\t\t\t\t\t\t\tnneis++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if curPoly.Neis[j] != 0 {\n\t\t\t\tidx := (uint32)(curPoly.Neis[j] - 1)\n\t\t\t\tref := this.m_nav.GetPolyRefBase(curTile) | DtPolyRef(idx)\n\t\t\t\tif filter.PassFilter(ref, curTile, \u0026curTile.Polys[idx]) {\n\t\t\t\t\t// Internal edge, encode id.\n\t\t\t\t\tneis[nneis] = ref\n\t\t\t\t\tnneis++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif nneis == 0 {\n\t\t\t\t// Wall edge, calc distance.\n\t\t\t\tvj := verts[j*3:]\n\t\t\t\tvi := verts[i*3:]\n\t\t\t\tvar tseg float32\n\t\t\t\tdistSqr := DtDistancePtSegSqr2D(endPos, vj, vi, \u0026tseg)\n\t\t\t\tif distSqr \u003c bestDist {\n\t\t\t\t\t// Update nearest distance.\n\t\t\t\t\tDtVlerp(bestPos[:], vj, vi, tseg)\n\t\t\t\t\tbestDist = distSqr\n\t\t\t\t\tbestNode = curNode\n\t\t\t\t\twallNode = curNode\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor k := 0; k \u003c nneis; k++ {\n\t\t\t\t\t// Skip if no node can be allocated.\n\t\t\t\t\tneighbourNode := this.m_tinyNodePool.GetNode(neis[k], 0)\n\t\t\t\t\tif neighbourNode == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// Skip if already visited.\n\t\t\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_CLOSED) != 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// Skip the link if it is too far from search constraint.\n\t\t\t\t\t// TODO: Maybe should use getPortalPoints(), but this one is way faster.\n\t\t\t\t\tvj := verts[j*3:]\n\t\t\t\t\tvi := verts[i*3:]\n\t\t\t\t\tvar tseg float32\n\t\t\t\t\tdistSqr := DtDistancePtSegSqr2D(searchPos[:], vj, vi, \u0026tseg)\n\t\t\t\t\tif distSqr \u003e searchRadSqr {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// Mark as the node as visited and push to queue.\n\t\t\t\t\tif nstack \u003c MAX_STACK {\n\t\t\t\t\t\tneighbourNode.Pidx = this.m_tinyNodePool.GetNodeIdx(curNode)\n\t\t\t\t\t\tneighbourNode.Flags |= DT_NODE_CLOSED\n\t\t\t\t\t\tstack[nstack] = neighbourNode\n\t\t\t\t\t\tnstack++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar n int\n\tif bestNode != nil {\n\t\t// Reverse the path.\n\t\tvar prev *DtNode\n\t\tnode := bestNode\n\t\tfor node != nil {\n\t\t\tnext := this.m_tinyNodePool.GetNodeAtIdx(node.Pidx)\n\t\t\tnode.Pidx = this.m_tinyNodePool.GetNodeIdx(prev)\n\t\t\tprev = node\n\t\t\tnode = next\n\t\t}\n\n\t\t// Store result\n\t\tnode = prev\n\t\tfor node != nil {\n\t\t\tvisited[n] = node.Id\n\t\t\tn++\n\t\t\tif n \u003e= maxVisitedSize {\n\t\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.m_tinyNodePool.GetNodeAtIdx(node.Pidx)\n\t\t}\n\t}\n\n\t*bHit = (wallNode != nil \u0026\u0026 wallNode == bestNode)\n\n\tDtVcopy(resultPos, bestPos[:])\n\n\t*visitedCount = n\n\n\treturn status\n}\n"
                    },
                    "QueryPolygons": {
                        "Name": "QueryPolygons",
                        "Code": "func (this *DtNavMeshQuery) QueryPolygons(center, halfExtents []float32,\n\tfilter *DtQueryFilter,\n\tpolys []DtPolyRef, polyCount *int, maxPolys int) DtStatus {\n\tif polys == nil || polyCount == nil || maxPolys \u003c 0 {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tcollector := dtCollectPolysQuery{}\n\tcollector.constructor(polys, maxPolys)\n\n\tstatus := this.QueryPolygons2(center, halfExtents, filter, \u0026collector)\n\tif DtStatusFailed(status) {\n\t\treturn status\n\t}\n\t*polyCount = collector.numCollected()\n\tif collector.overflowed() {\n\t\treturn DT_SUCCESS | DT_BUFFER_TOO_SMALL\n\t} else {\n\t\treturn DT_SUCCESS\n\t}\n}\n"
                    },
                    "QueryPolygons2": {
                        "Name": "QueryPolygons2",
                        "Code": "func (this *DtNavMeshQuery) QueryPolygons2(center, halfExtents []float32,\n\tfilter *DtQueryFilter, query DtPolyQuery) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\tif center == nil || halfExtents == nil || filter == nil || query == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tvar bmin, bmax [3]float32\n\tDtVsub(bmin[:], center, halfExtents)\n\tDtVadd(bmax[:], center, halfExtents)\n\n\t// Find tiles the query touches.\n\tvar minx, miny, maxx, maxy int32\n\tthis.m_nav.CalcTileLoc(bmin[:], \u0026minx, \u0026miny)\n\tthis.m_nav.CalcTileLoc(bmax[:], \u0026maxx, \u0026maxy)\n\n\tconst MAX_NEIS int = 32\n\tvar neis [MAX_NEIS]*DtMeshTile\n\n\tfor y := miny; y \u003c= maxy; y++ {\n\t\tfor x := minx; x \u003c= maxx; x++ {\n\t\t\tnneis := this.m_nav.GetTilesAt(x, y, neis[:], MAX_NEIS)\n\t\t\tfor j := 0; j \u003c nneis; j++ {\n\t\t\t\tthis.queryPolygonsInTile(neis[j], bmin[:], bmax[:], filter, query)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "Raycast": {
                        "Name": "Raycast",
                        "Code": "func (this *DtNavMeshQuery) Raycast(startRef DtPolyRef, startPos, endPos []float32,\n\tfilter *DtQueryFilter,\n\tt *float32, hitNormal []float32, path []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\tvar hit DtRaycastHit\n\thit.Path = path\n\thit.MaxPath = int32(maxPath)\n\n\tstatus := this.Raycast2(startRef, startPos, endPos, filter, 0, \u0026hit, 0)\n\n\t*t = hit.T\n\tif hitNormal != nil {\n\t\tDtVcopy(hitNormal, hit.HitNormal[:])\n\t}\n\tif pathCount != nil {\n\t\t*pathCount = int(hit.PathCount)\n\t}\n\treturn status\n}\n"
                    },
                    "Raycast2": {
                        "Name": "Raycast2",
                        "Code": "func (this *DtNavMeshQuery) Raycast2(startRef DtPolyRef, startPos, endPos []float32,\n\tfilter *DtQueryFilter, options DtRaycastOptions,\n\thit *DtRaycastHit, prevRef DtPolyRef) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\thit.T = 0\n\thit.PathCount = 0\n\thit.PathCost = 0\n\n\t// Validate input\n\tif startRef == 0 || !this.m_nav.IsValidPolyRef(startRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tif prevRef != 0 \u0026\u0026 !this.m_nav.IsValidPolyRef(prevRef) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tvar dir, curPos, lastPos [3]float32\n\tvar verts [DT_VERTS_PER_POLYGON*3 + 3]float32\n\tn := 0\n\n\tDtVcopy(curPos[:], startPos)\n\tDtVsub(dir[:], endPos, startPos)\n\tDtVset(hit.HitNormal[:], 0, 0, 0)\n\n\tstatus := DT_SUCCESS\n\n\tvar prevTile, tile, nextTile *DtMeshTile\n\tvar prevPoly, poly, nextPoly *DtPoly\n\tvar curRef DtPolyRef\n\n\t// The API input has been checked already, skip checking internal data.\n\tcurRef = startRef\n\ttile = nil\n\tpoly = nil\n\tthis.m_nav.GetTileAndPolyByRefUnsafe(curRef, \u0026tile, \u0026poly)\n\tnextTile = tile\n\tprevTile = tile\n\tnextPoly = poly\n\tprevPoly = poly\n\tif prevRef != 0 {\n\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(prevRef, \u0026prevTile, \u0026prevPoly)\n\t}\n\tfor curRef != 0 {\n\t\t// Cast ray against current polygon.\n\n\t\t// Collect vertices.\n\t\tnv := 0\n\t\tfor i := 0; i \u003c (int)(poly.VertCount); i++ {\n\t\t\tDtVcopy(verts[nv*3:], tile.Verts[poly.Verts[i]*3:])\n\t\t\tnv++\n\t\t}\n\n\t\tvar tmin, tmax float32\n\t\tvar segMin, segMax int\n\t\tif !DtIntersectSegmentPoly2D(startPos, endPos, verts[:], nv, \u0026tmin, \u0026tmax, \u0026segMin, \u0026segMax) {\n\t\t\t// Could not hit the polygon, keep the old t and report hit.\n\t\t\thit.PathCount = int32(n)\n\t\t\treturn status\n\t\t}\n\n\t\thit.HitEdgeIndex = int32(segMax)\n\n\t\t// Keep track of furthest t so far.\n\t\tif tmax \u003e hit.T {\n\t\t\thit.T = tmax\n\t\t}\n\t\t// Store visited polygons.\n\t\tif n \u003c int(hit.MaxPath) {\n\t\t\thit.Path[n] = curRef\n\t\t\tn++\n\t\t} else {\n\t\t\tstatus |= DT_BUFFER_TOO_SMALL\n\t\t}\n\t\t// Ray end is completely inside the polygon.\n\t\tif segMax == -1 {\n\t\t\thit.T = float32(math.MaxFloat32)\n\t\t\thit.PathCount = int32(n)\n\n\t\t\t// add the cost\n\t\t\tif (options \u0026 DT_RAYCAST_USE_COSTS) != 0 {\n\t\t\t\thit.PathCost += filter.GetCost(curPos[:], endPos, prevRef, prevTile, prevPoly, curRef, tile, poly, curRef, tile, poly)\n\t\t\t}\n\t\t\treturn status\n\t\t}\n\n\t\t// Follow neighbours.\n\t\tvar nextRef DtPolyRef\n\n\t\tfor i := poly.FirstLink; i != DT_NULL_LINK; i = tile.Links[i].Next {\n\t\t\tlink := \u0026tile.Links[i]\n\n\t\t\t// Find link which contains this edge.\n\t\t\tif (int)(link.Edge) != segMax {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Get pointer to the next polygon.\n\t\t\tnextTile = nil\n\t\t\tnextPoly = nil\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(link.Ref, \u0026nextTile, \u0026nextPoly)\n\n\t\t\t// Skip off-mesh connections.\n\t\t\tif nextPoly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Skip links based on filter.\n\t\t\tif !filter.PassFilter(link.Ref, nextTile, nextPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the link is internal, just return the ref.\n\t\t\tif link.Side == 0xff {\n\t\t\t\tnextRef = link.Ref\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// If the link is at tile boundary,\n\n\t\t\t// Check if the link spans the whole edge, and accept.\n\t\t\tif link.Bmin == 0 \u0026\u0026 link.Bmax == 255 {\n\t\t\t\tnextRef = link.Ref\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Check for partial edge links.\n\t\t\tv0 := poly.Verts[link.Edge]\n\t\t\tv1 := poly.Verts[(link.Edge+1)%poly.VertCount]\n\t\t\tleft := tile.Verts[v0*3:]\n\t\t\tright := tile.Verts[v1*3:]\n\n\t\t\t// Check that the intersection lies inside the link portal.\n\t\t\tif link.Side == 0 || link.Side == 4 {\n\t\t\t\t// Calculate link size.\n\t\t\t\ts := float32(1.0 / 255.0)\n\t\t\t\tlmin := left[2] + (right[2]-left[2])*(float32(link.Bmin)*s)\n\t\t\t\tlmax := left[2] + (right[2]-left[2])*(float32(link.Bmax)*s)\n\t\t\t\tif lmin \u003e lmax {\n\t\t\t\t\tDtSwapFloat32(\u0026lmin, \u0026lmax)\n\t\t\t\t}\n\n\t\t\t\t// Find Z intersection.\n\t\t\t\tz := startPos[2] + (endPos[2]-startPos[2])*tmax\n\t\t\t\tif z \u003e= lmin \u0026\u0026 z \u003c= lmax {\n\t\t\t\t\tnextRef = link.Ref\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if link.Side == 2 || link.Side == 6 {\n\t\t\t\t// Calculate link size.\n\t\t\t\ts := float32(1.0 / 255.0)\n\t\t\t\tlmin := left[0] + (right[0]-left[0])*(float32(link.Bmin)*s)\n\t\t\t\tlmax := left[0] + (right[0]-left[0])*(float32(link.Bmax)*s)\n\t\t\t\tif lmin \u003e lmax {\n\t\t\t\t\tDtSwapFloat32(\u0026lmin, \u0026lmax)\n\t\t\t\t}\n\n\t\t\t\t// Find X intersection.\n\t\t\t\tx := startPos[0] + (endPos[0]-startPos[0])*tmax\n\t\t\t\tif x \u003e= lmin \u0026\u0026 x \u003c= lmax {\n\t\t\t\t\tnextRef = link.Ref\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add the cost\n\t\tif (options \u0026 DT_RAYCAST_USE_COSTS) != 0 {\n\t\t\t// compute the intersection point at the furthest end of the polygon\n\t\t\t// and correct the height (since the raycast moves in 2d)\n\t\t\tDtVcopy(lastPos[:], curPos[:])\n\t\t\tDtVmad(curPos[:], startPos, dir[:], hit.T)\n\t\t\te1 := verts[segMax*3:]\n\t\t\te2 := verts[((segMax+1)%nv)*3:]\n\t\t\tvar eDir, diff [3]float32\n\t\t\tDtVsub(eDir[:], e2, e1)\n\t\t\tDtVsub(diff[:], curPos[:], e1)\n\t\t\tvar s float32\n\t\t\tif DtSqrFloat32(eDir[0]) \u003e DtSqrFloat32(eDir[2]) {\n\t\t\t\ts = diff[0] / eDir[0]\n\t\t\t} else {\n\t\t\t\ts = diff[2] / eDir[2]\n\t\t\t}\n\t\t\tcurPos[1] = e1[1] + eDir[1]*s\n\n\t\t\thit.PathCost += filter.GetCost(lastPos[:], curPos[:], prevRef, prevTile, prevPoly, curRef, tile, poly, nextRef, nextTile, nextPoly)\n\t\t}\n\n\t\tif nextRef == 0 {\n\t\t\t// No neighbour, we hit a wall.\n\n\t\t\t// Calculate hit normal.\n\t\t\ta := segMax\n\t\t\tvar b int\n\t\t\tif segMax+1 \u003c nv {\n\t\t\t\tb = segMax + 1\n\t\t\t} else {\n\t\t\t\tb = 0\n\t\t\t}\n\t\t\tva := verts[a*3:]\n\t\t\tvb := verts[b*3:]\n\t\t\tdx := vb[0] - va[0]\n\t\t\tdz := vb[2] - va[2]\n\t\t\thit.HitNormal[0] = dz\n\t\t\thit.HitNormal[1] = 0\n\t\t\thit.HitNormal[2] = -dx\n\t\t\tDtVnormalize(hit.HitNormal[:])\n\n\t\t\thit.PathCount = int32(n)\n\t\t\treturn status\n\t\t}\n\n\t\t// No hit, advance to neighbour polygon.\n\t\tprevRef = curRef\n\t\tcurRef = nextRef\n\t\tprevTile = tile\n\t\ttile = nextTile\n\t\tprevPoly = poly\n\t\tpoly = nextPoly\n\t}\n\n\thit.PathCount = int32(n)\n\n\treturn status\n}\n"
                    },
                    "UpdateSlicedFindPath": {
                        "Name": "UpdateSlicedFindPath",
                        "Code": "func (this *DtNavMeshQuery) UpdateSlicedFindPath(maxIter int, doneIters *int) DtStatus {\n\tif !DtStatusInProgress(this.m_query.status) {\n\t\treturn this.m_query.status\n\t}\n\t// Make sure the request is still valid.\n\tif !this.m_nav.IsValidPolyRef(this.m_query.startRef) || !this.m_nav.IsValidPolyRef(this.m_query.endRef) {\n\t\tthis.m_query.status = DT_FAILURE\n\t\treturn DT_FAILURE\n\t}\n\n\trayHit := DtRaycastHit{}\n\trayHit.MaxPath = 0\n\n\titer := 0\n\tfor iter \u003c maxIter \u0026\u0026 !this.m_openList.Empty() {\n\t\titer++\n\n\t\t// Remove node from open list and put it in closed list.\n\t\tbestNode := this.m_openList.Pop()\n\t\tbestNode.Flags \u0026= ^DT_NODE_OPEN\n\t\tbestNode.Flags |= DT_NODE_CLOSED\n\n\t\t// Reached the goal, stop searching.\n\t\tif bestNode.Id == this.m_query.endRef {\n\t\t\tthis.m_query.lastBestNode = bestNode\n\t\t\tdetails := this.m_query.status \u0026 DT_STATUS_DETAIL_MASK\n\t\t\tthis.m_query.status = DT_SUCCESS | details\n\t\t\tif doneIters != nil {\n\t\t\t\t*doneIters = iter\n\t\t\t}\n\t\t\treturn this.m_query.status\n\t\t}\n\n\t\t// Get current poly and tile.\n\t\t// The API input has been cheked already, skip checking internal data.\n\t\tbestRef := bestNode.Id\n\t\tvar bestTile *DtMeshTile\n\t\tvar bestPoly *DtPoly\n\t\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(bestRef, \u0026bestTile, \u0026bestPoly)) {\n\t\t\t// The polygon has disappeared during the sliced query, fail.\n\t\t\tthis.m_query.status = DT_FAILURE\n\t\t\tif doneIters != nil {\n\t\t\t\t*doneIters = iter\n\t\t\t}\n\t\t\treturn this.m_query.status\n\t\t}\n\n\t\t// Get parent and grand parent poly and tile.\n\t\tvar parentRef, grandpaRef DtPolyRef\n\t\tvar parentTile *DtMeshTile\n\t\tvar parentPoly *DtPoly\n\t\tvar parentNode *DtNode\n\t\tif bestNode.Pidx != 0 {\n\t\t\tparentNode = this.m_nodePool.GetNodeAtIdx(bestNode.Pidx)\n\t\t\tparentRef = parentNode.Id\n\t\t\tif parentNode.Pidx != 0 {\n\t\t\t\tgrandpaRef = this.m_nodePool.GetNodeAtIdx(parentNode.Pidx).Id\n\t\t\t}\n\t\t}\n\t\tif parentRef != 0 {\n\t\t\tinvalidParent := DtStatusFailed(this.m_nav.GetTileAndPolyByRef(parentRef, \u0026parentTile, \u0026parentPoly))\n\t\t\tif invalidParent || (grandpaRef != 0 \u0026\u0026 !this.m_nav.IsValidPolyRef(grandpaRef)) {\n\t\t\t\t// The polygon has disappeared during the sliced query, fail.\n\t\t\t\tthis.m_query.status = DT_FAILURE\n\t\t\t\tif doneIters != nil {\n\t\t\t\t\t*doneIters = iter\n\t\t\t\t}\n\t\t\t\treturn this.m_query.status\n\t\t\t}\n\t\t}\n\n\t\t// decide whether to test raycast to previous nodes\n\t\ttryLOS := false\n\t\tif (this.m_query.options \u0026 DT_FINDPATH_ANY_ANGLE) != 0 {\n\t\t\tif (parentRef != 0) \u0026\u0026 (DtVdistSqr(parentNode.Pos[:], bestNode.Pos[:]) \u003c this.m_query.raycastLimitSqr) {\n\t\t\t\ttryLOS = true\n\t\t\t}\n\t\t}\n\n\t\tfor i := bestPoly.FirstLink; i != DT_NULL_LINK; i = bestTile.Links[i].Next {\n\t\t\tneighbourRef := bestTile.Links[i].Ref\n\n\t\t\t// Skip invalid ids and do not expand back to where we came from.\n\t\t\tif neighbourRef == 0 || neighbourRef == parentRef {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Get neighbour poly and tile.\n\t\t\t// The API input has been cheked already, skip checking internal data.\n\t\t\tvar neighbourTile *DtMeshTile\n\t\t\tvar neighbourPoly *DtPoly\n\t\t\tthis.m_nav.GetTileAndPolyByRefUnsafe(neighbourRef, \u0026neighbourTile, \u0026neighbourPoly)\n\n\t\t\tif !this.m_query.filter.PassFilter(neighbourRef, neighbourTile, neighbourPoly) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// get the neighbor node\n\t\t\tneighbourNode := this.m_nodePool.GetNode(neighbourRef, 0)\n\t\t\tif neighbourNode == nil {\n\t\t\t\tthis.m_query.status |= DT_OUT_OF_NODES\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// do not expand to nodes that were already visited from the same parent\n\t\t\tif neighbourNode.Pidx != 0 \u0026\u0026 neighbourNode.Pidx == bestNode.Pidx {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// If the node is visited the first time, calculate node position.\n\t\t\tif neighbourNode.Flags == 0 {\n\t\t\t\tthis.getEdgeMidPoint2(bestRef, bestPoly, bestTile,\n\t\t\t\t\tneighbourRef, neighbourPoly, neighbourTile,\n\t\t\t\t\tneighbourNode.Pos[:])\n\t\t\t}\n\n\t\t\t// Calculate cost and heuristic.\n\t\t\tvar cost float32\n\t\t\tvar heuristic float32\n\n\t\t\t// raycast parent\n\t\t\tfoundShortCut := false\n\t\t\trayHit.PathCost = 0\n\t\t\trayHit.T = 0\n\t\t\tif tryLOS {\n\t\t\t\tthis.Raycast2(parentRef, parentNode.Pos[:], neighbourNode.Pos[:], this.m_query.filter, DT_RAYCAST_USE_COSTS, \u0026rayHit, grandpaRef)\n\t\t\t\tfoundShortCut = (rayHit.T \u003e= 1.0)\n\t\t\t}\n\n\t\t\t// update move cost\n\t\t\tif foundShortCut {\n\t\t\t\t// shortcut found using raycast. Using shorter cost instead\n\t\t\t\tcost = parentNode.Cost + rayHit.PathCost\n\t\t\t} else {\n\t\t\t\t// No shortcut found.\n\t\t\t\tcurCost := this.m_query.filter.GetCost(bestNode.Pos[:], neighbourNode.Pos[:],\n\t\t\t\t\tparentRef, parentTile, parentPoly,\n\t\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\t\tneighbourRef, neighbourTile, neighbourPoly)\n\t\t\t\tcost = bestNode.Cost + curCost\n\t\t\t}\n\n\t\t\t// Special case for last node.\n\t\t\tif neighbourRef == this.m_query.endRef {\n\t\t\t\tendCost := this.m_query.filter.GetCost(neighbourNode.Pos[:], this.m_query.endPos[:],\n\t\t\t\t\tbestRef, bestTile, bestPoly,\n\t\t\t\t\tneighbourRef, neighbourTile, neighbourPoly,\n\t\t\t\t\t0, nil, nil)\n\n\t\t\t\tcost = cost + endCost\n\t\t\t\theuristic = 0\n\t\t\t} else {\n\t\t\t\theuristic = DtVdist(neighbourNode.Pos[:], this.m_query.endPos[:]) * H_SCALE\n\t\t\t}\n\n\t\t\ttotal := cost + heuristic\n\n\t\t\t// The node is already in open list and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_OPEN) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// The node is already visited and process, and the new result is worse, skip.\n\t\t\tif (neighbourNode.Flags\u0026DT_NODE_CLOSED) != 0 \u0026\u0026 total \u003e= neighbourNode.Total {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Add or update the node.\n\t\t\tif foundShortCut {\n\t\t\t\tneighbourNode.Pidx = bestNode.Pidx\n\t\t\t} else {\n\t\t\t\tneighbourNode.Pidx = this.m_nodePool.GetNodeIdx(bestNode)\n\t\t\t}\n\t\t\tneighbourNode.Id = neighbourRef\n\t\t\tneighbourNode.Flags = (neighbourNode.Flags \u0026 ^(DT_NODE_CLOSED | DT_NODE_PARENT_DETACHED))\n\t\t\tneighbourNode.Cost = cost\n\t\t\tneighbourNode.Total = total\n\t\t\tif foundShortCut {\n\t\t\t\tneighbourNode.Flags = (neighbourNode.Flags | DT_NODE_PARENT_DETACHED)\n\t\t\t}\n\t\t\tif (neighbourNode.Flags \u0026 DT_NODE_OPEN) != 0 {\n\t\t\t\t// Already in open, update node location.\n\t\t\t\tthis.m_openList.Modify(neighbourNode)\n\t\t\t} else {\n\t\t\t\t// Put the node in open list.\n\t\t\t\tneighbourNode.Flags |= DT_NODE_OPEN\n\t\t\t\tthis.m_openList.Push(neighbourNode)\n\t\t\t}\n\n\t\t\t// Update nearest node to target so far.\n\t\t\tif heuristic \u003c this.m_query.lastBestNodeCost {\n\t\t\t\tthis.m_query.lastBestNodeCost = heuristic\n\t\t\t\tthis.m_query.lastBestNode = neighbourNode\n\t\t\t}\n\t\t}\n\t}\n\n\t// Exhausted all nodes, but could not find path.\n\tif this.m_openList.Empty() {\n\t\tdetails := this.m_query.status \u0026 DT_STATUS_DETAIL_MASK\n\t\tthis.m_query.status = DT_SUCCESS | details\n\t}\n\n\tif doneIters != nil {\n\t\t*doneIters = iter\n\t}\n\n\treturn this.m_query.status\n}\n"
                    },
                    "appendPortals": {
                        "Name": "appendPortals",
                        "Code": "func (this *DtNavMeshQuery) appendPortals(startIdx, endIdx int, endPos []float32, path []DtPolyRef,\n\tstraightPath []float32, straightPathFlags []DtStraightPathFlags, straightPathRefs []DtPolyRef,\n\tstraightPathCount *int, maxStraightPath int, options DtStraightPathOptions) DtStatus {\n\tstartPos := straightPath[(*straightPathCount-1)*3:]\n\t// Append or update last vertex\n\tvar stat DtStatus\n\tfor i := startIdx; i \u003c endIdx; i++ {\n\t\t// Calculate portal\n\t\tfrom := path[i]\n\t\tvar fromTile *DtMeshTile\n\t\tvar fromPoly *DtPoly\n\t\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(from, \u0026fromTile, \u0026fromPoly)) {\n\t\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t\t}\n\t\tto := path[i+1]\n\t\tvar toTile *DtMeshTile\n\t\tvar toPoly *DtPoly\n\t\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(to, \u0026toTile, \u0026toPoly)) {\n\t\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t\t}\n\t\tvar left, right [3]float32\n\t\tif DtStatusFailed(this.getPortalPoints2(from, fromPoly, fromTile, to, toPoly, toTile, left[:], right[:])) {\n\t\t\tbreak\n\t\t}\n\t\tif (options \u0026 DT_STRAIGHTPATH_AREA_CROSSINGS) != 0 {\n\t\t\t// Skip intersection if only area crossings are requested.\n\t\t\tif fromPoly.GetArea() == toPoly.GetArea() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Append intersection\n\t\tvar s, t float32\n\t\tif DtIntersectSegSeg2D(startPos, endPos, left[:], right[:], \u0026s, \u0026t) {\n\t\t\tvar pt [3]float32\n\t\t\tDtVlerp(pt[:], left[:], right[:], t)\n\n\t\t\tstat = this.appendVertex(pt[:], 0, path[i+1],\n\t\t\t\tstraightPath, straightPathFlags, straightPathRefs,\n\t\t\t\tstraightPathCount, maxStraightPath)\n\t\t\tif stat != DT_IN_PROGRESS {\n\t\t\t\treturn stat\n\t\t\t}\n\t\t}\n\t}\n\treturn DT_IN_PROGRESS\n}\n"
                    },
                    "appendVertex": {
                        "Name": "appendVertex",
                        "Code": "func (this *DtNavMeshQuery) appendVertex(pos []float32, flags DtStraightPathFlags, ref DtPolyRef,\n\tstraightPath []float32, straightPathFlags []DtStraightPathFlags, straightPathRefs []DtPolyRef,\n\tstraightPathCount *int, maxStraightPath int) DtStatus {\n\tif (*straightPathCount) \u003e 0 \u0026\u0026 DtVequal(straightPath[((*straightPathCount)-1)*3:], pos) {\n\t\t// The vertices are equal, update flags and poly.\n\t\tif straightPathFlags != nil {\n\t\t\tstraightPathFlags[(*straightPathCount)-1] = flags\n\t\t}\n\t\tif straightPathRefs != nil {\n\t\t\tstraightPathRefs[(*straightPathCount)-1] = ref\n\t\t}\n\t} else {\n\t\t// Append new vertex.\n\t\tDtVcopy(straightPath[(*straightPathCount)*3:], pos)\n\t\tif straightPathFlags != nil {\n\t\t\tstraightPathFlags[(*straightPathCount)] = flags\n\t\t}\n\t\tif straightPathRefs != nil {\n\t\t\tstraightPathRefs[(*straightPathCount)] = ref\n\t\t}\n\t\t(*straightPathCount)++\n\n\t\t// If there is no space to append more vertices, return.\n\t\tif (*straightPathCount) \u003e= maxStraightPath {\n\t\t\treturn DT_SUCCESS | DT_BUFFER_TOO_SMALL\n\t\t}\n\n\t\t// If reached end of path, return.\n\t\tif flags == DT_STRAIGHTPATH_END {\n\t\t\treturn DT_SUCCESS\n\t\t}\n\t}\n\treturn DT_IN_PROGRESS\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *DtNavMeshQuery) constructor() {\n\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtNavMeshQuery) destructor() {\n\tif this.m_tinyNodePool != nil {\n\t\tDtFreeNodePool(this.m_tinyNodePool)\n\t\tthis.m_tinyNodePool = nil\n\t}\n\tif this.m_nodePool != nil {\n\t\tDtFreeNodePool(this.m_nodePool)\n\t\tthis.m_nodePool = nil\n\t}\n\tif this.m_openList != nil {\n\t\tDtFreeNodeQueue(this.m_openList)\n\t\tthis.m_openList = nil\n\t}\n}\n"
                    },
                    "getEdgeMidPoint": {
                        "Name": "getEdgeMidPoint",
                        "Code": "func (this *DtNavMeshQuery) getEdgeMidPoint(from, to DtPolyRef, mid []float32) DtStatus {\n\tvar left, right [3]float32\n\tvar fromType, toType DtPolyTypes\n\tif DtStatusFailed(this.getPortalPoints(from, to, left[:], right[:], \u0026fromType, \u0026toType)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tmid[0] = (left[0] + right[0]) * 0.5\n\tmid[1] = (left[1] + right[1]) * 0.5\n\tmid[2] = (left[2] + right[2]) * 0.5\n\treturn DT_SUCCESS\n}\n"
                    },
                    "getEdgeMidPoint2": {
                        "Name": "getEdgeMidPoint2",
                        "Code": "func (this *DtNavMeshQuery) getEdgeMidPoint2(from DtPolyRef, fromPoly *DtPoly, fromTile *DtMeshTile,\n\tto DtPolyRef, toPoly *DtPoly, toTile *DtMeshTile,\n\tmid []float32) DtStatus {\n\tvar left, right [3]float32\n\tif DtStatusFailed(this.getPortalPoints2(from, fromPoly, fromTile, to, toPoly, toTile, left[:], right[:])) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\tmid[0] = (left[0] + right[0]) * 0.5\n\tmid[1] = (left[1] + right[1]) * 0.5\n\tmid[2] = (left[2] + right[2]) * 0.5\n\treturn DT_SUCCESS\n}\n"
                    },
                    "getPathToNode": {
                        "Name": "getPathToNode",
                        "Code": "func (this *DtNavMeshQuery) getPathToNode(endNode *DtNode, path []DtPolyRef, pathCount *int, maxPath int) DtStatus {\n\t// Find the length of the entire path.\n\tcurNode := endNode\n\tlength := 0\n\tfor curNode != nil {\n\t\tlength++\n\t\tcurNode = this.m_nodePool.GetNodeAtIdx(curNode.Pidx)\n\t}\n\n\t// If the path cannot be fully stored then advance to the last node we will be able to store.\n\tcurNode = endNode\n\tvar writeCount int\n\tfor writeCount = length; writeCount \u003e maxPath; writeCount-- {\n\t\tDtAssert(curNode != nil)\n\t\tcurNode = this.m_nodePool.GetNodeAtIdx(curNode.Pidx)\n\t}\n\n\t// Write path\n\tfor i := writeCount - 1; i \u003e= 0; i-- {\n\t\tDtAssert(curNode != nil)\n\t\tpath[i] = curNode.Id\n\t\tcurNode = this.m_nodePool.GetNodeAtIdx(curNode.Pidx)\n\t}\n\n\tDtAssert(curNode == nil)\n\n\t*pathCount = int(DtMinInt32(int32(length), int32(maxPath)))\n\n\tif length \u003e maxPath {\n\t\treturn DT_SUCCESS | DT_BUFFER_TOO_SMALL\n\t}\n\treturn DT_SUCCESS\n}\n"
                    },
                    "getPortalPoints": {
                        "Name": "getPortalPoints",
                        "Code": "func (this *DtNavMeshQuery) getPortalPoints(from, to DtPolyRef, left, right []float32,\n\tfromType, toType *DtPolyTypes) DtStatus {\n\tDtAssert(this.m_nav != nil)\n\n\tvar fromTile *DtMeshTile\n\tvar fromPoly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(from, \u0026fromTile, \u0026fromPoly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t*fromType = fromPoly.GetType()\n\n\tvar toTile *DtMeshTile\n\tvar toPoly *DtPoly\n\tif DtStatusFailed(this.m_nav.GetTileAndPolyByRef(to, \u0026toTile, \u0026toPoly)) {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t*toType = toPoly.GetType()\n\n\treturn this.getPortalPoints2(from, fromPoly, fromTile, to, toPoly, toTile, left, right)\n}\n"
                    },
                    "getPortalPoints2": {
                        "Name": "getPortalPoints2",
                        "Code": "func (this *DtNavMeshQuery) getPortalPoints2(from DtPolyRef, fromPoly *DtPoly, fromTile *DtMeshTile,\n\tto DtPolyRef, toPoly *DtPoly, toTile *DtMeshTile,\n\tleft, right []float32) DtStatus {\n\t// Find the link that points to the 'to' polygon.\n\tvar link *DtLink\n\tfor i := fromPoly.FirstLink; i != DT_NULL_LINK; i = fromTile.Links[i].Next {\n\t\tif fromTile.Links[i].Ref == to {\n\t\t\tlink = \u0026fromTile.Links[i]\n\t\t\tbreak\n\t\t}\n\t}\n\tif link == nil {\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\t// Handle off-mesh connections.\n\tif fromPoly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t// Find link that points to first vertex.\n\t\tfor i := fromPoly.FirstLink; i != DT_NULL_LINK; i = fromTile.Links[i].Next {\n\t\t\tif fromTile.Links[i].Ref == to {\n\t\t\t\tv := fromTile.Links[i].Edge\n\t\t\t\tDtVcopy(left, fromTile.Verts[fromPoly.Verts[v]*3:])\n\t\t\t\tDtVcopy(right, fromTile.Verts[fromPoly.Verts[v]*3:])\n\t\t\t\treturn DT_SUCCESS\n\t\t\t}\n\t\t}\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\n\tif toPoly.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\tfor i := toPoly.FirstLink; i != DT_NULL_LINK; i = toTile.Links[i].Next {\n\t\t\tif toTile.Links[i].Ref == from {\n\t\t\t\tv := toTile.Links[i].Edge\n\t\t\t\tDtVcopy(left, toTile.Verts[toPoly.Verts[v]*3:])\n\t\t\t\tDtVcopy(right, toTile.Verts[toPoly.Verts[v]*3:])\n\t\t\t\treturn DT_SUCCESS\n\t\t\t}\n\t\t}\n\t\treturn DT_FAILURE | DT_INVALID_PARAM\n\t}\n\n\t// Find portal vertices.\n\tv0 := fromPoly.Verts[link.Edge]\n\tv1 := fromPoly.Verts[int(link.Edge+1)%(int)(fromPoly.VertCount)]\n\tDtVcopy(left, fromTile.Verts[v0*3:])\n\tDtVcopy(right, fromTile.Verts[v1*3:])\n\n\t// If the link is at tile boundary, dtClamp the vertices to\n\t// the link width.\n\tif link.Side != 0xff {\n\t\t// Unpack portal limits.\n\t\tif link.Bmin != 0 || link.Bmax != 255 {\n\t\t\ts := float32(1.0 / 255.0)\n\t\t\ttmin := float32(link.Bmin) * s\n\t\t\ttmax := float32(link.Bmax) * s\n\t\t\tDtVlerp(left, fromTile.Verts[v0*3:], fromTile.Verts[v1*3:], tmin)\n\t\t\tDtVlerp(right, fromTile.Verts[v0*3:], fromTile.Verts[v1*3:], tmax)\n\t\t}\n\t}\n\n\treturn DT_SUCCESS\n}\n"
                    },
                    "queryPolygonsInTile": {
                        "Name": "queryPolygonsInTile",
                        "Code": "func (this *DtNavMeshQuery) queryPolygonsInTile(tile *DtMeshTile, qmin, qmax []float32,\n\tfilter *DtQueryFilter, query DtPolyQuery) {\n\tDtAssert(this.m_nav != nil)\n\tconst batchSize int = 32\n\tvar polyRefs [batchSize]DtPolyRef\n\tvar polys [batchSize]*DtPoly\n\tn := 0\n\n\tif tile.BvTree != nil {\n\t\tnodeIndex := 0\n\t\tendIndex := int(tile.Header.BvNodeCount)\n\t\ttbmin := tile.Header.Bmin[:]\n\t\ttbmax := tile.Header.Bmax[:]\n\t\tqfac := tile.Header.BvQuantFactor\n\n\t\t// Calculate quantized box\n\t\tvar bmin, bmax [3]uint16\n\t\t// dtClamp query box to world box.\n\t\tminx := DtClampFloat32(qmin[0], tbmin[0], tbmax[0]) - tbmin[0]\n\t\tminy := DtClampFloat32(qmin[1], tbmin[1], tbmax[1]) - tbmin[1]\n\t\tminz := DtClampFloat32(qmin[2], tbmin[2], tbmax[2]) - tbmin[2]\n\t\tmaxx := DtClampFloat32(qmax[0], tbmin[0], tbmax[0]) - tbmin[0]\n\t\tmaxy := DtClampFloat32(qmax[1], tbmin[1], tbmax[1]) - tbmin[1]\n\t\tmaxz := DtClampFloat32(qmax[2], tbmin[2], tbmax[2]) - tbmin[2]\n\t\t// Quantize\n\t\tbmin[0] = (uint16)(qfac*minx) \u0026 0xfffe\n\t\tbmin[1] = (uint16)(qfac*miny) \u0026 0xfffe\n\t\tbmin[2] = (uint16)(qfac*minz) \u0026 0xfffe\n\t\tbmax[0] = (uint16)(qfac*maxx+1) | 1\n\t\tbmax[1] = (uint16)(qfac*maxy+1) | 1\n\t\tbmax[2] = (uint16)(qfac*maxz+1) | 1\n\n\t\t// Traverse tree\n\t\tbase := this.m_nav.GetPolyRefBase(tile)\n\t\tfor nodeIndex \u003c endIndex {\n\t\t\tnode := \u0026tile.BvTree[nodeIndex]\n\t\t\toverlap := DtOverlapQuantBounds(bmin[:], bmax[:], node.Bmin[:], node.Bmax[:])\n\t\t\tisLeafNode := (node.I \u003e= 0)\n\n\t\t\tif isLeafNode \u0026\u0026 overlap {\n\t\t\t\tref := base | (DtPolyRef)(node.I)\n\t\t\t\tif filter.PassFilter(ref, tile, \u0026tile.Polys[node.I]) {\n\t\t\t\t\tpolyRefs[n] = ref\n\t\t\t\t\tpolys[n] = \u0026tile.Polys[node.I]\n\n\t\t\t\t\tif n == batchSize-1 {\n\t\t\t\t\t\tquery.Process(tile, polys[:], polyRefs[:], batchSize)\n\t\t\t\t\t\tn = 0\n\t\t\t\t\t} else {\n\t\t\t\t\t\tn++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif overlap || isLeafNode {\n\t\t\t\tnodeIndex++\n\t\t\t} else {\n\t\t\t\tescapeIndex := int(-node.I)\n\t\t\t\tnodeIndex += escapeIndex\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar bmin, bmax [3]float32\n\t\tbase := this.m_nav.GetPolyRefBase(tile)\n\t\tfor i := 0; i \u003c int(tile.Header.PolyCount); i++ {\n\t\t\tp := \u0026tile.Polys[i]\n\t\t\t// Do not return off-mesh connection polygons.\n\t\t\tif p.GetType() == DT_POLYTYPE_OFFMESH_CONNECTION {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Must pass filter\n\t\t\tref := base | (DtPolyRef)(i)\n\t\t\tif !filter.PassFilter(ref, tile, p) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Calc polygon bounds.\n\t\t\tv := tile.Verts[p.Verts[0]*3:]\n\t\t\tDtVcopy(bmin[:], v)\n\t\t\tDtVcopy(bmax[:], v)\n\t\t\tfor j := 1; j \u003c int(p.VertCount); j++ {\n\t\t\t\tv = tile.Verts[p.Verts[j]*3:]\n\t\t\t\tDtVmin(bmin[:], v)\n\t\t\t\tDtVmax(bmax[:], v)\n\t\t\t}\n\t\t\tif DtOverlapBounds(qmin, qmax, bmin[:], bmax[:]) {\n\t\t\t\tpolyRefs[n] = ref\n\t\t\t\tpolys[n] = p\n\n\t\t\t\tif n == batchSize-1 {\n\t\t\t\t\tquery.Process(tile, polys[:], polyRefs[:], batchSize)\n\t\t\t\t\tn = 0\n\t\t\t\t} else {\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process the last polygons that didn't make a full batch.\n\tif n \u003e 0 {\n\t\tquery.Process(tile, polys[:], polyRefs[:], n)\n\t}\n}\n"
                    }
                }
            },
            "DtNode": {
                "Name": "DtNode",
                "Code": "type DtNode struct {\n\tPos   [3]float32  ///\u003c Position of the node.\n\tCost  float32     ///\u003c Cost from previous node to current node.\n\tTotal float32     ///\u003c Cost up to the node.\n\tPidx  uint32      ///\u003c Index to parent node.\n\tState uint8       ///\u003c extra state information. A polyRef can have multiple nodes with different extra info. see DT_MAX_STATES_PER_NODE\n\tFlags DtNodeFlags ///\u003c Node flags. A combination of dtNodeFlags.\n\tId    DtPolyRef   ///\u003c Polygon ref the node corresponds to.\n}\n",
                "Methods": {}
            },
            "DtNodeFlags": {
                "Name": "DtNodeFlags",
                "Code": "type DtNodeFlags uint8\n",
                "Methods": {}
            },
            "DtNodeIndex": {
                "Name": "DtNodeIndex",
                "Code": "type DtNodeIndex uint16\n",
                "Methods": {}
            },
            "DtNodePool": {
                "Name": "DtNodePool",
                "Code": "type DtNodePool struct {\n\tm_nodes     []DtNode\n\tm_first     []DtNodeIndex\n\tm_next      []DtNodeIndex\n\tm_maxNodes  uint32\n\tm_hashSize  uint32\n\tm_nodeCount uint32\n\n\tbase uintptr\n}\n",
                "Methods": {
                    "Clear": {
                        "Name": "Clear",
                        "Code": "func (this *DtNodePool) Clear() {\n\tfor i := 0; i \u003c len(this.m_first); i++ {\n\t\tthis.m_first[i] = DT_NULL_IDX\n\t}\n\tthis.m_nodeCount = 0\n}\n"
                    },
                    "FindNode": {
                        "Name": "FindNode",
                        "Code": "func (this *DtNodePool) FindNode(id DtPolyRef, state uint8) *DtNode {\n\tbucket := DtHashRef(id) \u0026 (this.m_hashSize - 1)\n\ti := this.m_first[bucket]\n\tfor i != DT_NULL_IDX {\n\t\tif this.m_nodes[i].Id == id \u0026\u0026 this.m_nodes[i].State == state {\n\t\t\treturn \u0026this.m_nodes[i]\n\t\t}\n\t\ti = this.m_next[i]\n\t}\n\treturn nil\n}\n"
                    },
                    "FindNodes": {
                        "Name": "FindNodes",
                        "Code": "func (this *DtNodePool) FindNodes(id DtPolyRef, nodes []*DtNode, maxNodes uint32) uint32 {\n\tvar n uint32 = 0\n\tbucket := DtHashRef(id) \u0026 (this.m_hashSize - 1)\n\ti := this.m_first[bucket]\n\tfor i != DT_NULL_IDX {\n\t\tif this.m_nodes[i].Id == id {\n\t\t\tif n \u003e= maxNodes {\n\t\t\t\treturn n\n\t\t\t}\n\t\t\tnodes[n] = \u0026this.m_nodes[i]\n\t\t\tn = n + 1\n\t\t}\n\t\ti = this.m_next[i]\n\t}\n\n\treturn n\n}\n"
                    },
                    "GetFirst": {
                        "Name": "GetFirst",
                        "Code": "func (this *DtNodePool) GetFirst(bucket int) DtNodeIndex { return this.m_first[bucket] }\n"
                    },
                    "GetHashSize": {
                        "Name": "GetHashSize",
                        "Code": "func (this *DtNodePool) GetHashSize() uint32             { return this.m_hashSize }\n"
                    },
                    "GetMaxNodes": {
                        "Name": "GetMaxNodes",
                        "Code": "func (this *DtNodePool) GetMaxNodes() uint32             { return this.m_maxNodes }\n"
                    },
                    "GetMemUsed": {
                        "Name": "GetMemUsed",
                        "Code": "func (this *DtNodePool) GetMemUsed() uint32 {\n\treturn uint32(unsafe.Sizeof(*this)) +\n\t\tuint32(unsafe.Sizeof(\u0026this.m_nodes[0]))*this.m_maxNodes +\n\t\tuint32(unsafe.Sizeof(\u0026this.m_next[0]))*this.m_maxNodes +\n\t\tuint32(unsafe.Sizeof(\u0026this.m_first[0]))*this.m_hashSize\n}\n"
                    },
                    "GetNext": {
                        "Name": "GetNext",
                        "Code": "func (this *DtNodePool) GetNext(i int) DtNodeIndex       { return this.m_next[i] }\n"
                    },
                    "GetNode": {
                        "Name": "GetNode",
                        "Code": "func (this *DtNodePool) GetNode(id DtPolyRef, state uint8) *DtNode {\n\tbucket := DtHashRef(id) \u0026 (this.m_hashSize - 1)\n\ti := this.m_first[bucket]\n\tvar node *DtNode = nil\n\tfor i != DT_NULL_IDX {\n\t\tif this.m_nodes[i].Id == id \u0026\u0026 this.m_nodes[i].State == state {\n\t\t\treturn \u0026this.m_nodes[i]\n\t\t}\n\t\ti = this.m_next[i]\n\t}\n\n\tif this.m_nodeCount \u003e= this.m_maxNodes {\n\t\treturn nil\n\t}\n\n\ti = DtNodeIndex(this.m_nodeCount)\n\tthis.m_nodeCount++\n\n\t// Init node\n\tnode = \u0026this.m_nodes[i]\n\tnode.Pidx = 0\n\tnode.Cost = 0\n\tnode.Total = 0\n\tnode.Id = id\n\tnode.State = state\n\tnode.Flags = 0\n\n\tthis.m_next[i] = this.m_first[bucket]\n\tthis.m_first[bucket] = i\n\n\treturn node\n}\n"
                    },
                    "GetNodeAtIdx": {
                        "Name": "GetNodeAtIdx",
                        "Code": "func (this *DtNodePool) GetNodeAtIdx(idx uint32) *DtNode {\n\tif idx == 0 {\n\t\treturn nil\n\t}\n\treturn \u0026this.m_nodes[idx-1]\n}\n"
                    },
                    "GetNodeCount": {
                        "Name": "GetNodeCount",
                        "Code": "func (this *DtNodePool) GetNodeCount() uint32            { return this.m_nodeCount }\n"
                    },
                    "GetNodeIdx": {
                        "Name": "GetNodeIdx",
                        "Code": "func (this *DtNodePool) GetNodeIdx(node *DtNode) uint32 {\n\tif node == nil {\n\t\treturn 0\n\t}\n\tcurrent := uintptr(unsafe.Pointer(node))\n\treturn (uint32)(current-this.base)/sizeofNode + 1\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *DtNodePool) constructor(maxNodes, hashSize uint32) {\n\tthis.m_maxNodes = maxNodes\n\tthis.m_hashSize = hashSize\n\n\tDtAssert(DtNextPow2(this.m_hashSize) == this.m_hashSize)\n\t// pidx is special as 0 means \"none\" and 1 is the first node. For that reason\n\t// we have 1 fewer nodes available than the number of values it can contain.\n\tDtAssert(this.m_maxNodes \u003e 0 \u0026\u0026 this.m_maxNodes \u003c= uint32(DT_NULL_IDX) \u0026\u0026 this.m_maxNodes \u003c= (1\u003c\u003cDT_NODE_PARENT_BITS)-1)\n\n\tthis.m_nodes = make([]DtNode, this.m_maxNodes)\n\tthis.m_next = make([]DtNodeIndex, this.m_maxNodes)\n\tthis.m_first = make([]DtNodeIndex, this.m_hashSize)\n\n\tDtAssert(this.m_nodes != nil)\n\tDtAssert(this.m_next != nil)\n\tDtAssert(this.m_first != nil)\n\n\tfor i := 0; i \u003c len(this.m_first); i++ {\n\t\tthis.m_first[i] = DT_NULL_IDX\n\t}\n\tfor i := 0; i \u003c len(this.m_next); i++ {\n\t\tthis.m_next[i] = DT_NULL_IDX\n\t}\n\n\tthis.base = uintptr(unsafe.Pointer(\u0026(this.m_nodes[0])))\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtNodePool) destructor() {\n\tthis.m_nodes = nil\n\tthis.m_first = nil\n\tthis.m_next = nil\n}\n"
                    }
                }
            },
            "DtNodeQueue": {
                "Name": "DtNodeQueue",
                "Code": "type DtNodeQueue struct {\n\tm_heap     []*DtNode\n\tm_capacity int\n\tm_size     int\n}\n",
                "Methods": {
                    "Clear": {
                        "Name": "Clear",
                        "Code": "func (this *DtNodeQueue) Clear() { this.m_size = 0 }\n"
                    },
                    "Empty": {
                        "Name": "Empty",
                        "Code": "func (this *DtNodeQueue) Empty() bool { return this.m_size == 0 }\n"
                    },
                    "GetCapacity": {
                        "Name": "GetCapacity",
                        "Code": "func (this *DtNodeQueue) GetCapacity() int { return this.m_capacity }\n"
                    },
                    "GetMemUsed": {
                        "Name": "GetMemUsed",
                        "Code": "func (this *DtNodeQueue) GetMemUsed() uint32 {\n\treturn uint32(unsafe.Sizeof(*this)) +\n\t\tuint32(unsafe.Sizeof(\u0026this.m_heap[0]))*uint32(this.m_capacity+1)\n}\n"
                    },
                    "Modify": {
                        "Name": "Modify",
                        "Code": "func (this *DtNodeQueue) Modify(node *DtNode) {\n\tfor i := 0; i \u003c this.m_size; i++ {\n\t\tif this.m_heap[i] == node {\n\t\t\tthis.bubbleUp(i, node)\n\t\t\treturn\n\t\t}\n\t}\n}\n"
                    },
                    "Pop": {
                        "Name": "Pop",
                        "Code": "func (this *DtNodeQueue) Pop() *DtNode {\n\tresult := this.m_heap[0]\n\tthis.m_size--\n\tthis.trickleDown(0, this.m_heap[this.m_size])\n\treturn result\n}\n"
                    },
                    "Push": {
                        "Name": "Push",
                        "Code": "func (this *DtNodeQueue) Push(node *DtNode) {\n\tthis.m_size++\n\tthis.bubbleUp(this.m_size-1, node)\n}\n"
                    },
                    "Top": {
                        "Name": "Top",
                        "Code": "func (this *DtNodeQueue) Top() *DtNode { return this.m_heap[0] }\n"
                    },
                    "bubbleUp": {
                        "Name": "bubbleUp",
                        "Code": "func (this *DtNodeQueue) bubbleUp(i int, node *DtNode) {\n\tparent := (i - 1) / 2\n\t// note: (index \u003e 0) means there is a parent\n\tfor (i \u003e 0) \u0026\u0026 (this.m_heap[parent].Total \u003e node.Total) {\n\t\tthis.m_heap[i] = this.m_heap[parent]\n\t\ti = parent\n\t\tparent = (i - 1) / 2\n\t}\n\tthis.m_heap[i] = node\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *DtNodeQueue) constructor(n int) {\n\tthis.m_capacity = n\n\tDtAssert(this.m_capacity \u003e 0)\n\tthis.m_heap = make([]*DtNode, this.m_capacity+1)\n\tDtAssert(this.m_heap != nil)\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtNodeQueue) destructor() {\n\tthis.m_heap = nil\n}\n"
                    },
                    "trickleDown": {
                        "Name": "trickleDown",
                        "Code": "func (this *DtNodeQueue) trickleDown(i int, node *DtNode) {\n\tchild := (i * 2) + 1\n\tfor child \u003c this.m_size {\n\t\tif ((child + 1) \u003c this.m_size) \u0026\u0026\n\t\t\t(this.m_heap[child].Total \u003e this.m_heap[child+1].Total) {\n\t\t\tchild++\n\t\t}\n\t\tthis.m_heap[i] = this.m_heap[child]\n\t\ti = child\n\t\tchild = (i * 2) + 1\n\t}\n\tthis.bubbleUp(i, node)\n}\n"
                    }
                }
            },
            "DtOffMeshConnection": {
                "Name": "DtOffMeshConnection",
                "Code": "// / Defines an navigation mesh off-mesh connection within a dtMeshTile object.\n// / An off-mesh connection is a user defined traversable connection made up to two vertices.\ntype DtOffMeshConnection struct {\n\t/// The endpoints of the connection. [(ax, ay, az, bx, by, bz)]\n\tPos [6]float32\n\n\t/// The radius of the endpoints. [Limit: \u003e= 0]\n\tRad float32\n\n\t/// The polygon reference of the connection within the tile.\n\tPoly uint16\n\n\t/// Link flags.\n\t/// @note These are not the connection's user defined flags. Those are assigned via the\n\t/// connection's dtPoly definition. These are link flags used for internal purposes.\n\tFlags uint8\n\n\t/// End point side.\n\tSide uint8\n\n\t/// The id of the offmesh connection. (User assigned when the navigation mesh is built.)\n\tUserId uint32\n}\n",
                "Methods": {}
            },
            "DtPoly": {
                "Name": "DtPoly",
                "Code": "// / Defines a polygon within a dtMeshTile object.\n// / @ingroup detour\ntype DtPoly struct {\n\t/// Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)\n\tFirstLink uint32\n\n\t/// The indices of the polygon's vertices.\n\t/// The actual vertices are located in dtMeshTile::verts.\n\tVerts [DT_VERTS_PER_POLYGON]uint16\n\n\t/// Packed data representing neighbor polygons references and flags for each edge.\n\tNeis [DT_VERTS_PER_POLYGON]uint16\n\n\t/// The user defined polygon flags.\n\tFlags uint16\n\n\t/// The number of vertices in the polygon.\n\tVertCount uint8\n\n\t/// The bit packed area id and polygon type.\n\t/// @note Use the structure's set and get methods to acess this value.\n\tAreaAndtype uint8\n}\n",
                "Methods": {
                    "GetArea": {
                        "Name": "GetArea",
                        "Code": "func (this *DtPoly) GetArea() uint8 { return this.AreaAndtype \u0026 0x3f }\n"
                    },
                    "GetType": {
                        "Name": "GetType",
                        "Code": "func (this *DtPoly) GetType() DtPolyTypes { return DtPolyTypes(this.AreaAndtype \u003e\u003e 6) }\n"
                    },
                    "SetArea": {
                        "Name": "SetArea",
                        "Code": "func (this *DtPoly) SetArea(a uint8) { this.AreaAndtype = (this.AreaAndtype \u0026 0xc0) | (a \u0026 0x3f) }\n"
                    },
                    "SetType": {
                        "Name": "SetType",
                        "Code": "func (this *DtPoly) SetType(t DtPolyTypes) {\n\tthis.AreaAndtype = (this.AreaAndtype \u0026 0x3f) | (uint8(t) \u003c\u003c 6)\n}\n"
                    }
                }
            },
            "DtPolyDetail": {
                "Name": "DtPolyDetail",
                "Code": "// / Defines the location of detail sub-mesh data within a dtMeshTile.\ntype DtPolyDetail struct {\n\tVertBase  uint32 ///\u003c The offset of the vertices in the dtMeshTile::detailVerts array.\n\tTriBase   uint32 ///\u003c The offset of the triangles in the dtMeshTile::detailTris array.\n\tVertCount uint8  ///\u003c The number of vertices in the sub-mesh.\n\tTriCount  uint8  ///\u003c The number of triangles in the sub-mesh.\n}\n",
                "Methods": {}
            },
            "DtPolyQuery": {
                "Name": "DtPolyQuery",
                "Code": "// / Provides custom polygon query behavior.\n// / Used by dtNavMeshQuery::queryPolygons.\n// / @ingroup detour\ntype DtPolyQuery interface {\n\t/// Called for each batch of unique polygons touched by the search area in dtNavMeshQuery::queryPolygons.\n\t/// This can be called multiple times for a single query.\n\tProcess(tile *DtMeshTile, polys []*DtPoly, refs []DtPolyRef, count int)\n}\n",
                "Methods": {}
            },
            "DtPolyRef": {
                "Name": "DtPolyRef",
                "Code": "// / A handle to a polygon within a navigation mesh tile.\n// / @ingroup detour\ntype DtPolyRef uint32\n",
                "Methods": {}
            },
            "DtPolyTypes": {
                "Name": "DtPolyTypes",
                "Code": "// / Flags representing the type of a navigation mesh polygon.\ntype DtPolyTypes uint8\n",
                "Methods": {}
            },
            "DtQueryFilter": {
                "Name": "DtQueryFilter",
                "Code": "// / Defines polygon filtering and traversal costs for navigation mesh query operations.\n// / @ingroup detour\ntype DtQueryFilter struct {\n\tm_areaCost     [DT_MAX_AREAS]float32 ///\u003c Cost per area type. (Used by default implementation.)\n\tm_includeFlags uint16                ///\u003c Flags for polygons that can be visited. (Used by default implementation.)\n\tm_excludeFlags uint16                ///\u003c Flags for polygons that should not be visted. (Used by default implementation.)\n}\n",
                "Methods": {
                    "GetAreaCost": {
                        "Name": "GetAreaCost",
                        "Code": "func (this *DtQueryFilter) GetAreaCost(i int) float32 { return this.m_areaCost[i] }\n"
                    },
                    "GetCost": {
                        "Name": "GetCost",
                        "Code": "func (this *DtQueryFilter) GetCost(pa, pb []float32,\n\t_ DtPolyRef, _ *DtMeshTile, _ *DtPoly,\n\t_ DtPolyRef, _ *DtMeshTile, curPoly *DtPoly,\n\t_ DtPolyRef, _ *DtMeshTile, _ *DtPoly) float32 {\n\treturn DtVdist(pa, pb) * this.m_areaCost[curPoly.GetArea()]\n}\n"
                    },
                    "GetExcludeFlags": {
                        "Name": "GetExcludeFlags",
                        "Code": "func (this *DtQueryFilter) GetExcludeFlags() uint16 { return this.m_excludeFlags }\n"
                    },
                    "GetIncludeFlags": {
                        "Name": "GetIncludeFlags",
                        "Code": "func (this *DtQueryFilter) GetIncludeFlags() uint16 { return this.m_includeFlags }\n"
                    },
                    "PassFilter": {
                        "Name": "PassFilter",
                        "Code": "func (this *DtQueryFilter) PassFilter(_ DtPolyRef, _ *DtMeshTile, poly *DtPoly) bool {\n\treturn (poly.Flags\u0026this.m_includeFlags) != 0 \u0026\u0026 (poly.Flags\u0026this.m_excludeFlags) == 0\n}\n"
                    },
                    "Reset": {
                        "Name": "Reset",
                        "Code": "func (this *DtQueryFilter) Reset() {\n\tthis.constructor()\n}\n"
                    },
                    "SetAreaCost": {
                        "Name": "SetAreaCost",
                        "Code": "func (this *DtQueryFilter) SetAreaCost(i int, cost float32) { this.m_areaCost[i] = cost }\n"
                    },
                    "SetExcludeFlags": {
                        "Name": "SetExcludeFlags",
                        "Code": "func (this *DtQueryFilter) SetExcludeFlags(flags uint16) { this.m_excludeFlags = flags }\n"
                    },
                    "SetIncludeFlags": {
                        "Name": "SetIncludeFlags",
                        "Code": "func (this *DtQueryFilter) SetIncludeFlags(flags uint16) { this.m_includeFlags = flags }\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *DtQueryFilter) constructor() {\n\tthis.m_includeFlags = 0xffff\n\tthis.m_excludeFlags = 0\n\tfor i := 0; i \u003c DT_MAX_AREAS; i++ {\n\t\tthis.m_areaCost[i] = 1.0\n\t}\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtQueryFilter) destructor() {\n}\n"
                    }
                }
            },
            "DtRaycastHit": {
                "Name": "DtRaycastHit",
                "Code": "// / Provides information about raycast hit\n// / filled by dtNavMeshQuery::raycast\n// / @ingroup detour\ntype DtRaycastHit struct {\n\t/// The hit parameter. (FLT_MAX if no wall hit.)\n\tT float32\n\n\t/// hitNormal\tThe normal of the nearest wall hit. [(x, y, z)]\n\tHitNormal [3]float32\n\n\t/// The index of the edge on the final polygon where the wall was hit.\n\tHitEdgeIndex int32\n\n\t/// Pointer to an array of reference ids of the visited polygons. [opt]\n\tPath []DtPolyRef\n\n\t/// The number of visited polygons. [opt]\n\tPathCount int32\n\n\t/// The maximum number of polygons the @p path array can hold.\n\tMaxPath int32\n\n\t///  The cost of the path until hit.\n\tPathCost float32\n}\n",
                "Methods": {}
            },
            "DtRaycastOptions": {
                "Name": "DtRaycastOptions",
                "Code": "// / Options for dtNavMeshQuery::raycast\ntype DtRaycastOptions int\n",
                "Methods": {}
            },
            "DtStatus": {
                "Name": "DtStatus",
                "Code": "type DtStatus uint\n",
                "Methods": {}
            },
            "DtStraightPathFlags": {
                "Name": "DtStraightPathFlags",
                "Code": "// / Vertex flags returned by dtNavMeshQuery::findStraightPath.\ntype DtStraightPathFlags uint8\n",
                "Methods": {}
            },
            "DtStraightPathOptions": {
                "Name": "DtStraightPathOptions",
                "Code": "// / Options for dtNavMeshQuery::findStraightPath.\ntype DtStraightPathOptions int\n",
                "Methods": {}
            },
            "DtTileFlags": {
                "Name": "DtTileFlags",
                "Code": "// / Tile flags used for various functions and fields.\n// / For an example, see dtNavMesh::addTile().\ntype DtTileFlags int\n",
                "Methods": {}
            },
            "DtTileRef": {
                "Name": "DtTileRef",
                "Code": "// / A handle to a tile within a navigation mesh.\n// / @ingroup detour\ntype DtTileRef uint32\n",
                "Methods": {}
            },
            "dtCollectPolysQuery": {
                "Name": "dtCollectPolysQuery",
                "Code": "type dtCollectPolysQuery struct {\n\tm_polys        []DtPolyRef\n\tm_maxPolys     int\n\tm_numCollected int\n\tm_overflow     bool\n}\n",
                "Methods": {
                    "Process": {
                        "Name": "Process",
                        "Code": "func (this *dtCollectPolysQuery) Process(tile *DtMeshTile, polys []*DtPoly, refs []DtPolyRef, count int) {\n\t//dtIgnoreUnused(tile);\n\t//dtIgnoreUnused(polys);\n\tnumLeft := this.m_maxPolys - this.m_numCollected\n\ttoCopy := count\n\tif toCopy \u003e numLeft {\n\t\tthis.m_overflow = true\n\t\ttoCopy = numLeft\n\t}\n\tcopy(this.m_polys[this.m_numCollected:], refs[0:toCopy])\n\tthis.m_numCollected += toCopy\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *dtCollectPolysQuery) constructor(polys []DtPolyRef, maxPolys int) {\n\tthis.m_polys = polys\n\tthis.m_maxPolys = maxPolys\n}\n"
                    },
                    "numCollected": {
                        "Name": "numCollected",
                        "Code": "func (this *dtCollectPolysQuery) numCollected() int { return this.m_numCollected }\n"
                    },
                    "overflowed": {
                        "Name": "overflowed",
                        "Code": "func (this *dtCollectPolysQuery) overflowed() bool  { return this.m_overflow }\n"
                    }
                }
            },
            "dtFindNearestPolyQuery": {
                "Name": "dtFindNearestPolyQuery",
                "Code": "type dtFindNearestPolyQuery struct {\n\tm_query              *DtNavMeshQuery\n\tm_center             []float32\n\tm_nearestDistanceSqr float32\n\tm_nearestRef         DtPolyRef\n\tm_nearestPoint       [3]float32\n}\n",
                "Methods": {
                    "Process": {
                        "Name": "Process",
                        "Code": "func (this *dtFindNearestPolyQuery) Process(tile *DtMeshTile, polys []*DtPoly, refs []DtPolyRef, count int) {\n\t//DtIgnoreUnused(polys);\n\tfor i := 0; i \u003c count; i++ {\n\t\tref := refs[i]\n\t\tvar closestPtPoly [3]float32\n\t\tvar diff [3]float32\n\t\tposOverPoly := false\n\t\tvar d float32\n\t\tthis.m_query.ClosestPointOnPoly(ref, this.m_center, closestPtPoly[:], \u0026posOverPoly)\n\n\t\t// If a point is directly over a polygon and closer than\n\t\t// climb height, favor that instead of straight line nearest point.\n\t\tDtVsub(diff[:], this.m_center, closestPtPoly[:])\n\t\tif posOverPoly {\n\t\t\td = DtAbsFloat32(diff[1]) - tile.Header.WalkableClimb\n\t\t\tif d \u003e 0 {\n\t\t\t\td = d * d\n\t\t\t} else {\n\t\t\t\td = 0\n\t\t\t}\n\t\t} else {\n\t\t\td = DtVlenSqr(diff[:])\n\t\t}\n\n\t\tif d \u003c this.m_nearestDistanceSqr {\n\t\t\tDtVcopy(this.m_nearestPoint[:], closestPtPoly[:])\n\n\t\t\tthis.m_nearestDistanceSqr = d\n\t\t\tthis.m_nearestRef = ref\n\t\t}\n\t}\n}\n"
                    },
                    "constructor": {
                        "Name": "constructor",
                        "Code": "func (this *dtFindNearestPolyQuery) constructor(query *DtNavMeshQuery, center []float32) {\n\tthis.m_query = query\n\tthis.m_center = center\n\tthis.m_nearestDistanceSqr = float32(math.MaxFloat32)\n}\n"
                    },
                    "nearestPoint": {
                        "Name": "nearestPoint",
                        "Code": "func (this *dtFindNearestPolyQuery) nearestPoint() []float32 { return this.m_nearestPoint[:] }\n"
                    },
                    "nearestRef": {
                        "Name": "nearestRef",
                        "Code": "func (this *dtFindNearestPolyQuery) nearestRef() DtPolyRef   { return this.m_nearestRef }\n"
                    }
                }
            },
            "dtPolyState": {
                "Name": "dtPolyState",
                "Code": "type dtPolyState struct {\n\tflags uint16 // Flags (see dtPolyFlags).\n\tarea  uint8  // Area ID of the polygon.\n}\n",
                "Methods": {}
            },
            "dtQueryData": {
                "Name": "dtQueryData",
                "Code": "type dtQueryData struct {\n\tstatus           DtStatus\n\tlastBestNode     *DtNode\n\tlastBestNodeCost float32\n\tstartRef         DtPolyRef\n\tendRef           DtPolyRef\n\tstartPos         [3]float32\n\tendPos           [3]float32\n\tfilter           *DtQueryFilter\n\toptions          DtFindPathOptions\n\traycastLimitSqr  float32\n}\n",
                "Methods": {}
            },
            "dtSegInterval": {
                "Name": "dtSegInterval",
                "Code": "type dtSegInterval struct {\n\tref        DtPolyRef\n\ttmin, tmax int16\n}\n",
                "Methods": {}
            },
            "dtTileState": {
                "Name": "dtTileState",
                "Code": "type dtTileState struct {\n\tmagic   int32     // Magic number, used to identify the data.\n\tversion int32     // Data version number.\n\tref     DtTileRef // Tile ref at the time of storing the data.\n}\n",
                "Methods": {}
            },
            "sorter": {
                "Name": "sorter",
                "Code": "type sorter struct {\n\tlst      []BVItem\n\tcompFunc func(a, b *BVItem) bool\n}\n",
                "Methods": {
                    "Len": {
                        "Name": "Len",
                        "Code": "func (this *sorter) Len() int {\n\treturn len(this.lst)\n}\n"
                    },
                    "Less": {
                        "Name": "Less",
                        "Code": "func (this *sorter) Less(i, j int) bool {\n\treturn this.compFunc(\u0026this.lst[i], \u0026this.lst[j])\n}\n"
                    },
                    "Swap": {
                        "Name": "Swap",
                        "Code": "func (this *sorter) Swap(i, j int) {\n\tthis.lst[i], this.lst[j] = this.lst[j], this.lst[i]\n}\n"
                    }
                }
            }
        },
        "Functions": {
            "DtAbsFloat32": {
                "Name": "DtAbsFloat32",
                "Code": "func DtAbsFloat32(a float32) float32 {\n\tif a \u003c 0 {\n\t\treturn -a\n\t} else {\n\t\treturn a\n\t}\n}\n"
            },
            "DtAbsInt16": {
                "Name": "DtAbsInt16",
                "Code": "func DtAbsInt16(a int16) int16 {\n\tif a \u003c 0 {\n\t\treturn -a\n\t} else {\n\t\treturn a\n\t}\n}\n"
            },
            "DtAbsInt32": {
                "Name": "DtAbsInt32",
                "Code": "func DtAbsInt32(a int32) int32 {\n\tif a \u003c 0 {\n\t\treturn -a\n\t} else {\n\t\treturn a\n\t}\n}\n"
            },
            "DtAlign4": {
                "Name": "DtAlign4",
                "Code": "func DtAlign4(x int) int { return (x + 3) \u0026 ^3 }\n"
            },
            "DtAllocDtQueryFilter": {
                "Name": "DtAllocDtQueryFilter",
                "Code": "func DtAllocDtQueryFilter() *DtQueryFilter {\n\tfilter := \u0026DtQueryFilter{}\n\tfilter.constructor()\n\treturn filter\n}\n"
            },
            "DtAllocNavMesh": {
                "Name": "DtAllocNavMesh",
                "Code": "func DtAllocNavMesh() *DtNavMesh {\n\tnavmesh := \u0026DtNavMesh{}\n\tnavmesh.constructor()\n\treturn navmesh\n}\n"
            },
            "DtAllocNavMeshQuery": {
                "Name": "DtAllocNavMeshQuery",
                "Code": "func DtAllocNavMeshQuery() *DtNavMeshQuery {\n\tquery := \u0026DtNavMeshQuery{}\n\tquery.constructor()\n\treturn query\n}\n"
            },
            "DtAllocNodePool": {
                "Name": "DtAllocNodePool",
                "Code": "func DtAllocNodePool(maxNodes, hashSize uint32) *DtNodePool {\n\tpool := \u0026DtNodePool{}\n\tpool.constructor(maxNodes, hashSize)\n\treturn pool\n}\n"
            },
            "DtAllocNodeQueue": {
                "Name": "DtAllocNodeQueue",
                "Code": "func DtAllocNodeQueue(n int) *DtNodeQueue {\n\tqueue := \u0026DtNodeQueue{}\n\tqueue.constructor(n)\n\treturn queue\n}\n"
            },
            "DtAssert": {
                "Name": "DtAssert",
                "Code": "func DtAssert(expression bool) {\n}\n"
            },
            "DtAssertFailGetCustom": {
                "Name": "DtAssertFailGetCustom",
                "Code": "func DtAssertFailGetCustom() DtAssertFailFunc {\n\treturn nil\n}\n"
            },
            "DtAssertFailSetCustom": {
                "Name": "DtAssertFailSetCustom",
                "Code": "func DtAssertFailSetCustom(assertFailFunc DtAssertFailFunc) {\n}\n"
            },
            "DtCalcPolyCenter": {
                "Name": "DtCalcPolyCenter",
                "Code": "func DtCalcPolyCenter(tc []float32, idx []uint16, nidx int, verts []float32) {\n\ttc[0] = 0.0\n\ttc[1] = 0.0\n\ttc[2] = 0.0\n\tfor j := 0; j \u003c nidx; j++ {\n\t\tv := verts[idx[j]*3:]\n\t\ttc[0] += v[0]\n\t\ttc[1] += v[1]\n\t\ttc[2] += v[2]\n\t}\n\ts := 1.0 / float32(nidx)\n\ttc[0] *= s\n\ttc[1] *= s\n\ttc[2] *= s\n}\n"
            },
            "DtClampFloat32": {
                "Name": "DtClampFloat32",
                "Code": "func DtClampFloat32(v, mn, mx float32) float32 {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClampInt": {
                "Name": "DtClampInt",
                "Code": "func DtClampInt(v, mn, mx int) int {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClampInt16": {
                "Name": "DtClampInt16",
                "Code": "func DtClampInt16(v, mn, mx int16) int16 {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClampInt32": {
                "Name": "DtClampInt32",
                "Code": "func DtClampInt32(v, mn, mx int32) int32 {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClampUInt16": {
                "Name": "DtClampUInt16",
                "Code": "func DtClampUInt16(v, mn, mx uint16) uint16 {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClampUInt32": {
                "Name": "DtClampUInt32",
                "Code": "func DtClampUInt32(v, mn, mx uint32) uint32 {\n\tif v \u003c mn {\n\t\treturn mn\n\t} else {\n\t\tif v \u003e mx {\n\t\t\treturn mx\n\t\t} else {\n\t\t\treturn v\n\t\t}\n\t}\n}\n"
            },
            "DtClosestHeightPointTriangle": {
                "Name": "DtClosestHeightPointTriangle",
                "Code": "func DtClosestHeightPointTriangle(p, a, b, c []float32, h *float32) bool {\n\tv0 := [3]float32{}\n\tv1 := [3]float32{}\n\tv2 := [3]float32{}\n\tDtVsub(v0[:], c, a)\n\tDtVsub(v1[:], b, a)\n\tDtVsub(v2[:], p, a)\n\n\tdot00 := DtVdot2D(v0[:], v0[:])\n\tdot01 := DtVdot2D(v0[:], v1[:])\n\tdot02 := DtVdot2D(v0[:], v2[:])\n\tdot11 := DtVdot2D(v1[:], v1[:])\n\tdot12 := DtVdot2D(v1[:], v2[:])\n\n\t// Compute barycentric coordinates\n\tinvDenom := 1.0 / (dot00*dot11 - dot01*dot01)\n\tu := (dot11*dot02 - dot01*dot12) * invDenom\n\tv := (dot00*dot12 - dot01*dot02) * invDenom\n\n\t// The (sloppy) epsilon is needed to allow to get height of points which\n\t// are interpolated along the edges of the triangles.\n\t//\tstatic const float EPS = 1e-4f;\n\n\t// If point lies inside the triangle, return interpolated ycoord.\n\tif u \u003e= -EPS \u0026\u0026 v \u003e= -EPS \u0026\u0026 (u+v) \u003c= 1+EPS {\n\t\t*h = a[1] + v0[1]*u + v1[1]*v\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
            },
            "DtClosestPtPointTriangle": {
                "Name": "DtClosestPtPointTriangle",
                "Code": "func DtClosestPtPointTriangle(closest, p, a, b, c []float32) {\n\t// Check if P in vertex region outside A\n\tab := [3]float32{}\n\tac := [3]float32{}\n\tap := [3]float32{}\n\tDtVsub(ab[:], b, a)\n\tDtVsub(ac[:], c, a)\n\tDtVsub(ap[:], p, a)\n\td1 := DtVdot(ab[:], ap[:])\n\td2 := DtVdot(ac[:], ap[:])\n\tif d1 \u003c= 0.0 \u0026\u0026 d2 \u003c= 0.0 {\n\t\t// barycentric coordinates (1,0,0)\n\t\tDtVcopy(closest, a)\n\t\treturn\n\t}\n\n\t// Check if P in vertex region outside B\n\tbp := [3]float32{}\n\tDtVsub(bp[:], p, b)\n\td3 := DtVdot(ab[:], bp[:])\n\td4 := DtVdot(ac[:], bp[:])\n\tif d3 \u003e= 0.0 \u0026\u0026 d4 \u003c= d3 {\n\t\t// barycentric coordinates (0,1,0)\n\t\tDtVcopy(closest, b)\n\t\treturn\n\t}\n\n\t// Check if P in edge region of AB, if so return projection of P onto AB\n\tvc := d1*d4 - d3*d2\n\tif vc \u003c= 0.0 \u0026\u0026 d1 \u003e= 0.0 \u0026\u0026 d3 \u003c= 0.0 {\n\t\t// barycentric coordinates (1-v,v,0)\n\t\tv := d1 / (d1 - d3)\n\t\tclosest[0] = a[0] + v*ab[0]\n\t\tclosest[1] = a[1] + v*ab[1]\n\t\tclosest[2] = a[2] + v*ab[2]\n\t\treturn\n\t}\n\n\t// Check if P in vertex region outside C\n\tcp := [3]float32{}\n\tDtVsub(cp[:], p, c)\n\td5 := DtVdot(ab[:], cp[:])\n\td6 := DtVdot(ac[:], cp[:])\n\tif d6 \u003e= 0.0 \u0026\u0026 d5 \u003c= d6 {\n\t\t// barycentric coordinates (0,0,1)\n\t\tDtVcopy(closest, c)\n\t\treturn\n\t}\n\n\t// Check if P in edge region of AC, if so return projection of P onto AC\n\tvb := d5*d2 - d1*d6\n\tif vb \u003c= 0.0 \u0026\u0026 d2 \u003e= 0.0 \u0026\u0026 d6 \u003c= 0.0 {\n\t\t// barycentric coordinates (1-w,0,w)\n\t\tw := d2 / (d2 - d6)\n\t\tclosest[0] = a[0] + w*ac[0]\n\t\tclosest[1] = a[1] + w*ac[1]\n\t\tclosest[2] = a[2] + w*ac[2]\n\t\treturn\n\t}\n\n\t// Check if P in edge region of BC, if so return projection of P onto BC\n\tva := d3*d6 - d5*d4\n\tif va \u003c= 0.0 \u0026\u0026 (d4-d3) \u003e= 0.0 \u0026\u0026 (d5-d6) \u003e= 0.0 {\n\t\t// barycentric coordinates (0,1-w,w)\n\t\tw := (d4 - d3) / ((d4 - d3) + (d5 - d6))\n\t\tclosest[0] = b[0] + w*(c[0]-b[0])\n\t\tclosest[1] = b[1] + w*(c[1]-b[1])\n\t\tclosest[2] = b[2] + w*(c[2]-b[2])\n\t\treturn\n\t}\n\n\t// P inside face region. Compute Q through its barycentric coordinates (u,v,w)\n\tdenom := 1.0 / (va + vb + vc)\n\tv := vb * denom\n\tw := vc * denom\n\tclosest[0] = a[0] + ab[0]*v + ac[0]*w\n\tclosest[1] = a[1] + ab[1]*v + ac[1]*w\n\tclosest[2] = a[2] + ab[2]*v + ac[2]*w\n}\n"
            },
            "DtCreateNavMeshData": {
                "Name": "DtCreateNavMeshData",
                "Code": "func DtCreateNavMeshData(params *DtNavMeshCreateParams, outData *[]byte, outDataSize *int) bool {\n\tif params.Nvp \u003e DT_VERTS_PER_POLYGON {\n\t\treturn false\n\t}\n\tif params.VertCount \u003e= 0xffff {\n\t\treturn false\n\t}\n\tif params.VertCount == 0 || params.Verts == nil {\n\t\treturn false\n\t}\n\tif params.PolyCount == 0 || params.Polys == nil {\n\t\treturn false\n\t}\n\tnvp := int(params.Nvp)\n\n\t// Classify off-mesh connection points. We store only the connections\n\t// whose start point is inside the tile.\n\tvar offMeshConClass []byte\n\tvar storedOffMeshConCount int\n\tvar offMeshConLinkCount int\n\n\tif params.OffMeshConCount \u003e 0 {\n\t\toffMeshConClass = make([]byte, params.OffMeshConCount*2)\n\t\tif offMeshConClass == nil {\n\t\t\treturn false\n\t\t}\n\t\t// Find tight heigh bounds, used for culling out off-mesh start locations.\n\t\thmin := float32(math.MaxFloat32)\n\t\thmax := -float32(math.MaxFloat32)\n\n\t\tif params.DetailVerts != nil \u0026\u0026 params.DetailVertsCount != 0 {\n\t\t\tfor i := 0; i \u003c int(params.DetailVertsCount); i++ {\n\t\t\t\th := params.DetailVerts[i*3+1]\n\t\t\t\thmin = DtMinFloat32(hmin, h)\n\t\t\t\thmax = DtMaxFloat32(hmax, h)\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := 0; i \u003c int(params.VertCount); i++ {\n\t\t\t\tiv := params.Verts[i*3:]\n\t\t\t\th := params.Bmin[1] + float32(iv[1])*params.Ch\n\t\t\t\thmin = DtMinFloat32(hmin, h)\n\t\t\t\thmax = DtMaxFloat32(hmax, h)\n\t\t\t}\n\t\t}\n\t\thmin -= params.WalkableClimb\n\t\thmax += params.WalkableClimb\n\t\tvar bmin, bmax [3]float32\n\t\tDtVcopy(bmin[:], params.Bmin[:])\n\t\tDtVcopy(bmax[:], params.Bmax[:])\n\t\tbmin[1] = hmin\n\t\tbmax[1] = hmax\n\n\t\tfor i := 0; i \u003c int(params.OffMeshConCount); i++ {\n\t\t\tp0 := params.OffMeshConVerts[(i*2+0)*3:]\n\t\t\tp1 := params.OffMeshConVerts[(i*2+1)*3:]\n\t\t\toffMeshConClass[i*2+0] = classifyOffMeshPoint(p0, bmin[:], bmax[:])\n\t\t\toffMeshConClass[i*2+1] = classifyOffMeshPoint(p1, bmin[:], bmax[:])\n\n\t\t\t// Zero out off-mesh start positions which are not even potentially touching the mesh.\n\t\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\t\tif p0[1] \u003c bmin[1] || p0[1] \u003e bmax[1] {\n\t\t\t\t\toffMeshConClass[i*2+0] = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cound how many links should be allocated for off-mesh connections.\n\t\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\t\toffMeshConLinkCount++\n\t\t\t}\n\t\t\tif offMeshConClass[i*2+1] == 0xff {\n\t\t\t\toffMeshConLinkCount++\n\t\t\t}\n\t\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\t\tstoredOffMeshConCount++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Off-mesh connectionss are stored as polygons, adjust values.\n\ttotPolyCount := int(params.PolyCount) + storedOffMeshConCount\n\ttotVertCount := int(params.VertCount) + storedOffMeshConCount*2\n\n\t// Find portal edges which are at tile borders.\n\tedgeCount := 0\n\tportalCount := 0\n\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\tp := params.Polys[i*2*nvp:]\n\t\tfor j := 0; j \u003c nvp; j++ {\n\t\t\tif p[j] == MESH_NULL_IDX {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tedgeCount++\n\n\t\t\tif (p[nvp+j] \u0026 0x8000) != 0 {\n\t\t\t\tdir := p[nvp+j] \u0026 0xf\n\t\t\t\tif dir != 0xf {\n\t\t\t\t\tportalCount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmaxLinkCount := edgeCount + portalCount*2 + offMeshConLinkCount*2\n\n\t// Find unique detail vertices.\n\tuniqueDetailVertCount := 0\n\tdetailTriCount := 0\n\tif params.DetailMeshes != nil {\n\t\t// Has detail mesh, count unique detail vertex count and use input detail tri count.\n\t\tdetailTriCount = int(params.DetailTriCount)\n\t\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\t\tp := params.Polys[i*nvp*2:]\n\t\t\tndv := int(params.DetailMeshes[i*4+1])\n\t\t\tnv := 0\n\t\t\tfor j := 0; j \u003c nvp; j++ {\n\t\t\t\tif p[j] == MESH_NULL_IDX {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tnv++\n\t\t\t}\n\t\t\tndv -= nv\n\t\t\tuniqueDetailVertCount += ndv\n\t\t}\n\t} else {\n\t\t// No input detail mesh, build detail mesh from nav polys.\n\t\tuniqueDetailVertCount = 0 // No extra detail verts.\n\t\tdetailTriCount = 0\n\t\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\t\tp := params.Polys[i*nvp*2:]\n\t\t\tnv := 0\n\t\t\tfor j := 0; j \u003c nvp; j++ {\n\t\t\t\tif p[j] == MESH_NULL_IDX {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tnv++\n\t\t\t}\n\t\t\tdetailTriCount += nv - 2\n\t\t}\n\t}\n\n\t// Calculate data size\n\theaderSize := DtAlign4(int(unsafe.Sizeof(DtMeshHeader{})))\n\tvertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(totVertCount))\n\tpolysSize := DtAlign4(int(unsafe.Sizeof(DtPoly{})) * int(totPolyCount))\n\tlinksSize := DtAlign4(int(unsafe.Sizeof(DtLink{})) * int(maxLinkCount))\n\tdetailMeshesSize := DtAlign4(int(unsafe.Sizeof(DtPolyDetail{})) * int(params.PolyCount))\n\tdetailVertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(uniqueDetailVertCount))\n\tdetailTrisSize := DtAlign4(int(unsafe.Sizeof(uint8(1))) * 4 * int(detailTriCount))\n\tbvTreeSize := 0\n\tif params.BuildBvTree {\n\t\tbvTreeSize = DtAlign4(int(unsafe.Sizeof(DtBVNode{})) * int(params.PolyCount*2))\n\t}\n\toffMeshConsSize := DtAlign4(int(unsafe.Sizeof(DtOffMeshConnection{})) * int(storedOffMeshConCount))\n\n\tdataSize := headerSize + vertsSize + polysSize + linksSize +\n\t\tdetailMeshesSize + detailVertsSize + detailTrisSize +\n\t\tbvTreeSize + offMeshConsSize\n\n\tdata := make([]byte, dataSize)\n\tif data == nil {\n\t\toffMeshConClass = nil\n\t\treturn false\n\t}\n\n\td := 0\n\n\theader := (*DtMeshHeader)(unsafe.Pointer(\u0026(data[d])))\n\td += headerSize\n\n\tvar navVerts []float32\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026navVerts)))\n\tsliceHeader.Cap = 3 * int(totVertCount)\n\tsliceHeader.Len = 3 * int(totVertCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += vertsSize\n\n\tvar navPolys []DtPoly\n\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026navPolys)))\n\tsliceHeader.Cap = int(totPolyCount)\n\tsliceHeader.Len = int(totPolyCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += polysSize\n\n\td += linksSize // Ignore links; just leave enough space for them. They'll be created on load.\n\n\tvar navDMeshes []DtPolyDetail\n\tif params.PolyCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026navDMeshes)))\n\t\tsliceHeader.Cap = int(params.PolyCount)\n\t\tsliceHeader.Len = int(params.PolyCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailMeshesSize\n\t}\n\n\tvar navDVerts []float32\n\tif uniqueDetailVertCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026navDVerts)))\n\t\tsliceHeader.Cap = 3 * int(uniqueDetailVertCount)\n\t\tsliceHeader.Len = 3 * int(uniqueDetailVertCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailVertsSize\n\t}\n\n\tvar navDTris []uint8\n\tif detailTriCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026navDTris)))\n\t\tsliceHeader.Cap = 4 * int(detailTriCount)\n\t\tsliceHeader.Len = 4 * int(detailTriCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailTrisSize\n\t}\n\n\tvar navBvtree []DtBVNode\n\tif params.BuildBvTree \u0026\u0026 params.PolyCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026navBvtree)))\n\t\tsliceHeader.Cap = int(params.PolyCount * 2)\n\t\tsliceHeader.Len = int(params.PolyCount * 2)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += bvTreeSize\n\t}\n\n\tvar offMeshCons []DtOffMeshConnection\n\tif storedOffMeshConCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026offMeshCons)))\n\t\tsliceHeader.Cap = int(storedOffMeshConCount)\n\t\tsliceHeader.Len = int(storedOffMeshConCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += offMeshConsSize\n\t}\n\n\t// Store header\n\theader.Magic = DT_NAVMESH_MAGIC\n\theader.Version = DT_NAVMESH_VERSION\n\theader.X = params.TileX\n\theader.Y = params.TileY\n\theader.Layer = params.TileLayer\n\theader.UserId = params.UserId\n\theader.PolyCount = int32(totPolyCount)\n\theader.VertCount = int32(totVertCount)\n\theader.MaxLinkCount = int32(maxLinkCount)\n\tDtVcopy(header.Bmin[:], params.Bmin[:])\n\tDtVcopy(header.Bmax[:], params.Bmax[:])\n\theader.DetailMeshCount = params.PolyCount\n\theader.DetailVertCount = int32(uniqueDetailVertCount)\n\theader.DetailTriCount = int32(detailTriCount)\n\theader.BvQuantFactor = 1.0 / float32(params.Cs)\n\theader.OffMeshBase = params.PolyCount\n\theader.WalkableHeight = params.WalkableHeight\n\theader.WalkableRadius = params.WalkableRadius\n\theader.WalkableClimb = params.WalkableClimb\n\theader.OffMeshConCount = int32(storedOffMeshConCount)\n\tif params.BuildBvTree {\n\t\theader.BvNodeCount = params.PolyCount * 2\n\t} else {\n\t\theader.BvNodeCount = 0\n\t}\n\n\toffMeshVertsBase := params.VertCount\n\toffMeshPolyBase := params.PolyCount\n\n\t// Store vertices\n\t// Mesh vertices\n\tfor i := 0; i \u003c int(params.VertCount); i++ {\n\t\tiv := params.Verts[i*3:]\n\t\tv := navVerts[i*3:]\n\t\tv[0] = params.Bmin[0] + float32(iv[0])*params.Cs\n\t\tv[1] = params.Bmin[1] + float32(iv[1])*params.Ch\n\t\tv[2] = params.Bmin[2] + float32(iv[2])*params.Cs\n\t}\n\t// Off-mesh link vertices.\n\tn := 0\n\tfor i := 0; i \u003c int(params.OffMeshConCount); i++ {\n\t\t// Only store connections which start from this tile.\n\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\tlinkv := params.OffMeshConVerts[i*2*3:]\n\t\t\tv := navVerts[(int(offMeshVertsBase)+n*2)*3:]\n\t\t\tDtVcopy(v[0:], linkv[0:])\n\t\t\tDtVcopy(v[3:], linkv[3:])\n\t\t\tn++\n\t\t}\n\t}\n\n\t// Store polygons\n\t// Mesh polys\n\tsrcIndex := 0\n\tsrc := params.Polys[srcIndex:]\n\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\tp := \u0026navPolys[i]\n\t\tp.VertCount = 0\n\t\tp.Flags = params.PolyFlags[i]\n\t\tp.SetArea(params.PolyAreas[i])\n\t\tp.SetType(DT_POLYTYPE_GROUND)\n\t\tfor j := 0; j \u003c nvp; j++ {\n\t\t\tif src[j] == MESH_NULL_IDX {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tp.Verts[j] = src[j]\n\t\t\tif (src[nvp+j] \u0026 0x8000) != 0 {\n\t\t\t\t// Border or portal edge.\n\t\t\t\tdir := src[nvp+j] \u0026 0xf\n\t\t\t\tif dir == 0xf { // Border\n\t\t\t\t\tp.Neis[j] = 0\n\t\t\t\t} else if dir == 0 { // Portal x-\n\t\t\t\t\tp.Neis[j] = DT_EXT_LINK | 4\n\t\t\t\t} else if dir == 1 { // Portal z+\n\t\t\t\t\tp.Neis[j] = DT_EXT_LINK | 2\n\t\t\t\t} else if dir == 2 { // Portal x+\n\t\t\t\t\tp.Neis[j] = DT_EXT_LINK | 0\n\t\t\t\t} else if dir == 3 { // Portal z-\n\t\t\t\t\tp.Neis[j] = DT_EXT_LINK | 6\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Normal connection\n\t\t\t\tp.Neis[j] = src[nvp+j] + 1\n\t\t\t}\n\n\t\t\tp.VertCount++\n\t\t}\n\t\tsrcIndex += nvp * 2\n\t\tsrc = params.Polys[srcIndex:]\n\t}\n\t// Off-mesh connection vertices.\n\tn = 0\n\tfor i := 0; i \u003c int(params.OffMeshConCount); i++ {\n\t\t// Only store connections which start from this tile.\n\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\tp := \u0026navPolys[int(offMeshPolyBase)+n]\n\t\t\tp.VertCount = 2\n\t\t\tp.Verts[0] = (uint16)(int(offMeshVertsBase) + n*2 + 0)\n\t\t\tp.Verts[1] = (uint16)(int(offMeshVertsBase) + n*2 + 1)\n\t\t\tp.Flags = params.OffMeshConFlags[i]\n\t\t\tp.SetArea(params.OffMeshConAreas[i])\n\t\t\tp.SetType(DT_POLYTYPE_OFFMESH_CONNECTION)\n\t\t\tn++\n\t\t}\n\t}\n\n\t// Store detail meshes and vertices.\n\t// The nav polygon vertices are stored as the first vertices on each mesh.\n\t// We compress the mesh data by skipping them and using the navmesh coordinates.\n\tif params.DetailMeshes != nil {\n\t\tvbase := 0\n\t\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\t\tdtl := \u0026navDMeshes[i]\n\t\t\tvb := (int)(params.DetailMeshes[i*4+0])\n\t\t\tndv := (int)(params.DetailMeshes[i*4+1])\n\t\t\tnv := int(navPolys[i].VertCount)\n\t\t\tdtl.VertBase = (uint32)(vbase)\n\t\t\tdtl.VertCount = (uint8)(ndv - nv)\n\t\t\tdtl.TriBase = (uint32)(params.DetailMeshes[i*4+2])\n\t\t\tdtl.TriCount = (uint8)(params.DetailMeshes[i*4+3])\n\t\t\t// Copy vertices except the first 'nv' verts which are equal to nav poly verts.\n\t\t\tif (ndv - nv) != 0 {\n\t\t\t\tcopy(navDVerts[vbase*3:], params.DetailVerts[(vb+nv)*3:(vb+nv)*3+3*(ndv-nv)])\n\t\t\t\tvbase += (int)(ndv - nv)\n\t\t\t}\n\t\t}\n\t\t// Store triangles.\n\t\tcopy(navDTris, params.DetailTris[:4*params.DetailTriCount])\n\t} else {\n\t\t// Create dummy detail mesh by triangulating polys.\n\t\ttbase := 0\n\t\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\t\tdtl := \u0026navDMeshes[i]\n\t\t\tnv := int(navPolys[i].VertCount)\n\t\t\tdtl.VertBase = 0\n\t\t\tdtl.VertCount = 0\n\t\t\tdtl.TriBase = (uint32)(tbase)\n\t\t\tdtl.TriCount = (uint8)(nv - 2)\n\t\t\t// Triangulate polygon (local indices).\n\t\t\tfor j := 2; j \u003c nv; j++ {\n\t\t\t\tt := navDTris[tbase*4:]\n\t\t\t\tt[0] = 0\n\t\t\t\tt[1] = (uint8)(j - 1)\n\t\t\t\tt[2] = (uint8)(j)\n\t\t\t\t// Bit for each edge that belongs to poly boundary.\n\t\t\t\tt[3] = (1 \u003c\u003c 2)\n\t\t\t\tif j == 2 {\n\t\t\t\t\tt[3] |= (1 \u003c\u003c 0)\n\t\t\t\t}\n\t\t\t\tif j == nv-1 {\n\t\t\t\t\tt[3] |= (1 \u003c\u003c 4)\n\t\t\t\t}\n\t\t\t\ttbase++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Store and create BVtree.\n\tif params.BuildBvTree {\n\t\tcreateBVTree(params, navBvtree, int(2*params.PolyCount))\n\t}\n\n\t// Store Off-Mesh connections.\n\tn = 0\n\tfor i := 0; i \u003c int(params.OffMeshConCount); i++ {\n\t\t// Only store connections which start from this tile.\n\t\tif offMeshConClass[i*2+0] == 0xff {\n\t\t\tcon := \u0026offMeshCons[n]\n\t\t\tcon.Poly = (uint16)(int(offMeshPolyBase) + n)\n\t\t\t// Copy connection end-points.\n\t\t\tendPts := params.OffMeshConVerts[i*2*3:]\n\t\t\tDtVcopy(con.Pos[0:], endPts[0:])\n\t\t\tDtVcopy(con.Pos[3:], endPts[3:])\n\t\t\tcon.Rad = params.OffMeshConRad[i]\n\n\t\t\tif params.OffMeshConDir[i] != 0 {\n\t\t\t\tcon.Flags = DT_OFFMESH_CON_BIDIR\n\t\t\t} else {\n\t\t\t\tcon.Flags = 0\n\t\t\t}\n\t\t\tcon.Side = offMeshConClass[i*2+1]\n\t\t\tif params.OffMeshConUserID != nil {\n\t\t\t\tcon.UserId = params.OffMeshConUserID[i]\n\t\t\t}\n\t\t\tn++\n\t\t}\n\t}\n\n\toffMeshConClass = nil\n\n\t*outData = data\n\t*outDataSize = dataSize\n\n\treturn true\n}\n"
            },
            "DtDistancePtPolyEdgesSqr": {
                "Name": "DtDistancePtPolyEdgesSqr",
                "Code": "func DtDistancePtPolyEdgesSqr(pt, verts []float32, nverts int, ed, et []float32) bool {\n\tvar i, j int\n\tc := false\n\tfor i, j = 0, nverts-1; i \u003c nverts; j, i = i, i+1 {\n\t\tvi := verts[i*3:]\n\t\tvj := verts[j*3:]\n\t\tif ((vi[2] \u003e pt[2]) != (vj[2] \u003e pt[2])) \u0026\u0026\n\t\t\t(pt[0] \u003c (vj[0]-vi[0])*(pt[2]-vi[2])/(vj[2]-vi[2])+vi[0]) {\n\t\t\tc = !c\n\t\t}\n\t\ted[j] = DtDistancePtSegSqr2D(pt, vj, vi, \u0026et[j])\n\t}\n\treturn c\n}\n"
            },
            "DtDistancePtSegSqr2D": {
                "Name": "DtDistancePtSegSqr2D",
                "Code": "func DtDistancePtSegSqr2D(pt, p, q []float32, t *float32) float32 {\n\tpqx := q[0] - p[0]\n\tpqz := q[2] - p[2]\n\tdx := pt[0] - p[0]\n\tdz := pt[2] - p[2]\n\td := pqx*pqx + pqz*pqz\n\t*t = pqx*dx + pqz*dz\n\tif d \u003e 0 {\n\t\t*t /= d\n\t}\n\tif *t \u003c 0 {\n\t\t*t = 0\n\t} else if *t \u003e 1 {\n\t\t*t = 1\n\t}\n\tdx = p[0] + (*t)*pqx - pt[0]\n\tdz = p[2] + (*t)*pqz - pt[2]\n\treturn dx*dx + dz*dz\n}\n"
            },
            "DtFreeDtQueryFilter": {
                "Name": "DtFreeDtQueryFilter",
                "Code": "func DtFreeDtQueryFilter(filter *DtQueryFilter) {\n\tif filter == nil {\n\t\treturn\n\t}\n\tfilter.destructor()\n}\n"
            },
            "DtFreeNavMesh": {
                "Name": "DtFreeNavMesh",
                "Code": "func DtFreeNavMesh(navmesh *DtNavMesh) {\n\tif navmesh == nil {\n\t\treturn\n\t}\n\tnavmesh.destructor()\n}\n"
            },
            "DtFreeNavMeshQuery": {
                "Name": "DtFreeNavMeshQuery",
                "Code": "func DtFreeNavMeshQuery(query *DtNavMeshQuery) {\n\tif query == nil {\n\t\treturn\n\t}\n\tquery.destructor()\n}\n"
            },
            "DtFreeNodePool": {
                "Name": "DtFreeNodePool",
                "Code": "func DtFreeNodePool(pool *DtNodePool) {\n\tif pool == nil {\n\t\treturn\n\t}\n\tpool.destructor()\n}\n"
            },
            "DtFreeNodeQueue": {
                "Name": "DtFreeNodeQueue",
                "Code": "func DtFreeNodeQueue(queue *DtNodeQueue) {\n\tif queue == nil {\n\t\treturn\n\t}\n\tqueue.destructor()\n}\n"
            },
            "DtGetDetailTriEdgeFlags": {
                "Name": "DtGetDetailTriEdgeFlags",
                "Code": "func DtGetDetailTriEdgeFlags(triFlags uint8, edgeIndex int) int {\n\treturn int((triFlags \u003e\u003e (edgeIndex * 2)) \u0026 0x3)\n}\n"
            },
            "DtHashRef": {
                "Name": "DtHashRef",
                "Code": "func DtHashRef(polyRef DtPolyRef) uint32 {\n\ta := uint32(polyRef)\n\ta += ^(a \u003c\u003c 15)\n\ta ^= (a \u003e\u003e 10)\n\ta += (a \u003c\u003c 3)\n\ta ^= (a \u003e\u003e 6)\n\ta += ^(a \u003c\u003c 11)\n\ta ^= (a \u003e\u003e 16)\n\treturn a\n}\n"
            },
            "DtIgnoreUnused": {
                "Name": "DtIgnoreUnused",
                "Code": "func DtIgnoreUnused(interface{}) {}\n"
            },
            "DtIlog2": {
                "Name": "DtIlog2",
                "Code": "func DtIlog2(v uint32) uint32 {\n\tvar r, shift, temp uint32\n\n\tif v \u003e 0xffff {\n\t\ttemp = 1\n\t} else {\n\t\ttemp = 0\n\t}\n\tr = temp \u003c\u003c 4\n\tv \u003e\u003e= r\n\n\tif v \u003e 0xff {\n\t\ttemp = 1\n\t} else {\n\t\ttemp = 0\n\t}\n\tshift = temp \u003c\u003c 3\n\tv \u003e\u003e= shift\n\tr |= shift\n\n\tif v \u003e 0xf {\n\t\ttemp = 1\n\t} else {\n\t\ttemp = 0\n\t}\n\tshift = temp \u003c\u003c 2\n\tv \u003e\u003e= shift\n\tr |= shift\n\n\tif v \u003e 0x3 {\n\t\ttemp = 1\n\t} else {\n\t\ttemp = 0\n\t}\n\tshift = temp \u003c\u003c 1\n\tv \u003e\u003e= shift\n\tr |= shift\n\tr |= (v \u003e\u003e 1)\n\treturn r\n}\n"
            },
            "DtIntersectSegSeg2D": {
                "Name": "DtIntersectSegSeg2D",
                "Code": "func DtIntersectSegSeg2D(ap, aq, bp, bq []float32, s, t *float32) bool {\n\tu := [3]float32{}\n\tv := [3]float32{}\n\tw := [3]float32{}\n\tDtVsub(u[:], aq, ap)\n\tDtVsub(v[:], bq, bp)\n\tDtVsub(w[:], ap, bp)\n\td := vperpXZ(u[:], v[:])\n\tif math.Abs(float64(d)) \u003c 1e-6 {\n\t\treturn false\n\t}\n\t*s = vperpXZ(v[:], w[:]) / d\n\t*t = vperpXZ(u[:], w[:]) / d\n\treturn true\n}\n"
            },
            "DtIntersectSegmentPoly2D": {
                "Name": "DtIntersectSegmentPoly2D",
                "Code": "func DtIntersectSegmentPoly2D(p0, p1, verts []float32, nverts int, tmin, tmax *float32, segMin, segMax *int) bool {\n\t*tmin = 0\n\t*tmax = 1\n\t*segMin = -1\n\t*segMax = -1\n\n\tdir := [3]float32{}\n\tDtVsub(dir[:], p1, p0)\n\n\tfor i, j := 0, nverts-1; i \u003c nverts; j, i = i, i+1 {\n\t\tedge := [3]float32{}\n\t\tdiff := [3]float32{}\n\t\tDtVsub(edge[:], verts[i*3:], verts[j*3:])\n\t\tDtVsub(diff[:], p0, verts[j*3:])\n\t\tn := DtVperp2D(edge[:], diff[:])\n\t\td := DtVperp2D(dir[:], edge[:])\n\t\tif math.Abs(float64(d)) \u003c 0.00000001 {\n\t\t\t// S is nearly parallel to this edge\n\t\t\tif n \u003c 0 {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tt := n / d\n\t\tif d \u003c 0 {\n\t\t\t// segment S is entering across this edge\n\t\t\tif t \u003e *tmin {\n\t\t\t\t*tmin = t\n\t\t\t\t*segMin = j\n\t\t\t\t// S enters after leaving polygon\n\t\t\t\tif *tmin \u003e *tmax {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// segment S is leaving across this edge\n\t\t\tif t \u003c *tmax {\n\t\t\t\t*tmax = t\n\t\t\t\t*segMax = j\n\t\t\t\t// S leaves before entering polygon\n\t\t\t\tif *tmax \u003c *tmin {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n"
            },
            "DtMathAtan2f": {
                "Name": "DtMathAtan2f",
                "Code": "func DtMathAtan2f(y float32, x float32) float32 { return float32(math.Atan2(float64(y), float64(x))) }\n"
            },
            "DtMathCeilf": {
                "Name": "DtMathCeilf",
                "Code": "func DtMathCeilf(x float32) float32             { return float32(math.Ceil(float64(x))) }\n"
            },
            "DtMathCosf": {
                "Name": "DtMathCosf",
                "Code": "func DtMathCosf(x float32) float32              { return float32(math.Cos(float64(x))) }\n"
            },
            "DtMathFabsf": {
                "Name": "DtMathFabsf",
                "Code": "func DtMathFabsf(x float32) float32             { return float32(math.Abs(float64(x))) }\n"
            },
            "DtMathFloorf": {
                "Name": "DtMathFloorf",
                "Code": "func DtMathFloorf(x float32) float32            { return float32(math.Floor(float64(x))) }\n"
            },
            "DtMathSinf": {
                "Name": "DtMathSinf",
                "Code": "func DtMathSinf(x float32) float32              { return float32(math.Sin(float64(x))) }\n"
            },
            "DtMathSqrtf": {
                "Name": "DtMathSqrtf",
                "Code": "func DtMathSqrtf(x float32) float32             { return float32(math.Sqrt(float64(x))) }\n"
            },
            "DtMaxFloat32": {
                "Name": "DtMaxFloat32",
                "Code": "func DtMaxFloat32(a, b float32) float32 {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxInt": {
                "Name": "DtMaxInt",
                "Code": "func DtMaxInt(a, b int) int {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxInt16": {
                "Name": "DtMaxInt16",
                "Code": "func DtMaxInt16(a, b int16) int16 {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxInt32": {
                "Name": "DtMaxInt32",
                "Code": "func DtMaxInt32(a, b int32) int32 {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxInt8": {
                "Name": "DtMaxInt8",
                "Code": "func DtMaxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
            },
            "DtMaxUInt16": {
                "Name": "DtMaxUInt16",
                "Code": "func DtMaxUInt16(a, b uint16) uint16 {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxUInt32": {
                "Name": "DtMaxUInt32",
                "Code": "func DtMaxUInt32(a, b uint32) uint32 {\n\tif a \u003e b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMaxUInt8": {
                "Name": "DtMaxUInt8",
                "Code": "func DtMaxUInt8(a, b uint8) uint8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
            },
            "DtMinFloat32": {
                "Name": "DtMinFloat32",
                "Code": "func DtMinFloat32(a, b float32) float32 {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMinInt": {
                "Name": "DtMinInt",
                "Code": "func DtMinInt(a, b int) int {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMinInt16": {
                "Name": "DtMinInt16",
                "Code": "func DtMinInt16(a, b int16) int16 {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMinInt32": {
                "Name": "DtMinInt32",
                "Code": "func DtMinInt32(a, b int32) int32 {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMinUInt16": {
                "Name": "DtMinUInt16",
                "Code": "func DtMinUInt16(a, b uint16) uint16 {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtMinUInt32": {
                "Name": "DtMinUInt32",
                "Code": "func DtMinUInt32(a, b uint32) uint32 {\n\tif a \u003c b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n}\n"
            },
            "DtNavMeshDataSwapEndian": {
                "Name": "DtNavMeshDataSwapEndian",
                "Code": "func DtNavMeshDataSwapEndian(data []byte, _ int /*dataSize*/) bool {\n\t// Make sure the data is in right format.\n\theader := (*DtMeshHeader)(unsafe.Pointer(\u0026(data[0])))\n\tif header.Magic != DT_NAVMESH_MAGIC {\n\t\treturn false\n\t}\n\tif header.Version != DT_NAVMESH_VERSION {\n\t\treturn false\n\t}\n\t// Patch header pointers.\n\theaderSize := DtAlign4(int(unsafe.Sizeof(DtMeshHeader{})))\n\tvertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(header.VertCount))\n\tpolysSize := DtAlign4(int(unsafe.Sizeof(DtPoly{})) * int(header.PolyCount))\n\tlinksSize := DtAlign4(int(unsafe.Sizeof(DtLink{})) * int(header.MaxLinkCount))\n\tdetailMeshesSize := DtAlign4(int(unsafe.Sizeof(DtPolyDetail{})) * int(header.DetailMeshCount))\n\tdetailVertsSize := DtAlign4(int(unsafe.Sizeof(float32(1.0))) * 3 * int(header.DetailVertCount))\n\tdetailTrisSize := DtAlign4(int(unsafe.Sizeof(uint8(1))) * 4 * int(header.DetailTriCount))\n\tbvtreeSize := DtAlign4(int(unsafe.Sizeof(DtBVNode{})) * int(header.BvNodeCount))\n\toffMeshLinksSize := DtAlign4(int(unsafe.Sizeof(DtOffMeshConnection{})) * int(header.OffMeshConCount))\n\n\td := 0 + headerSize\n\n\tvar verts []float32\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026verts)))\n\tsliceHeader.Cap = 3 * int(header.VertCount)\n\tsliceHeader.Len = 3 * int(header.VertCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += vertsSize\n\n\tvar polys []DtPoly\n\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026polys)))\n\tsliceHeader.Cap = int(header.PolyCount)\n\tsliceHeader.Len = int(header.PolyCount)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\td += polysSize\n\n\td += linksSize // Ignore links; they technically should be endian-swapped but all their data is overwritten on load anyway.\n\t//dtLink* links = dtGetThenAdvanceBufferPointer\u003cdtLink\u003e(d, linksSize);\n\n\tvar detailMeshes []DtPolyDetail\n\tif header.DetailMeshCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026detailMeshes)))\n\t\tsliceHeader.Cap = int(header.DetailMeshCount)\n\t\tsliceHeader.Len = int(header.DetailMeshCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailMeshesSize\n\t}\n\n\tvar detailVerts []float32\n\tif header.DetailVertCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026detailVerts)))\n\t\tsliceHeader.Cap = 3 * int(header.DetailVertCount)\n\t\tsliceHeader.Len = 3 * int(header.DetailVertCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += detailVertsSize\n\t}\n\n\td += detailTrisSize // Ignore detail tris; single bytes can't be endian-swapped.\n\t//unsigned char* detailTris = dtGetThenAdvanceBufferPointer\u003cunsigned char\u003e(d, detailTrisSize);\n\n\tvar bvTree []DtBVNode\n\tif header.BvNodeCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026bvTree)))\n\t\tsliceHeader.Cap = int(header.BvNodeCount)\n\t\tsliceHeader.Len = int(header.BvNodeCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += bvtreeSize\n\t}\n\n\tvar offMeshCons []DtOffMeshConnection\n\tif header.OffMeshConCount != 0 {\n\t\tsliceHeader = (*reflect.SliceHeader)((unsafe.Pointer(\u0026offMeshCons)))\n\t\tsliceHeader.Cap = int(header.OffMeshConCount)\n\t\tsliceHeader.Len = int(header.OffMeshConCount)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026(data[d])))\n\t\td += offMeshLinksSize\n\t}\n\n\t// Vertices\n\tfor i := 0; i \u003c int(header.VertCount*3); i++ {\n\t\tDtSwapEndianFloat32(\u0026verts[i])\n\t}\n\n\t// Polys\n\tfor i := 0; i \u003c int(header.PolyCount); i++ {\n\t\tp := \u0026polys[i]\n\t\t// poly-\u003efirstLink is update when tile is added, no need to swap.\n\t\tfor j := 0; j \u003c int(DT_VERTS_PER_POLYGON); j++ {\n\t\t\tDtSwapEndianUInt16(\u0026p.Verts[j])\n\t\t\tDtSwapEndianUInt16(\u0026p.Neis[j])\n\t\t}\n\t\tDtSwapEndianUInt16(\u0026p.Flags)\n\t}\n\n\t// Links are rebuild when tile is added, no need to swap.\n\n\t// Detail meshes\n\tfor i := 0; i \u003c int(header.DetailMeshCount); i++ {\n\t\tpd := \u0026detailMeshes[i]\n\t\tDtSwapEndianUInt32(\u0026pd.VertBase)\n\t\tDtSwapEndianUInt32(\u0026pd.TriBase)\n\t}\n\n\t// Detail verts\n\tfor i := 0; i \u003c int(header.DetailVertCount*3); i++ {\n\t\tDtSwapEndianFloat32(\u0026detailVerts[i])\n\t}\n\n\t// BV-tree\n\tfor i := 0; i \u003c int(header.BvNodeCount); i++ {\n\t\tnode := \u0026bvTree[i]\n\t\tfor j := 0; j \u003c 3; j++ {\n\t\t\tDtSwapEndianUInt16(\u0026node.Bmin[j])\n\t\t\tDtSwapEndianUInt16(\u0026node.Bmax[j])\n\t\t}\n\t\tDtSwapEndianInt32(\u0026node.I)\n\t}\n\n\t// Off-mesh Connections.\n\tfor i := 0; i \u003c int(header.OffMeshConCount); i++ {\n\t\tcon := \u0026offMeshCons[i]\n\t\tfor j := 0; j \u003c 6; j++ {\n\t\t\tDtSwapEndianFloat32(\u0026con.Pos[j])\n\t\t}\n\t\tDtSwapEndianFloat32(\u0026con.Rad)\n\t\tDtSwapEndianUInt16(\u0026con.Poly)\n\t}\n\n\treturn true\n}\n"
            },
            "DtNavMeshHeaderSwapEndian": {
                "Name": "DtNavMeshHeaderSwapEndian",
                "Code": "func DtNavMeshHeaderSwapEndian(data []byte, _ int /*dataSize*/) bool {\n\theader := (*DtMeshHeader)(unsafe.Pointer(\u0026(data[0])))\n\n\tswappedMagic := DT_NAVMESH_MAGIC\n\tswappedVersion := DT_NAVMESH_VERSION\n\tDtSwapEndianInt32(\u0026swappedMagic)\n\tDtSwapEndianInt32(\u0026swappedVersion)\n\n\tif (header.Magic != DT_NAVMESH_MAGIC || header.Version != DT_NAVMESH_VERSION) \u0026\u0026\n\t\t(header.Magic != swappedMagic || header.Version != swappedVersion) {\n\t\treturn false\n\t}\n\n\tDtSwapEndianInt32(\u0026header.Magic)\n\tDtSwapEndianInt32(\u0026header.Version)\n\tDtSwapEndianInt32(\u0026header.X)\n\tDtSwapEndianInt32(\u0026header.Y)\n\tDtSwapEndianInt32(\u0026header.Layer)\n\tDtSwapEndianUInt32(\u0026header.UserId)\n\tDtSwapEndianInt32(\u0026header.PolyCount)\n\tDtSwapEndianInt32(\u0026header.VertCount)\n\tDtSwapEndianInt32(\u0026header.MaxLinkCount)\n\tDtSwapEndianInt32(\u0026header.DetailMeshCount)\n\tDtSwapEndianInt32(\u0026header.DetailVertCount)\n\tDtSwapEndianInt32(\u0026header.DetailTriCount)\n\tDtSwapEndianInt32(\u0026header.BvNodeCount)\n\tDtSwapEndianInt32(\u0026header.OffMeshConCount)\n\tDtSwapEndianInt32(\u0026header.OffMeshBase)\n\tDtSwapEndianFloat32(\u0026header.WalkableHeight)\n\tDtSwapEndianFloat32(\u0026header.WalkableRadius)\n\tDtSwapEndianFloat32(\u0026header.WalkableClimb)\n\tDtSwapEndianFloat32(\u0026header.Bmin[0])\n\tDtSwapEndianFloat32(\u0026header.Bmin[1])\n\tDtSwapEndianFloat32(\u0026header.Bmin[2])\n\tDtSwapEndianFloat32(\u0026header.Bmax[0])\n\tDtSwapEndianFloat32(\u0026header.Bmax[1])\n\tDtSwapEndianFloat32(\u0026header.Bmax[2])\n\tDtSwapEndianFloat32(\u0026header.BvQuantFactor)\n\n\t// Freelist index and pointers are updated when tile is added, no need to swap.\n\n\treturn true\n}\n"
            },
            "DtNextPow2": {
                "Name": "DtNextPow2",
                "Code": "func DtNextPow2(v uint32) uint32 {\n\tv--\n\tv |= v \u003e\u003e 1\n\tv |= v \u003e\u003e 2\n\tv |= v \u003e\u003e 4\n\tv |= v \u003e\u003e 8\n\tv |= v \u003e\u003e 16\n\tv++\n\treturn v\n}\n"
            },
            "DtOppositeTile": {
                "Name": "DtOppositeTile",
                "Code": "func DtOppositeTile(side int) int { return (side + 4) \u0026 0x7 }\n"
            },
            "DtOverlapBounds": {
                "Name": "DtOverlapBounds",
                "Code": "func DtOverlapBounds(amin, amax, bmin, bmax []float32) bool {\n\treturn !(amin[0] \u003e bmax[0] || amax[0] \u003c bmin[0] || amin[1] \u003e bmax[1] || amax[1] \u003c bmin[1] || amin[2] \u003e bmax[2] || amax[2] \u003c bmin[2])\n}\n"
            },
            "DtOverlapPolyPoly2D": {
                "Name": "DtOverlapPolyPoly2D",
                "Code": "func DtOverlapPolyPoly2D(polya []float32, npolya int, polyb []float32, npolyb int) bool {\n\tfor i, j := 0, npolya-1; i \u003c npolya; j, i = i, i+1 {\n\t\tva := polya[j*3:]\n\t\tvb := polya[i*3:]\n\t\tn := [3]float32{vb[2] - va[2], 0, -(vb[0] - va[0])}\n\t\tvar amin, amax, bmin, bmax float32\n\t\tprojectPoly(n[:], polya, npolya, \u0026amin, \u0026amax)\n\t\tprojectPoly(n[:], polyb, npolyb, \u0026bmin, \u0026bmax)\n\t\tif !overlapRange(amin, amax, bmin, bmax, EPS) {\n\t\t\t// Found separating axis\n\t\t\treturn false\n\t\t}\n\t}\n\tfor i, j := 0, npolyb-1; i \u003c npolyb; j, i = i, i+1 {\n\t\tva := polyb[j*3:]\n\t\tvb := polyb[i*3:]\n\t\tn := [3]float32{vb[2] - va[2], 0, -(vb[0] - va[0])}\n\t\tvar amin, amax, bmin, bmax float32\n\t\tprojectPoly(n[:], polya, npolya, \u0026amin, \u0026amax)\n\t\tprojectPoly(n[:], polyb, npolyb, \u0026bmin, \u0026bmax)\n\t\tif !overlapRange(amin, amax, bmin, bmax, EPS) {\n\t\t\t// Found separating axis\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
            },
            "DtOverlapQuantBounds": {
                "Name": "DtOverlapQuantBounds",
                "Code": "func DtOverlapQuantBounds(amin, amax, bmin, bmax []uint16) bool {\n\treturn !(amin[0] \u003e bmax[0] || amax[0] \u003c bmin[0] || amin[1] \u003e bmax[1] || amax[1] \u003c bmin[1] || amin[2] \u003e bmax[2] || amax[2] \u003c bmin[2])\n}\n"
            },
            "DtPointInPolygon": {
                "Name": "DtPointInPolygon",
                "Code": "func DtPointInPolygon(pt, verts []float32, nverts int) bool {\n\tvar i, j int\n\tc := false\n\tfor i, j = 0, nverts-1; i \u003c nverts; j, i = i, i+1 {\n\t\tvi := verts[i*3:]\n\t\tvj := verts[j*3:]\n\t\tif ((vi[2] \u003e pt[2]) != (vj[2] \u003e pt[2])) \u0026\u0026\n\t\t\t(pt[0] \u003c (vj[0]-vi[0])*(pt[2]-vi[2])/(vj[2]-vi[2])+vi[0]) {\n\t\t\tc = !c\n\t\t}\n\t}\n\treturn c\n}\n"
            },
            "DtRandomPointInConvexPoly": {
                "Name": "DtRandomPointInConvexPoly",
                "Code": "func DtRandomPointInConvexPoly(pts []float32, npts int, areas []float32, s, t float32, out []float32) {\n\tareasum := float32(0.0)\n\tfor i := 2; i \u003c npts; i++ {\n\t\tareas[i] = DtTriArea2D(pts[0:], pts[(i-1)*3:], pts[i*3:])\n\t\tareasum += DtMaxFloat32(float32(0.001), areas[i])\n\t}\n\t// Find sub triangle weighted by area.\n\tthr := s * areasum\n\tacc := float32(0.0)\n\tu := float32(1.0)\n\ttri := npts - 1\n\tfor i := 2; i \u003c npts; i++ {\n\t\tdacc := areas[i]\n\t\tif thr \u003e= acc \u0026\u0026 thr \u003c (acc+dacc) {\n\t\t\tu = (thr - acc) / dacc\n\t\t\ttri = i\n\t\t\tbreak\n\t\t}\n\t\tacc += dacc\n\t}\n\n\tv := DtMathSqrtf(t)\n\n\ta := 1 - v\n\tb := (1 - u) * v\n\tc := u * v\n\tpa := pts[0:]\n\tpb := pts[(tri-1)*3:]\n\tpc := pts[tri*3:]\n\n\tout[0] = a*pa[0] + b*pb[0] + c*pc[0]\n\tout[1] = a*pa[1] + b*pb[1] + c*pc[1]\n\tout[2] = a*pa[2] + b*pb[2] + c*pc[2]\n}\n"
            },
            "DtSqrFloat32": {
                "Name": "DtSqrFloat32",
                "Code": "func DtSqrFloat32(a float32) float32 { return a * a }\n"
            },
            "DtSqrInt16": {
                "Name": "DtSqrInt16",
                "Code": "func DtSqrInt16(a int16) int16       { return a * a }\n"
            },
            "DtSqrInt32": {
                "Name": "DtSqrInt32",
                "Code": "func DtSqrInt32(a int32) int32       { return a * a }\n"
            },
            "DtSqrUInt16": {
                "Name": "DtSqrUInt16",
                "Code": "func DtSqrUInt16(a uint16) uint16    { return a * a }\n"
            },
            "DtSqrUInt32": {
                "Name": "DtSqrUInt32",
                "Code": "func DtSqrUInt32(a uint32) uint32    { return a * a }\n"
            },
            "DtStatusDetail": {
                "Name": "DtStatusDetail",
                "Code": "func DtStatusDetail(status DtStatus, detail DtStatus) bool {\n\treturn (status \u0026 detail) != 0\n}\n"
            },
            "DtStatusFailed": {
                "Name": "DtStatusFailed",
                "Code": "func DtStatusFailed(status DtStatus) bool {\n\treturn (status \u0026 DT_FAILURE) != 0\n}\n"
            },
            "DtStatusInProgress": {
                "Name": "DtStatusInProgress",
                "Code": "func DtStatusInProgress(status DtStatus) bool {\n\treturn (status \u0026 DT_IN_PROGRESS) != 0\n}\n"
            },
            "DtStatusSucceed": {
                "Name": "DtStatusSucceed",
                "Code": "func DtStatusSucceed(status DtStatus) bool {\n\treturn (status \u0026 DT_SUCCESS) != 0\n}\n"
            },
            "DtSwapByte": {
                "Name": "DtSwapByte",
                "Code": "func DtSwapByte(a, b *uint8) {\n\ttmp := *a\n\t*a = *b\n\t*b = tmp\n}\n"
            },
            "DtSwapEndianFloat32": {
                "Name": "DtSwapEndianFloat32",
                "Code": "func DtSwapEndianFloat32(v *float32) {\n\tx0 := (*uint8)(unsafe.Pointer(v))\n\tx1 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 1))\n\tx2 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 2))\n\tx3 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 3))\n\tDtSwapByte(x0, x3)\n\tDtSwapByte(x1, x2)\n}\n"
            },
            "DtSwapEndianInt16": {
                "Name": "DtSwapEndianInt16",
                "Code": "func DtSwapEndianInt16(v *int16) {\n\tx0 := (*uint8)(unsafe.Pointer(v))\n\tx1 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 1))\n\tDtSwapByte(x0, x1)\n}\n"
            },
            "DtSwapEndianInt32": {
                "Name": "DtSwapEndianInt32",
                "Code": "func DtSwapEndianInt32(v *int32) {\n\tx0 := (*uint8)(unsafe.Pointer(v))\n\tx1 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 1))\n\tx2 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 2))\n\tx3 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 3))\n\tDtSwapByte(x0, x3)\n\tDtSwapByte(x1, x2)\n}\n"
            },
            "DtSwapEndianUInt16": {
                "Name": "DtSwapEndianUInt16",
                "Code": "func DtSwapEndianUInt16(v *uint16) {\n\tx0 := (*uint8)(unsafe.Pointer(v))\n\tx1 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 1))\n\tDtSwapByte(x0, x1)\n}\n"
            },
            "DtSwapEndianUInt32": {
                "Name": "DtSwapEndianUInt32",
                "Code": "func DtSwapEndianUInt32(v *uint32) {\n\tx0 := (*uint8)(unsafe.Pointer(v))\n\tx1 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 1))\n\tx2 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 2))\n\tx3 := (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + 3))\n\tDtSwapByte(x0, x3)\n\tDtSwapByte(x1, x2)\n}\n"
            },
            "DtSwapFloat32": {
                "Name": "DtSwapFloat32",
                "Code": "func DtSwapFloat32(a, b *float32) { t := *a; *a = *b; *b = t }\n"
            },
            "DtSwapInt16": {
                "Name": "DtSwapInt16",
                "Code": "func DtSwapInt16(a, b *int16)     { t := *a; *a = *b; *b = t }\n"
            },
            "DtSwapInt32": {
                "Name": "DtSwapInt32",
                "Code": "func DtSwapInt32(a, b *int32)     { t := *a; *a = *b; *b = t }\n"
            },
            "DtSwapUInt16": {
                "Name": "DtSwapUInt16",
                "Code": "func DtSwapUInt16(a, b *uint16)   { t := *a; *a = *b; *b = t }\n"
            },
            "DtSwapUInt32": {
                "Name": "DtSwapUInt32",
                "Code": "func DtSwapUInt32(a, b *uint32)   { t := *a; *a = *b; *b = t }\n"
            },
            "DtTriArea2D": {
                "Name": "DtTriArea2D",
                "Code": "func DtTriArea2D(a, b, c []float32) float32 {\n\tabx := b[0] - a[0]\n\tabz := b[2] - a[2]\n\tacx := c[0] - a[0]\n\tacz := c[2] - a[2]\n\treturn acx*abz - abx*acz\n}\n"
            },
            "DtVadd": {
                "Name": "DtVadd",
                "Code": "func DtVadd(dest, v1, v2 []float32) {\n\tdest[0] = v1[0] + v2[0]\n\tdest[1] = v1[1] + v2[1]\n\tdest[2] = v1[2] + v2[2]\n}\n"
            },
            "DtVcopy": {
                "Name": "DtVcopy",
                "Code": "func DtVcopy(dest, a []float32) {\n\tdest[0] = a[0]\n\tdest[1] = a[1]\n\tdest[2] = a[2]\n}\n"
            },
            "DtVcross": {
                "Name": "DtVcross",
                "Code": "func DtVcross(dest, v1, v2 []float32) {\n\tdest[0] = v1[1]*v2[2] - v1[2]*v2[1]\n\tdest[1] = v1[2]*v2[0] - v1[0]*v2[2]\n\tdest[2] = v1[0]*v2[1] - v1[1]*v2[0]\n}\n"
            },
            "DtVdist": {
                "Name": "DtVdist",
                "Code": "func DtVdist(v1, v2 []float32) float32 {\n\tdx := v2[0] - v1[0]\n\tdy := v2[1] - v1[1]\n\tdz := v2[2] - v1[2]\n\treturn DtMathSqrtf(dx*dx + dy*dy + dz*dz)\n}\n"
            },
            "DtVdist2D": {
                "Name": "DtVdist2D",
                "Code": "func DtVdist2D(v1, v2 []float32) float32 {\n\tdx := v2[0] - v1[0]\n\tdz := v2[2] - v1[2]\n\treturn DtMathSqrtf(dx*dx + dz*dz)\n}\n"
            },
            "DtVdist2DSqr": {
                "Name": "DtVdist2DSqr",
                "Code": "func DtVdist2DSqr(v1, v2 []float32) float32 {\n\tdx := v2[0] - v1[0]\n\tdz := v2[2] - v1[2]\n\treturn dx*dx + dz*dz\n}\n"
            },
            "DtVdistSqr": {
                "Name": "DtVdistSqr",
                "Code": "func DtVdistSqr(v1, v2 []float32) float32 {\n\tdx := v2[0] - v1[0]\n\tdy := v2[1] - v1[1]\n\tdz := v2[2] - v1[2]\n\treturn dx*dx + dy*dy + dz*dz\n}\n"
            },
            "DtVdot": {
                "Name": "DtVdot",
                "Code": "func DtVdot(v1, v2 []float32) float32 {\n\treturn v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]\n}\n"
            },
            "DtVdot2D": {
                "Name": "DtVdot2D",
                "Code": "func DtVdot2D(u, v []float32) float32 {\n\treturn u[0]*v[0] + u[2]*v[2]\n}\n"
            },
            "DtVequal": {
                "Name": "DtVequal",
                "Code": "func DtVequal(p0, p1 []float32) bool {\n\td := DtVdistSqr(p0, p1)\n\treturn d \u003c thr\n}\n"
            },
            "DtVlen": {
                "Name": "DtVlen",
                "Code": "func DtVlen(v []float32) float32 {\n\treturn DtMathSqrtf(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])\n}\n"
            },
            "DtVlenSqr": {
                "Name": "DtVlenSqr",
                "Code": "func DtVlenSqr(v []float32) float32 {\n\treturn v[0]*v[0] + v[1]*v[1] + v[2]*v[2]\n}\n"
            },
            "DtVlerp": {
                "Name": "DtVlerp",
                "Code": "func DtVlerp(dest, v1, v2 []float32, t float32) {\n\tdest[0] = v1[0] + (v2[0]-v1[0])*t\n\tdest[1] = v1[1] + (v2[1]-v1[1])*t\n\tdest[2] = v1[2] + (v2[2]-v1[2])*t\n}\n"
            },
            "DtVmad": {
                "Name": "DtVmad",
                "Code": "func DtVmad(dest, v1, v2 []float32, s float32) {\n\tdest[0] = v1[0] + v2[0]*s\n\tdest[1] = v1[1] + v2[1]*s\n\tdest[2] = v1[2] + v2[2]*s\n}\n"
            },
            "DtVmax": {
                "Name": "DtVmax",
                "Code": "func DtVmax(mx, v []float32) {\n\tmx[0] = DtMaxFloat32(mx[0], v[0])\n\tmx[1] = DtMaxFloat32(mx[1], v[1])\n\tmx[2] = DtMaxFloat32(mx[2], v[2])\n}\n"
            },
            "DtVmin": {
                "Name": "DtVmin",
                "Code": "func DtVmin(mn, v []float32) {\n\tmn[0] = DtMinFloat32(mn[0], v[0])\n\tmn[1] = DtMinFloat32(mn[1], v[1])\n\tmn[2] = DtMinFloat32(mn[2], v[2])\n}\n"
            },
            "DtVnormalize": {
                "Name": "DtVnormalize",
                "Code": "func DtVnormalize(v []float32) {\n\td := 1.0 / DtMathSqrtf(DtSqrFloat32(v[0])+DtSqrFloat32(v[1])+DtSqrFloat32(v[2]))\n\tv[0] *= d\n\tv[1] *= d\n\tv[2] *= d\n}\n"
            },
            "DtVperp2D": {
                "Name": "DtVperp2D",
                "Code": "func DtVperp2D(u, v []float32) float32 {\n\treturn u[2]*v[0] - u[0]*v[2]\n}\n"
            },
            "DtVscale": {
                "Name": "DtVscale",
                "Code": "func DtVscale(dest, v []float32, t float32) {\n\tdest[0] = v[0] * t\n\tdest[1] = v[1] * t\n\tdest[2] = v[2] * t\n}\n"
            },
            "DtVset": {
                "Name": "DtVset",
                "Code": "func DtVset(dest []float32, x, y, z float32) {\n\tdest[0] = x\n\tdest[1] = y\n\tdest[2] = z\n}\n"
            },
            "DtVsub": {
                "Name": "DtVsub",
                "Code": "func DtVsub(dest, v1, v2 []float32) {\n\tdest[0] = v1[0] - v2[0]\n\tdest[1] = v1[1] - v2[1]\n\tdest[2] = v1[2] - v2[2]\n}\n"
            },
            "Memset": {
                "Name": "Memset",
                "Code": "func Memset(mem uintptr, val uint8, size int) {\n\tvar dst []byte\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026dst)))\n\tsliceHeader.Cap = size\n\tsliceHeader.Len = size\n\tsliceHeader.Data = mem\n\tfor i := 0; i \u003c size; i++ {\n\t\tdst[i] = val\n\t}\n}\n"
            },
            "SliceSizeFromPointer": {
                "Name": "SliceSizeFromPointer",
                "Code": "func SliceSizeFromPointer(p, start unsafe.Pointer, eleSize uintptr) uint32 {\n\treturn uint32((uintptr(p) - uintptr(start)) / eleSize)\n}\n"
            },
            "allocLink": {
                "Name": "allocLink",
                "Code": "func allocLink(tile *DtMeshTile) uint32 {\n\tif tile.LinksFreeList == DT_NULL_LINK {\n\t\treturn DT_NULL_LINK\n\t}\n\tlink := tile.LinksFreeList\n\ttile.LinksFreeList = tile.Links[link].Next\n\treturn link\n}\n"
            },
            "calcExtends": {
                "Name": "calcExtends",
                "Code": "func calcExtends(items []BVItem, _ /*nitems*/, imin, imax int,\n\tbmin, bmax []uint16) {\n\tbmin[0] = items[imin].bmin[0]\n\tbmin[1] = items[imin].bmin[1]\n\tbmin[2] = items[imin].bmin[2]\n\n\tbmax[0] = items[imin].bmax[0]\n\tbmax[1] = items[imin].bmax[1]\n\tbmax[2] = items[imin].bmax[2]\n\n\tfor i := imin + 1; i \u003c imax; i++ {\n\t\tit := \u0026items[i]\n\t\tif it.bmin[0] \u003c bmin[0] {\n\t\t\tbmin[0] = it.bmin[0]\n\t\t}\n\t\tif it.bmin[1] \u003c bmin[1] {\n\t\t\tbmin[1] = it.bmin[1]\n\t\t}\n\t\tif it.bmin[2] \u003c bmin[2] {\n\t\t\tbmin[2] = it.bmin[2]\n\t\t}\n\n\t\tif it.bmax[0] \u003e bmax[0] {\n\t\t\tbmax[0] = it.bmax[0]\n\t\t}\n\t\tif it.bmax[1] \u003e bmax[1] {\n\t\t\tbmax[1] = it.bmax[1]\n\t\t}\n\t\tif it.bmax[2] \u003e bmax[2] {\n\t\t\tbmax[2] = it.bmax[2]\n\t\t}\n\t}\n}\n"
            },
            "calcSlabEndPoints": {
                "Name": "calcSlabEndPoints",
                "Code": "func calcSlabEndPoints(va, vb, bmin, bmax []float32, side int) {\n\tif side == 0 || side == 4 {\n\t\tif va[2] \u003c vb[2] {\n\t\t\tbmin[0] = va[2]\n\t\t\tbmin[1] = va[1]\n\t\t\tbmax[0] = vb[2]\n\t\t\tbmax[1] = vb[1]\n\t\t} else {\n\t\t\tbmin[0] = vb[2]\n\t\t\tbmin[1] = vb[1]\n\t\t\tbmax[0] = va[2]\n\t\t\tbmax[1] = va[1]\n\t\t}\n\t} else if side == 2 || side == 6 {\n\t\tif va[0] \u003c vb[0] {\n\t\t\tbmin[0] = va[0]\n\t\t\tbmin[1] = va[1]\n\t\t\tbmax[0] = vb[0]\n\t\t\tbmax[1] = vb[1]\n\t\t} else {\n\t\t\tbmin[0] = vb[0]\n\t\t\tbmin[1] = vb[1]\n\t\t\tbmax[0] = va[0]\n\t\t\tbmax[1] = va[1]\n\t\t}\n\t}\n}\n"
            },
            "classifyOffMeshPoint": {
                "Name": "classifyOffMeshPoint",
                "Code": "func classifyOffMeshPoint(pt, bmin, bmax []float32) uint8 {\n\tconst XP uint8 = 1 \u003c\u003c 0\n\tconst ZP uint8 = 1 \u003c\u003c 1\n\tconst XM uint8 = 1 \u003c\u003c 2\n\tconst ZM uint8 = 1 \u003c\u003c 3\n\n\tvar outcode uint8\n\tif pt[0] \u003e= bmax[0] {\n\t\toutcode |= XP\n\t}\n\tif pt[2] \u003e= bmax[2] {\n\t\toutcode |= ZP\n\t}\n\tif pt[0] \u003c bmin[0] {\n\t\toutcode |= XM\n\t}\n\tif pt[2] \u003c bmin[2] {\n\t\toutcode |= ZM\n\t}\n\n\tswitch outcode {\n\tcase XP:\n\t\treturn 0\n\tcase XP | ZP:\n\t\treturn 1\n\tcase ZP:\n\t\treturn 2\n\tcase XM | ZP:\n\t\treturn 3\n\tcase XM:\n\t\treturn 4\n\tcase XM | ZM:\n\t\treturn 5\n\tcase ZM:\n\t\treturn 6\n\tcase XP | ZM:\n\t\treturn 7\n\t}\n\n\treturn 0xff\n}\n"
            },
            "compareItemX": {
                "Name": "compareItemX",
                "Code": "func compareItemX(a, b *BVItem) bool {\n\treturn a.bmin[0] \u003c b.bmin[0]\n}\n"
            },
            "compareItemY": {
                "Name": "compareItemY",
                "Code": "func compareItemY(a, b *BVItem) bool {\n\treturn a.bmin[1] \u003c b.bmin[1]\n}\n"
            },
            "compareItemZ": {
                "Name": "compareItemZ",
                "Code": "func compareItemZ(a, b *BVItem) bool {\n\treturn a.bmin[2] \u003c b.bmin[2]\n}\n"
            },
            "computeTileHash": {
                "Name": "computeTileHash",
                "Code": "func computeTileHash(x, y, mask int32) int32 {\n\th1 := uint32(0x8da6b343) // Large multiplicative constants;\n\th2 := uint32(0xd8163841) // here arbitrarily chosen primes\n\tn := h1*uint32(x) + h2*uint32(y)\n\treturn int32(n \u0026 uint32(mask))\n}\n"
            },
            "createBVTree": {
                "Name": "createBVTree",
                "Code": "func createBVTree(params *DtNavMeshCreateParams, nodes []DtBVNode, _ int /*nnodes*/) int {\n\t// Build tree\n\tquantFactor := 1 / float32(params.Cs)\n\titems := make([]BVItem, params.PolyCount)\n\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\tit := \u0026items[i]\n\t\tit.i = i\n\t\t// Calc polygon bounds. Use detail meshes if available.\n\t\tif params.DetailMeshes != nil {\n\t\t\tvb := (int)(params.DetailMeshes[i*4+0])\n\t\t\tndv := (int)(params.DetailMeshes[i*4+1])\n\t\t\tvar bmin [3]float32\n\t\t\tvar bmax [3]float32\n\n\t\t\tdv := params.DetailVerts[vb*3:]\n\t\t\tDtVcopy(bmin[:], dv)\n\t\t\tDtVcopy(bmax[:], dv)\n\n\t\t\tfor j := 1; j \u003c ndv; j++ {\n\t\t\t\tDtVmin(bmin[:], dv[j*3:])\n\t\t\t\tDtVmax(bmax[:], dv[j*3:])\n\t\t\t}\n\n\t\t\t// BV-tree uses cs for all dimensions\n\t\t\tit.bmin[0] = (uint16)(DtClampUInt32((uint32)((bmin[0]-params.Bmin[0])*quantFactor), 0, 0xffff))\n\t\t\tit.bmin[1] = (uint16)(DtClampUInt32((uint32)((bmin[1]-params.Bmin[1])*quantFactor), 0, 0xffff))\n\t\t\tit.bmin[2] = (uint16)(DtClampUInt32((uint32)((bmin[2]-params.Bmin[2])*quantFactor), 0, 0xffff))\n\n\t\t\tit.bmax[0] = (uint16)(DtClampUInt32((uint32)((bmax[0]-params.Bmin[0])*quantFactor), 0, 0xffff))\n\t\t\tit.bmax[1] = (uint16)(DtClampUInt32((uint32)((bmax[1]-params.Bmin[1])*quantFactor), 0, 0xffff))\n\t\t\tit.bmax[2] = (uint16)(DtClampUInt32((uint32)((bmax[2]-params.Bmin[2])*quantFactor), 0, 0xffff))\n\t\t} else {\n\t\t\tp := params.Polys[i*int(params.Nvp)*2:]\n\t\t\tit.bmax[0] = params.Verts[p[0]*3+0]\n\t\t\tit.bmin[0] = it.bmax[0]\n\t\t\tit.bmax[1] = params.Verts[p[0]*3+1]\n\t\t\tit.bmin[1] = it.bmax[1]\n\t\t\tit.bmax[2] = params.Verts[p[0]*3+2]\n\t\t\tit.bmin[2] = it.bmax[2]\n\n\t\t\tfor j := 1; j \u003c int(params.Nvp); j++ {\n\t\t\t\tif p[j] == MESH_NULL_IDX {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tx := params.Verts[p[j]*3+0]\n\t\t\t\ty := params.Verts[p[j]*3+1]\n\t\t\t\tz := params.Verts[p[j]*3+2]\n\n\t\t\t\tif x \u003c it.bmin[0] {\n\t\t\t\t\tit.bmin[0] = x\n\t\t\t\t}\n\t\t\t\tif y \u003c it.bmin[1] {\n\t\t\t\t\tit.bmin[1] = y\n\t\t\t\t}\n\t\t\t\tif z \u003c it.bmin[2] {\n\t\t\t\t\tit.bmin[2] = z\n\t\t\t\t}\n\n\t\t\t\tif x \u003e it.bmax[0] {\n\t\t\t\t\tit.bmax[0] = x\n\t\t\t\t}\n\t\t\t\tif y \u003e it.bmax[1] {\n\t\t\t\t\tit.bmax[1] = y\n\t\t\t\t}\n\t\t\t\tif z \u003e it.bmax[2] {\n\t\t\t\t\tit.bmax[2] = z\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remap y\n\t\t\tit.bmin[1] = (uint16)(DtMathFloorf((float32)(it.bmin[1]) * params.Ch / params.Cs))\n\t\t\tit.bmax[1] = (uint16)(DtMathCeilf((float32)(it.bmax[1]) * params.Ch / params.Cs))\n\t\t}\n\t}\n\n\tcurNode := 0\n\tsubdivide(items, int(params.PolyCount), 0, int(params.PolyCount), \u0026curNode, nodes)\n\n\titems = nil\n\n\treturn curNode\n}\n"
            },
            "freeLink": {
                "Name": "freeLink",
                "Code": "func freeLink(tile *DtMeshTile, link uint32) {\n\ttile.Links[link].Next = tile.LinksFreeList\n\ttile.LinksFreeList = link\n}\n"
            },
            "getSlabCoord": {
                "Name": "getSlabCoord",
                "Code": "func getSlabCoord(va []float32, side int) float32 {\n\tif side == 0 || side == 4 {\n\t\treturn va[0]\n\t} else if side == 2 || side == 6 {\n\t\treturn va[2]\n\t}\n\treturn 0\n}\n"
            },
            "insertInterval": {
                "Name": "insertInterval",
                "Code": "func insertInterval(ints []dtSegInterval, nints *int, maxInts int,\n\ttmin, tmax int16, ref DtPolyRef) {\n\tif *nints+1 \u003e maxInts {\n\t\treturn\n\t}\n\t// Find insertion point.\n\tidx := 0\n\tfor idx \u003c *nints {\n\t\tif tmax \u003c= ints[idx].tmin {\n\t\t\tbreak\n\t\t}\n\t\tidx++\n\t}\n\t// Move current results.\n\tif (*nints - idx) != 0 {\n\t\tfor i := *nints; i \u003e= idx+1; i-- {\n\t\t\tints[i] = ints[i-1]\n\t\t}\n\t}\n\t// Store\n\tints[idx].ref = ref\n\tints[idx].tmin = tmin\n\tints[idx].tmax = tmax\n\t(*nints)++\n}\n"
            },
            "longestAxis": {
                "Name": "longestAxis",
                "Code": "func longestAxis(x, y, z uint16) int {\n\taxis := 0\n\tmaxVal := x\n\tif y \u003e maxVal {\n\t\taxis = 1\n\t\tmaxVal = y\n\t}\n\tif z \u003e maxVal {\n\t\taxis = 2\n\t}\n\treturn axis\n}\n"
            },
            "newSorter": {
                "Name": "newSorter",
                "Code": "func newSorter(lst []BVItem, compFunc func(a, b *BVItem) bool) *sorter {\n\treturn \u0026sorter{\n\t\tlst:      lst,\n\t\tcompFunc: compFunc,\n\t}\n}\n"
            },
            "overlapRange": {
                "Name": "overlapRange",
                "Code": "func overlapRange(amin, amax, bmin, bmax, eps float32) bool {\n\treturn !((amin+eps) \u003e bmax || (amax-eps) \u003c bmin)\n}\n"
            },
            "overlapSlabs": {
                "Name": "overlapSlabs",
                "Code": "func overlapSlabs(amin, amax, bmin, bmax []float32, px, py float32) bool {\n\t// Check for horizontal overlap.\n\t// The segment is shrunken a little so that slabs which touch\n\t// at end points are not connected.\n\tminx := DtMaxFloat32(amin[0]+px, bmin[0]+px)\n\tmaxx := DtMinFloat32(amax[0]-px, bmax[0]-px)\n\tif minx \u003e maxx {\n\t\treturn false\n\t}\n\t// Check vertical overlap.\n\tad := (amax[1] - amin[1]) / (amax[0] - amin[0])\n\tak := amin[1] - ad*amin[0]\n\tbd := (bmax[1] - bmin[1]) / (bmax[0] - bmin[0])\n\tbk := bmin[1] - bd*bmin[0]\n\taminy := ad*minx + ak\n\tamaxy := ad*maxx + ak\n\tbminy := bd*minx + bk\n\tbmaxy := bd*maxx + bk\n\tdmin := bminy - aminy\n\tdmax := bmaxy - amaxy\n\n\t// Crossing segments always overlap.\n\tif dmin*dmax \u003c 0 {\n\t\treturn true\n\t}\n\t// Check for overlap at endpoints.\n\tthr := DtSqrFloat32(py * 2)\n\tif dmin*dmin \u003c= thr || dmax*dmax \u003c= thr {\n\t\treturn true\n\t}\n\treturn false\n}\n"
            },
            "projectPoly": {
                "Name": "projectPoly",
                "Code": "func projectPoly(axis, poly []float32, npoly int, rmin, rmax *float32) {\n\t*rmax = DtVdot2D(axis, poly)\n\t*rmin = *rmax\n\tfor i := 1; i \u003c npoly; i++ {\n\t\td := DtVdot2D(axis, poly[i*3:])\n\t\t*rmin = DtMinFloat32(*rmin, d)\n\t\t*rmax = DtMaxFloat32(*rmax, d)\n\t}\n}\n"
            },
            "subdivide": {
                "Name": "subdivide",
                "Code": "func subdivide(items []BVItem, nitems, imin, imax int, curNode *int, nodes []DtBVNode) {\n\tinum := imax - imin\n\ticur := *curNode\n\n\tnode := \u0026nodes[*curNode]\n\t(*curNode)++\n\n\tif inum == 1 {\n\t\t// Leaf\n\t\tnode.Bmin[0] = items[imin].bmin[0]\n\t\tnode.Bmin[1] = items[imin].bmin[1]\n\t\tnode.Bmin[2] = items[imin].bmin[2]\n\n\t\tnode.Bmax[0] = items[imin].bmax[0]\n\t\tnode.Bmax[1] = items[imin].bmax[1]\n\t\tnode.Bmax[2] = items[imin].bmax[2]\n\n\t\tnode.I = int32(items[imin].i)\n\t} else {\n\t\t// Split\n\t\tcalcExtends(items, nitems, imin, imax, node.Bmin[:], node.Bmax[:])\n\n\t\taxis := longestAxis(node.Bmax[0]-node.Bmin[0],\n\t\t\tnode.Bmax[1]-node.Bmin[1],\n\t\t\tnode.Bmax[2]-node.Bmin[2])\n\n\t\tif axis == 0 {\n\t\t\t// Sort along x-axis\n\t\t\tsort.Sort(newSorter(items[imin:imin+inum], compareItemX))\n\t\t} else if axis == 1 {\n\t\t\t// Sort along y-axis\n\t\t\tsort.Sort(newSorter(items[imin:imin+inum], compareItemY))\n\t\t} else {\n\t\t\t// Sort along z-axis\n\t\t\tsort.Sort(newSorter(items[imin:imin+inum], compareItemZ))\n\t\t}\n\n\t\tisplit := imin + inum/2\n\n\t\t// Left\n\t\tsubdivide(items, nitems, imin, isplit, curNode, nodes)\n\t\t// Right\n\t\tsubdivide(items, nitems, isplit, imax, curNode, nodes)\n\n\t\tiescape := *curNode - icur\n\t\t// Negative index means escape.\n\t\tnode.I = int32(-iescape)\n\t}\n}\n"
            },
            "vperpXZ": {
                "Name": "vperpXZ",
                "Code": "func vperpXZ(a, b []float32) float32 {\n\treturn a[0]*b[2] - a[2]*b[0]\n}\n"
            }
        }
    },
    {
        "Name": "main",
        "Structs": {},
        "Functions": {
            "main": {
                "Name": "main",
                "Code": "func main() {\n\tvar mesh = loader.LoadTileMesh(\"../assets/navmesh.bin\")\n\tif mesh == nil {\n\t\tpanic(\"load mesh failed.\")\n\t}\n\n\tvar meshQuery = detour.DtAllocNavMeshQuery()\n\tvar status = meshQuery.Init(mesh, 2048)\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"init mesh query failed.\")\n\t}\n\n\tvar meshFilter = detour.DtAllocDtQueryFilter()\n\n\tvar crowd = dtcrowd.DtAllocCrowd()\n\tif !crowd.Init(1, 0.5, mesh) {\n\t\tpanic(\"init crowd failed.\")\n\t}\n\n\tvar agentPos [3]float32\n\tvar agentHalfExtents = [3]float32{1, 0.75, 1}\n\tvar agentNearestPoly detour.DtPolyRef\n\tstatus = meshQuery.FindNearestPoly(agentPos[:], agentHalfExtents[:], meshFilter, \u0026agentNearestPoly, agentPos[:])\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"find closest point failed.\")\n\t}\n\n\tvar agentParams = dtcrowd.DtAllocCrowdAgentParams().\n\t\tSetRadius(0.5).\n\t\tSetHeight(2).\n\t\tSetMaxAcceleration(6).\n\t\tSetMaxSpeed(10).\n\t\tSetCollisionQueryRange(0.3 * 12).\n\t\tSetPathOptimizationRange(0.3 * 30)\n\tvar agentId = crowd.AddAgent(agentPos[:], agentParams)\n\n\tvar agentTarget = [3]float32{1.1322085857391357, 10.197294235229492, -5.400757312774658}\n\tvar agentTragetRef detour.DtPolyRef\n\tstatus = meshQuery.FindNearestPoly(agentTarget[:], agentHalfExtents[:], meshFilter, \u0026agentTragetRef, agentTarget[:])\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"find agent target closest point failed.\")\n\t}\n\n\tcrowd.RequestMoveTarget(agentId, agentTragetRef, agentTarget[:])\n\n\tvar path [256]detour.DtPolyRef\n\tvar pathCount int\n\tmeshQuery.FindPath(agentNearestPoly, agentTragetRef, agentPos[:], agentTarget[:], meshFilter, path[:], \u0026pathCount, 256)\n\n\tvar straightPath [256 * 3]float32\n\tvar straightPathFlags [256]detour.DtStraightPathFlags\n\tvar straightPathRef [256]detour.DtPolyRef\n\tvar straightPathCount int\n\tmeshQuery.FindStraightPath(agentPos[:], agentTarget[:], path[:], pathCount, straightPath[:], straightPathFlags[:], straightPathRef[:], \u0026straightPathCount, 256, 0)\n\tfmt.Println(straightPath[:pathCount*3])\n\n\tvar agent = crowd.GetAgent(agentId)\n\tfmt.Println(agent.GetCurrentPos())\n\tfor i := 0; i \u003c 100; i += 1 {\n\t\tcrowd.Update(0.1, nil)\n\t\tfmt.Println(agent.GetCurrentPos())\n\t}\n}\n"
            }
        }
    },
    {
        "Name": "main",
        "Structs": {},
        "Functions": {
            "main": {
                "Name": "main",
                "Code": "func main() {\n\tvar mesh = loader.LoadTileMesh(\"./navmesh.bin\")\n\tif mesh == nil {\n\t\tpanic(\"load mesh failed.\")\n\t}\n\n\tvar meshQuery = detour.DtAllocNavMeshQuery()\n\tvar status = meshQuery.Init(mesh, 2048)\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"init mesh query failed.\")\n\t}\n\n\tvar meshFilter = detour.DtAllocDtQueryFilter()\n\n\tvar agentPos [3]float32\n\tvar agentHalfExtents = [3]float32{1, 0.75, 1}\n\tvar agentNearestPoly detour.DtPolyRef\n\tstatus = meshQuery.FindNearestPoly(agentPos[:], agentHalfExtents[:], meshFilter, \u0026agentNearestPoly, agentPos[:])\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"find closest point failed.\")\n\t}\n\n\tvar agentTarget = [3]float32{1.1322085857391357, 10.197294235229492, -5.400757312774658}\n\tvar agentTragetRef detour.DtPolyRef\n\tstatus = meshQuery.FindNearestPoly(agentTarget[:], agentHalfExtents[:], meshFilter, \u0026agentTragetRef, agentTarget[:])\n\tif detour.DtStatusFailed(status) {\n\t\tpanic(\"find agent target closest point failed.\")\n\t}\n\n\tvar path [256]detour.DtPolyRef\n\tvar pathCount int\n\tmeshQuery.FindPath(agentNearestPoly, agentTragetRef, agentPos[:], agentTarget[:], meshFilter, path[:], \u0026pathCount, 256)\n\n\tvar straightPath [256 * 3]float32\n\tvar straightPathFlags [256]detour.DtStraightPathFlags\n\tvar straightPathRef [256]detour.DtPolyRef\n\tvar straightPathCount int\n\tmeshQuery.FindStraightPath(agentPos[:], agentTarget[:], path[:], pathCount, straightPath[:], straightPathFlags[:], straightPathRef[:], \u0026straightPathCount, 256, 0)\n\tfmt.Println(straightPath[:straightPathCount*3])\n}\n"
            }
        }
    },
    {
        "Name": "main",
        "Structs": {},
        "Functions": {
            "main": {
                "Name": "main",
                "Code": "func main() {\r\n\tr := gin.Default()\r\n\tr.Use(cors.Default())\r\n\tr.StaticFS(\"/public\", http.Dir(\"./public\"))\r\n\r\n\tserver := debugger.NewServer(r)\r\n\t_ = server\r\n\r\n\tr.Run(\":9001\")\r\n}\r"
            }
        }
    },
    {
        "Name": "fastlz",
        "Structs": {},
        "Functions": {
            "Fastlz_compress": {
                "Name": "Fastlz_compress",
                "Code": "func Fastlz_compress(input []byte, length int, output []byte) int {\n\t/* for short block, choose fastlz1 */\n\tif length \u003c 65536 {\n\t\treturn fastlz1_compress(input, length, output)\n\t}\n\t/* else... */\n\treturn fastlz2_compress(input, length, output)\n}\n"
            },
            "Fastlz_compress_level": {
                "Name": "Fastlz_compress_level",
                "Code": "func Fastlz_compress_level(level int, input []byte, length int, output []byte) int {\n\tif len(output) \u003c int(math.Max(66, float64(length)*1.05)) {\n\t\treturn 0\n\t}\n\tif level == 1 {\n\t\treturn fastlz1_compress(input, length, output)\n\t}\n\tif level == 2 {\n\t\treturn fastlz2_compress(input, length, output)\n\t}\n\treturn 0\n}\n"
            },
            "Fastlz_decompress": {
                "Name": "Fastlz_decompress",
                "Code": "func Fastlz_decompress(input []byte, length int, output []byte, maxout int) int {\n\t/* magic identifier for compression level */\n\tlevel := ((*(*uint8)(unsafe.Pointer(\u0026input[0]))) \u003e\u003e 5) + 1\n\n\tif level == 1 {\n\t\treturn fastlz1_decompress(input, length, output, maxout)\n\t}\n\tif level == 2 {\n\t\treturn fastlz2_decompress(input, length, output, maxout)\n\t}\n\t/* unknown level, trigger error */\n\treturn 0\n}\n"
            },
            "fastlz1_compress": {
                "Name": "fastlz1_compress",
                "Code": "func fastlz1_compress(input []byte, length int, output []byte) int {\n\tvar ip uint = 0\n\tvar ip_bound uint = uint(length - 2)\n\tvar ip_limit uint = uint(length - 12)\n\tvar op uint = 0\n\n\tvar htab [HASH_SIZE]uint\n\tvar hslot uint\n\tvar hval uint\n\n\tvar copy uint\n\n\t/* sanity check */\n\tif length \u003c 4 {\n\t\tif length != 0 {\n\t\t\t/* create literal copy only */\n\t\t\toutput[op] = byte(length - 1)\n\t\t\top++\n\t\t\tip_bound++\n\t\t\tfor ip \u003c= ip_bound {\n\t\t\t\toutput[op] = input[ip]\n\t\t\t\top++\n\t\t\t\tip++\n\t\t\t}\n\t\t\treturn length + 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t/* initializes hash table */\n\t// do nothing\n\n\t/* we start with literal copy */\n\tcopy = 2\n\toutput[op] = MAX_COPY - 1\n\top++\n\toutput[op] = input[ip]\n\top++\n\tip++\n\toutput[op] = input[ip]\n\top++\n\tip++\n\n\t/* main loop */\n\tfor ip \u003c ip_limit {\n\t\tvar ref uint\n\t\tvar distance uint\n\n\t\t/* minimum match length */\n\t\tvar len uint = 3\n\n\t\t/* comparison starting-point */\n\t\tanchor := ip\n\n\t\t/* check for a run */\n\t\t// do nothing\n\n\t\t/* find potential match */\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\n\t\thslot = hval\n\t\tref = htab[hval]\n\n\t\t/* calculate distance to the match */\n\t\tdistance = anchor - ref\n\n\t\t/* update hash table */\n\t\thtab[hslot] = anchor\n\n\t\t/* is this a match? check the first 3 bytes */\n\t\tif distance == 0 ||\n\t\t\t(distance \u003e= MAX_DISTANCE1) ||\n\t\t\tinput[ref] != input[ip] || input[ref+1] != input[ip+1] || input[ref+2] != input[ip+2] {\n\t\t\tgoto literal\n\t\t}\n\n\t\t/* last matched byte */\n\t\tref += len\n\t\tip = anchor + len\n\n\t\t/* distance is biased */\n\t\tdistance--\n\n\t\tif distance == 0 {\n\t\t\t/* zero distance means a run */\n\t\t\tx := input[ip-1]\n\t\t\tfor ip \u003c ip_bound {\n\t\t\t\tif input[ref] != x {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tip++\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t}\n\t\t} else {\n\t\t\tfor {\n\t\t\t\t/* safe because the outer check against ip limit */\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\n\t\t\t\tfor ip \u003c ip_bound {\n\t\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tref++\n\t\t\t\t\tip++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tref++\n\t\t\tip++\n\t\t}\n\t\t/* if we have copied something, adjust the copy count */\n\t\tif copy != 0 {\n\t\t\t/* copy is biased, '0' means 1 byte copy */\n\t\t\toutput[op-copy-1] = byte(copy - 1)\n\t\t} else {\n\t\t\t/* back, to overwrite the copy count */\n\t\t\top--\n\t\t}\n\t\t/* reset literal counter */\n\t\tcopy = 0\n\n\t\t/* length is biased, '1' means a match of 3 bytes */\n\t\tip -= 3\n\t\tlen = ip - anchor\n\n\t\t/* encode the match */\n\t\tfor len \u003e MAX_LEN-2 {\n\t\t\toutput[op] = byte((7 \u003c\u003c 5) + (distance \u003e\u003e 8))\n\t\t\top++\n\t\t\toutput[op] = MAX_LEN - 2 - 7 - 2\n\t\t\top++\n\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\top++\n\t\t\tlen -= MAX_LEN - 2\n\t\t}\n\n\t\tif len \u003c 7 {\n\t\t\toutput[op] = byte((len \u003c\u003c 5) + (distance \u003e\u003e 8))\n\t\t\top++\n\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\top++\n\t\t} else {\n\t\t\toutput[op] = byte((7 \u003c\u003c 5) + (distance \u003e\u003e 8))\n\t\t\top++\n\t\t\toutput[op] = byte(len - 7)\n\t\t\top++\n\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\top++\n\t\t}\n\n\t\t/* update the hash at match boundary */\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\t\thtab[hval] = ip\n\t\tip++\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\t\thtab[hval] = ip\n\t\tip++\n\n\t\t/* assuming literal copy */\n\t\toutput[op] = MAX_COPY - 1\n\t\top++\n\n\t\tcontinue\n\n\tliteral:\n\t\toutput[op] = input[anchor]\n\t\top++\n\t\tanchor++\n\t\tip = anchor\n\t\tcopy++\n\t\tif copy == MAX_COPY {\n\t\t\tcopy = 0\n\t\t\toutput[op] = MAX_COPY - 1\n\t\t\top++\n\t\t}\n\t}\n\n\t/* left-over as literal copy */\n\tip_bound++\n\tfor ip \u003c= ip_bound {\n\t\toutput[op] = input[ip]\n\t\top++\n\t\tip++\n\t\tcopy++\n\t\tif copy == MAX_COPY {\n\t\t\tcopy = 0\n\t\t\toutput[op] = MAX_COPY - 1\n\t\t\top++\n\t\t}\n\t}\n\n\t/* if we have copied something, adjust the copy length */\n\tif copy != 0 {\n\t\toutput[op-copy-1] = byte(copy - 1)\n\t} else {\n\t\top--\n\t}\n\n\treturn int(op)\n}\n"
            },
            "fastlz1_decompress": {
                "Name": "fastlz1_decompress",
                "Code": "func fastlz1_decompress(input []byte, length int, output []byte, maxout int) int {\n\tvar ip uint = 0\n\tvar ip_limit uint = uint(length)\n\tvar op uint = 0\n\tvar op_limit uint = uint(maxout)\n\tvar ctrl uint = uint(input[ip] \u0026 31)\n\tip++\n\tloop := true\n\n\tfor loop {\n\t\tref := op\n\t\tlen := ctrl \u003e\u003e 5\n\t\tofs := (ctrl \u0026 31) \u003c\u003c 8\n\n\t\tif ctrl \u003e= 32 {\n\t\t\tlen--\n\t\t\tref -= ofs\n\t\t\tif len == 7-1 {\n\t\t\t\tlen += uint(input[ip])\n\t\t\t\tip++\n\t\t\t}\n\t\t\tref -= uint(input[ip])\n\t\t\tip++\n\n\t\t\tif op+len+3 \u003e op_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif int(ref-1) \u003c 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif ip \u003c ip_limit {\n\t\t\t\tctrl = uint(input[ip])\n\t\t\t\tip++\n\t\t\t} else {\n\t\t\t\tloop = false\n\t\t\t}\n\t\t\tif ref == op {\n\t\t\t\t/* optimize copy for a run */\n\t\t\t\tb := output[ref-1]\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\tfor ; len != 0; len-- {\n\t\t\t\t\toutput[op] = b\n\t\t\t\t\top++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* copy from reference */\n\t\t\t\tref--\n\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\n\t\t\t\tfor ; len != 0; len-- {\n\t\t\t\t\toutput[op] = output[ref]\n\t\t\t\t\top++\n\t\t\t\t\tref++\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tctrl++\n\t\t\tif op+ctrl \u003e op_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif ip+ctrl \u003e ip_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\toutput[op] = input[ip]\n\t\t\top++\n\t\t\tip++\n\t\t\tfor ctrl--; ctrl != 0; ctrl-- {\n\t\t\t\toutput[op] = input[ip]\n\t\t\t\top++\n\t\t\t\tip++\n\t\t\t}\n\t\t\tloop = (ip \u003c ip_limit)\n\t\t\tif loop {\n\t\t\t\tctrl = uint(input[ip])\n\t\t\t\tip++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn int(op)\n}\n"
            },
            "fastlz2_compress": {
                "Name": "fastlz2_compress",
                "Code": "func fastlz2_compress(input []byte, length int, output []byte) int {\n\tvar ip uint = 0\n\tvar ip_bound uint = uint(length - 2)\n\tvar ip_limit uint = uint(length - 12)\n\tvar op uint = 0\n\n\tvar htab [HASH_SIZE]uint\n\tvar hslot uint\n\tvar hval uint\n\n\tvar copy uint\n\n\t/* sanity check */\n\tif length \u003c 4 {\n\t\tif length != 0 {\n\t\t\t/* create literal copy only */\n\t\t\toutput[op] = byte(length - 1)\n\t\t\top++\n\t\t\tip_bound++\n\t\t\tfor ip \u003c= ip_bound {\n\t\t\t\toutput[op] = input[ip]\n\t\t\t\top++\n\t\t\t\tip++\n\t\t\t}\n\t\t\treturn length + 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t/* initializes hash table */\n\t// do nothing\n\n\t/* we start with literal copy */\n\tcopy = 2\n\toutput[op] = MAX_COPY - 1\n\top++\n\toutput[op] = input[ip]\n\top++\n\tip++\n\toutput[op] = input[ip]\n\top++\n\tip++\n\n\t/* main loop */\n\tfor ip \u003c ip_limit {\n\t\tvar ref uint\n\t\tvar distance uint\n\n\t\t/* minimum match length */\n\t\tvar len uint = 3\n\n\t\t/* comparison starting-point */\n\t\tanchor := ip\n\n\t\t/* check for a run */\n\t\tif input[ip] == input[ip-1] \u0026\u0026 (uint(input[ip-1])|uint(input[ip])\u003c\u003c8) == (uint(input[ip+1])|uint(input[ip+2])\u003c\u003c8) {\n\t\t\tdistance = 1\n\t\t\tip += 3\n\t\t\tref = anchor - 1 + 3\n\t\t\tgoto match\n\t\t}\n\n\t\t/* find potential match */\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\n\t\thslot = hval\n\t\tref = htab[hval]\n\n\t\t/* calculate distance to the match */\n\t\tdistance = anchor - ref\n\n\t\t/* update hash table */\n\t\thtab[hslot] = anchor\n\n\t\t/* is this a match? check the first 3 bytes */\n\t\tif distance == 0 ||\n\t\t\t(distance \u003e= MAX_FARDISTANCE) ||\n\t\t\tinput[ref] != input[ip] || input[ref+1] != input[ip+1] || input[ref+2] != input[ip+2] {\n\t\t\tgoto literal\n\t\t}\n\n\t\t/* far, needs at least 5-byte match */\n\t\tif distance \u003e= MAX_DISTANCE2 {\n\t\t\tif input[ref+3] != input[ip+3] || input[ref+4] != input[ip+4] {\n\t\t\t\tgoto literal\n\t\t\t}\n\t\t\tlen += 2\n\t\t}\n\n\t\tref += len\n\n\tmatch:\n\n\t\t/* last matched byte */\n\t\tip = anchor + len\n\n\t\t/* distance is biased */\n\t\tdistance--\n\n\t\tif distance == 0 {\n\t\t\t/* zero distance means a run */\n\t\t\tx := input[ip-1]\n\t\t\tfor ip \u003c ip_bound {\n\t\t\t\tif input[ref] != x {\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tip++\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t}\n\t\t} else {\n\t\t\tfor {\n\t\t\t\t/* safe because the outer check against ip limit */\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tref++\n\t\t\t\tip++\n\n\t\t\t\tfor ip \u003c ip_bound {\n\t\t\t\t\tif input[ref] != input[ip] {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tref++\n\t\t\t\t\tip++\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tref++\n\t\t\tip++\n\t\t}\n\t\t/* if we have copied something, adjust the copy count */\n\t\tif copy != 0 {\n\t\t\t/* copy is biased, '0' means 1 byte copy */\n\t\t\toutput[op-copy-1] = byte(copy - 1)\n\t\t} else {\n\t\t\t/* back, to overwrite the copy count */\n\t\t\top--\n\t\t}\n\t\t/* reset literal counter */\n\t\tcopy = 0\n\n\t\t/* length is biased, '1' means a match of 3 bytes */\n\t\tip -= 3\n\t\tlen = ip - anchor\n\n\t\t/* encode the match */\n\t\tif distance \u003c MAX_DISTANCE2 {\n\t\t\tif len \u003c 7 {\n\t\t\t\toutput[op] = byte((len \u003c\u003c 5) + (distance \u003e\u003e 8))\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\t\top++\n\t\t\t} else {\n\t\t\t\toutput[op] = byte((7 \u003c\u003c 5) + (distance \u003e\u003e 8))\n\t\t\t\top++\n\t\t\t\tfor len -= 7; len \u003e= 255; len -= 255 {\n\t\t\t\t\toutput[op] = 255\n\t\t\t\t\top++\n\t\t\t\t}\n\t\t\t\toutput[op] = byte(len)\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\t\top++\n\t\t\t}\n\t\t} else {\n\t\t\t/* far away, but not yet in the another galaxy... */\n\t\t\tif len \u003c 7 {\n\t\t\t\tdistance -= MAX_DISTANCE2\n\t\t\t\toutput[op] = byte((len \u003c\u003c 5) + 31)\n\t\t\t\top++\n\t\t\t\toutput[op] = 255\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u003e\u003e 8)\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\t\top++\n\t\t\t} else {\n\t\t\t\tdistance -= MAX_DISTANCE2\n\t\t\t\toutput[op] = (7 \u003c\u003c 5) + 31\n\t\t\t\top++\n\t\t\t\tfor len -= 7; len \u003e= 255; len -= 255 {\n\t\t\t\t\toutput[op] = 255\n\t\t\t\t\top++\n\t\t\t\t}\n\t\t\t\toutput[op] = byte(len)\n\t\t\t\top++\n\t\t\t\toutput[op] = 255\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u003e\u003e 8)\n\t\t\t\top++\n\t\t\t\toutput[op] = byte(distance \u0026 255)\n\t\t\t\top++\n\t\t\t}\n\t\t}\n\n\t\t/* update the hash at match boundary */\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\t\thtab[hval] = ip\n\t\tip++\n\t\thval = (uint(input[ip]) | uint(input[ip+1])\u003c\u003c8)\n\t\thval ^= (uint(input[ip+1]) | uint(input[ip+2])\u003c\u003c8) ^ (hval \u003e\u003e (16 - HASH_LOG))\n\t\thval \u0026= HASH_MASK\n\t\thtab[hval] = ip\n\t\tip++\n\n\t\t/* assuming literal copy */\n\t\toutput[op] = MAX_COPY - 1\n\t\top++\n\n\t\tcontinue\n\n\tliteral:\n\t\toutput[op] = input[anchor]\n\t\top++\n\t\tanchor++\n\t\tip = anchor\n\t\tcopy++\n\t\tif copy == MAX_COPY {\n\t\t\tcopy = 0\n\t\t\toutput[op] = MAX_COPY - 1\n\t\t\top++\n\t\t}\n\t}\n\n\t/* left-over as literal copy */\n\tip_bound++\n\tfor ip \u003c= ip_bound {\n\t\toutput[op] = input[ip]\n\t\top++\n\t\tip++\n\t\tcopy++\n\t\tif copy == MAX_COPY {\n\t\t\tcopy = 0\n\t\t\toutput[op] = MAX_COPY - 1\n\t\t\top++\n\t\t}\n\t}\n\n\t/* if we have copied something, adjust the copy length */\n\tif copy != 0 {\n\t\toutput[op-copy-1] = byte(copy - 1)\n\t} else {\n\t\top--\n\t}\n\n\t/* marker for fastlz2 */\n\toutput[0] |= (1 \u003c\u003c 5)\n\n\treturn int(op)\n}\n"
            },
            "fastlz2_decompress": {
                "Name": "fastlz2_decompress",
                "Code": "func fastlz2_decompress(input []byte, length int, output []byte, maxout int) int {\n\tvar ip uint = 0\n\tvar ip_limit uint = uint(length)\n\tvar op uint = 0\n\tvar op_limit uint = uint(maxout)\n\tvar ctrl uint = uint(input[ip] \u0026 31)\n\tip++\n\tloop := true\n\n\tfor loop {\n\t\tref := op\n\t\tlen := ctrl \u003e\u003e 5\n\t\tofs := (ctrl \u0026 31) \u003c\u003c 8\n\n\t\tif ctrl \u003e= 32 {\n\t\t\tvar code byte\n\t\t\tlen--\n\t\t\tref -= ofs\n\t\t\tif len == 7-1 {\n\t\t\t\tcode = 255\n\t\t\t\tfor code == 255 {\n\t\t\t\t\tcode = input[ip]\n\t\t\t\t\tip++\n\t\t\t\t\tlen += uint(code)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode = input[ip]\n\t\t\tip++\n\t\t\tref -= uint(code)\n\n\t\t\t/* match from 16-bit distance */\n\t\t\tif code == 255 {\n\t\t\t\tif ofs == (31 \u003c\u003c 8) {\n\t\t\t\t\tofs = uint(input[ip]) \u003c\u003c 8\n\t\t\t\t\tip++\n\t\t\t\t\tofs += uint(input[ip])\n\t\t\t\t\tip++\n\t\t\t\t\tref = op - ofs - MAX_DISTANCE2\n\t\t\t\t}\n\t\t\t}\n\t\t\tif op+len+3 \u003e op_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif int(ref-1) \u003c 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif ip \u003c ip_limit {\n\t\t\t\tctrl = uint(input[ip])\n\t\t\t\tip++\n\t\t\t} else {\n\t\t\t\tloop = false\n\t\t\t}\n\t\t\tif ref == op {\n\t\t\t\t/* optimize copy for a run */\n\t\t\t\tb := output[ref-1]\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\toutput[op] = b\n\t\t\t\top++\n\t\t\t\tfor ; len != 0; len-- {\n\t\t\t\t\toutput[op] = b\n\t\t\t\t\top++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* copy from reference */\n\t\t\t\tref--\n\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\t\t\t\toutput[op] = output[ref]\n\t\t\t\top++\n\t\t\t\tref++\n\n\t\t\t\tfor ; len != 0; len-- {\n\t\t\t\t\toutput[op] = output[ref]\n\t\t\t\t\top++\n\t\t\t\t\tref++\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tctrl++\n\t\t\tif op+ctrl \u003e op_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif ip+ctrl \u003e ip_limit {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\toutput[op] = input[ip]\n\t\t\top++\n\t\t\tip++\n\t\t\tfor ctrl--; ctrl != 0; ctrl-- {\n\t\t\t\toutput[op] = input[ip]\n\t\t\t\top++\n\t\t\t\tip++\n\t\t\t}\n\t\t\tloop = (ip \u003c ip_limit)\n\t\t\tif loop {\n\t\t\t\tctrl = uint(input[ip])\n\t\t\t\tip++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn int(op)\n}\n"
            }
        }
    },
    {
        "Name": "loader",
        "Structs": {
            "FastLZCompressor": {
                "Name": "FastLZCompressor",
                "Code": "type FastLZCompressor struct{}\n",
                "Methods": {
                    "Compress": {
                        "Name": "Compress",
                        "Code": "func (c *FastLZCompressor) Compress(buffer []byte, bufferSize int32, compressed []byte, maxCompressedSize int32, compressedSize *int32) detour.DtStatus {\n\t*compressedSize = int32(fastlz.Fastlz_compress(buffer, int(bufferSize), compressed))\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "Decompress": {
                        "Name": "Decompress",
                        "Code": "func (c *FastLZCompressor) Decompress(compressed []byte, compressedSize int32, buffer []byte, maxBufferSize int32, bufferSize *int32) detour.DtStatus {\n\t*bufferSize = int32(fastlz.Fastlz_decompress(compressed, int(compressedSize), buffer, int(maxBufferSize)))\n\tif *bufferSize \u003c 0 {\n\t\treturn detour.DT_FAILURE\n\t} else {\n\t\treturn detour.DT_SUCCESS\n\t}\n}\n"
                    },
                    "MaxCompressedSize": {
                        "Name": "MaxCompressedSize",
                        "Code": "func (c *FastLZCompressor) MaxCompressedSize(bufferSize int32) int32 {\n\treturn int32(float64(bufferSize) * 1.05)\n}\n"
                    }
                }
            },
            "MeshProcess": {
                "Name": "MeshProcess",
                "Code": "type MeshProcess struct{}\n",
                "Methods": {
                    "Process": {
                        "Name": "Process",
                        "Code": "func (p *MeshProcess) Process(params *detour.DtNavMeshCreateParams, polyAreas []uint8, polyFlags []uint16) {\n\t// Update poly flags from areas.\n\tfor i := 0; i \u003c int(params.PolyCount); i++ {\n\t\tif polyAreas[i] == dtcache.DT_TILECACHE_WALKABLE_AREA {\n\t\t\tpolyAreas[i] = POLYAREA_GROUND\n\t\t}\n\t\tif polyAreas[i] == POLYAREA_GROUND ||\n\t\t\tpolyAreas[i] == POLYAREA_GRASS ||\n\t\t\tpolyAreas[i] == POLYAREA_ROAD {\n\t\t\tpolyFlags[i] = POLYFLAGS_WALK\n\t\t} else if polyAreas[i] == POLYAREA_WATER {\n\t\t\tpolyFlags[i] = POLYFLAGS_SWIM\n\t\t} else if polyAreas[i] == POLYAREA_DOOR {\n\t\t\tpolyFlags[i] = POLYFLAGS_WALK | POLYFLAGS_DOOR\n\t\t}\n\t}\n}\n"
                    }
                }
            },
            "NavMeshSetHeader": {
                "Name": "NavMeshSetHeader",
                "Code": "type NavMeshSetHeader struct {\n\tmagic    int32\n\tversion  int32\n\tnumTiles int32\n\tparams   detour.DtNavMeshParams\n}\n",
                "Methods": {}
            },
            "NavMeshTileHeader": {
                "Name": "NavMeshTileHeader",
                "Code": "type NavMeshTileHeader struct {\n\ttileRef  detour.DtTileRef\n\tdataSize int32\n}\n",
                "Methods": {}
            },
            "TileCacheSetHeader": {
                "Name": "TileCacheSetHeader",
                "Code": "type TileCacheSetHeader struct {\n\tmagic       int32\n\tversion     int32\n\tnumTiles    int32\n\tparams      detour.DtNavMeshParams\n\tcacheParams dtcache.DtTileCacheParams\n}\n",
                "Methods": {}
            },
            "TileCacheTileHeader": {
                "Name": "TileCacheTileHeader",
                "Code": "type TileCacheTileHeader struct {\n\ttileRef  dtcache.DtCompressedTileRef\n\tdataSize int32\n}\n",
                "Methods": {}
            }
        },
        "Functions": {
            "LoadTempObstacles": {
                "Name": "LoadTempObstacles",
                "Code": "func LoadTempObstacles(path string) (*detour.DtNavMesh, *dtcache.DtTileCache) {\n\tmeshData, err := os.ReadFile(path)\n\tdetour.DtAssert(err == nil)\n\n\treturn LoadTempObstaclesByBytes(meshData)\n}\n"
            },
            "LoadTempObstaclesByBytes": {
                "Name": "LoadTempObstaclesByBytes",
                "Code": "func LoadTempObstaclesByBytes(data []byte) (*detour.DtNavMesh, *dtcache.DtTileCache) {\n\n\theader := (*TileCacheSetHeader)(unsafe.Pointer(\u0026(data[0])))\n\tif header.magic != TILECACHESET_MAGIC {\n\t\treturn nil, nil\n\t}\n\tif header.version != TILECACHESET_VERSION {\n\t\treturn nil, nil\n\t}\n\n\tvar navMesh = detour.DtAllocNavMesh()\n\tif navMesh == nil {\n\t\treturn nil, nil\n\t}\n\n\tvar status = navMesh.Init(\u0026header.params)\n\tif detour.DtStatusFailed(status) {\n\t\treturn nil, nil\n\t}\n\n\tvar tileCache = dtcache.DtAllocTileCache()\n\tif tileCache == nil {\n\t\treturn nil, nil\n\t}\n\n\tstatus = tileCache.Init(\u0026header.cacheParams, \u0026FastLZCompressor{}, \u0026MeshProcess{})\n\tif detour.DtStatusFailed(status) {\n\t\treturn nil, nil\n\t}\n\n\tvar offset = int(unsafe.Sizeof(*header))\n\tfor i := 0; i \u003c int(header.numTiles); i++ {\n\t\ttileHeader := (*TileCacheTileHeader)(unsafe.Pointer(\u0026(data[offset])))\n\t\toffset += int(unsafe.Sizeof(*tileHeader))\n\t\tif tileHeader.tileRef == 0 || tileHeader.dataSize == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tvar tempData []byte\n\t\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026tempData)))\n\t\tsliceHeader.Cap = int(tileHeader.dataSize)\n\t\tsliceHeader.Len = int(tileHeader.dataSize)\n\t\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026data[offset]))\n\t\toffset += int(tileHeader.dataSize)\n\t\tdata := make([]byte, tileHeader.dataSize)\n\t\tcopy(data, tempData)\n\n\t\tvar tile dtcache.DtCompressedTileRef\n\t\tstatus = tileCache.AddTile(data, tileHeader.dataSize, dtcache.DT_COMPRESSEDTILE_FREE_DATA, \u0026tile)\n\t\tdetour.DtAssert(detour.DtStatusSucceed(status))\n\n\t\tif tile != 0 {\n\t\t\ttileCache.BuildNavMeshTile(tile, navMesh)\n\t\t} else {\n\t\t\tdetour.DtAssert(false)\n\t\t}\n\t}\n\treturn navMesh, tileCache\n}\n"
            },
            "LoadTileMesh": {
                "Name": "LoadTileMesh",
                "Code": "func LoadTileMesh(path string) *detour.DtNavMesh {\n\tmeshData, err := os.ReadFile(path)\n\tdetour.DtAssert(err == nil)\n\n\treturn LoadTileMeshByBytes(meshData)\n}\n"
            },
            "LoadTileMeshByBytes": {
                "Name": "LoadTileMeshByBytes",
                "Code": "func LoadTileMeshByBytes(data []byte) *detour.DtNavMesh {\n\theader := (*NavMeshSetHeader)(unsafe.Pointer(\u0026(data[0])))\n\tif header.magic != NAVMESHSET_MAGIC {\n\t\treturn nil\n\t}\n\tif header.version != NAVMESHSET_VERSION {\n\t\treturn nil\n\t}\n\n\tvar navMesh = detour.DtAllocNavMesh()\n\tif navMesh == nil {\n\t\treturn nil\n\t}\n\n\tvar status = navMesh.Init(\u0026header.params)\n\tif detour.DtStatusFailed(status) {\n\t\treturn nil\n\t}\n\n\tvar offset = int32(unsafe.Sizeof(*header))\n\tfor i := 0; i \u003c int(header.numTiles); i += 1 {\n\t\tvar tileHeader = (*NavMeshTileHeader)(unsafe.Pointer(\u0026(data[offset])))\n\t\tif tileHeader.tileRef \u003c= 0 || tileHeader.dataSize \u003c= 0 {\n\t\t\tbreak\n\t\t}\n\t\toffset += int32(unsafe.Sizeof(*tileHeader))\n\n\t\ttileData := data[offset : offset+tileHeader.dataSize]\n\t\tnavMesh.AddTile(tileData, int(tileHeader.dataSize), detour.DT_TILE_FREE_DATA, tileHeader.tileRef, nil)\n\t\toffset += tileHeader.dataSize\n\t}\n\n\treturn navMesh\n}\n"
            }
        }
    },
    {
        "Name": "dtcache",
        "Structs": {
            "DtCompressedTile": {
                "Name": "DtCompressedTile",
                "Code": "type DtCompressedTile struct {\n\tSalt           uint32 ///\u003c Counter describing modifications to the tile.\n\tHeader         *DtTileCacheLayerHeader\n\tCompressed     []byte\n\tCompressedSize int32\n\tData           []byte\n\tDataSize       int32\n\tFlags          uint32\n\tNext           *DtCompressedTile\n}\n",
                "Methods": {}
            },
            "DtCompressedTileRef": {
                "Name": "DtCompressedTileRef",
                "Code": "type DtCompressedTileRef uint32\n",
                "Methods": {}
            },
            "DtObstacleBox": {
                "Name": "DtObstacleBox",
                "Code": "type DtObstacleBox struct {\n\tBmin [3]float32\n\tBmax [3]float32\n}\n",
                "Methods": {}
            },
            "DtObstacleCylinder": {
                "Name": "DtObstacleCylinder",
                "Code": "type DtObstacleCylinder struct {\n\tPos    [3]float32\n\tRadius float32\n\tHeight float32\n}\n",
                "Methods": {}
            },
            "DtObstacleOrientedBox": {
                "Name": "DtObstacleOrientedBox",
                "Code": "type DtObstacleOrientedBox struct {\n\tCenter      [3]float32\n\tHalfExtents [3]float32\n\tRotAux      [2]float32 //{ cos(0.5f*angle)*sin(-0.5f*angle); cos(0.5f*angle)*cos(0.5f*angle) - 0.5 }\n}\n",
                "Methods": {}
            },
            "DtObstacleRef": {
                "Name": "DtObstacleRef",
                "Code": "type DtObstacleRef uint32\n",
                "Methods": {}
            },
            "DtTileCache": {
                "Name": "DtTileCache",
                "Code": "type DtTileCache struct {\n\tm_tileLutSize int32 ///\u003c Tile hash lookup size (must be pot).\n\tm_tileLutMask int32 ///\u003c Tile hash lookup mask.\n\n\tm_posLookup    []*DtCompressedTile ///\u003c Tile hash lookup.\n\tm_nextFreeTile *DtCompressedTile   ///\u003c Freelist of tiles.\n\tm_tiles        []DtCompressedTile  ///\u003c List of tiles.\n\n\tm_saltBits uint32 ///\u003c Number of salt bits in the tile ID.\n\tm_tileBits uint32 ///\u003c Number of tile bits in the tile ID.\n\n\tm_params DtTileCacheParams\n\n\tm_tcomp  DtTileCacheCompressor\n\tm_tmproc DtTileCacheMeshProcess\n\n\tm_obstacles        []DtTileCacheObstacle\n\tm_nextFreeObstacle *DtTileCacheObstacle\n\n\tm_reqs  [MAX_REQUESTS]ObstacleRequest\n\tm_nreqs int32\n\n\tm_update  [MAX_UPDATE]DtCompressedTileRef\n\tm_nupdate int32\n}\n",
                "Methods": {
                    "AddBoxObstacle": {
                        "Name": "AddBoxObstacle",
                        "Code": "func (this *DtTileCache) AddBoxObstacle(bmin, bmax []float32, result *DtObstacleRef) detour.DtStatus {\n\tif this.m_nreqs \u003e= MAX_REQUESTS {\n\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t}\n\n\tvar ob *DtTileCacheObstacle\n\tif this.m_nextFreeObstacle != nil {\n\t\tob = this.m_nextFreeObstacle\n\t\tthis.m_nextFreeObstacle = ob.Next\n\t\tob.Next = nil\n\t}\n\tif ob == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tsalt := ob.Salt\n\t*ob = DtTileCacheObstacle{}\n\tob.Salt = salt\n\tob.State = DT_OBSTACLE_PROCESSING\n\tob.Type = DT_OBSTACLE_BOX\n\tdetour.DtVcopy(ob.Box.Bmin[:], bmin)\n\tdetour.DtVcopy(ob.Box.Bmax[:], bmax)\n\n\treq := \u0026this.m_reqs[this.m_nreqs]\n\tthis.m_nreqs++\n\t*req = ObstacleRequest{}\n\treq.action = REQUEST_ADD\n\treq.ref = this.GetObstacleRef(ob)\n\n\tif result != nil {\n\t\t*result = req.ref\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "AddBoxObstacle2": {
                        "Name": "AddBoxObstacle2",
                        "Code": "func (this *DtTileCache) AddBoxObstacle2(center, halfExtents []float32, yRadians float32, result *DtObstacleRef) detour.DtStatus {\n\tif this.m_nreqs \u003e= MAX_REQUESTS {\n\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t}\n\n\tvar ob *DtTileCacheObstacle\n\tif this.m_nextFreeObstacle != nil {\n\t\tob = this.m_nextFreeObstacle\n\t\tthis.m_nextFreeObstacle = ob.Next\n\t\tob.Next = nil\n\t}\n\tif ob == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tsalt := ob.Salt\n\t*ob = DtTileCacheObstacle{}\n\tob.Salt = salt\n\tob.State = DT_OBSTACLE_PROCESSING\n\tob.Type = DT_OBSTACLE_ORIENTED_BOX\n\tdetour.DtVcopy(ob.OrientedBox.Center[:], center)\n\tdetour.DtVcopy(ob.OrientedBox.HalfExtents[:], halfExtents)\n\n\tcoshalf := float32(math.Cos(0.5 * float64(yRadians)))\n\tsinhalf := float32(math.Sin(-0.5 * float64(yRadians)))\n\tob.OrientedBox.RotAux[0] = coshalf * sinhalf\n\tob.OrientedBox.RotAux[1] = coshalf*coshalf - 0.5\n\n\treq := \u0026this.m_reqs[this.m_nreqs]\n\tthis.m_nreqs++\n\t*req = ObstacleRequest{}\n\treq.action = REQUEST_ADD\n\treq.ref = this.GetObstacleRef(ob)\n\n\tif result != nil {\n\t\t*result = req.ref\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "AddObstacle": {
                        "Name": "AddObstacle",
                        "Code": "func (this *DtTileCache) AddObstacle(pos []float32, radius, height float32, result *DtObstacleRef) detour.DtStatus {\n\tif this.m_nreqs \u003e= MAX_REQUESTS {\n\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t}\n\n\tvar ob *DtTileCacheObstacle\n\tif this.m_nextFreeObstacle != nil {\n\t\tob = this.m_nextFreeObstacle\n\t\tthis.m_nextFreeObstacle = ob.Next\n\t\tob.Next = nil\n\t}\n\tif ob == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tsalt := ob.Salt\n\t*ob = DtTileCacheObstacle{}\n\n\tob.Salt = salt\n\tob.State = DT_OBSTACLE_PROCESSING\n\tob.Type = DT_OBSTACLE_CYLINDER\n\tdetour.DtVcopy(ob.Cylinder.Pos[:], pos)\n\tob.Cylinder.Radius = radius\n\tob.Cylinder.Height = height\n\n\treq := \u0026this.m_reqs[this.m_nreqs]\n\tthis.m_nreqs++\n\t*req = ObstacleRequest{}\n\treq.action = REQUEST_ADD\n\treq.ref = this.GetObstacleRef(ob)\n\n\tif result != nil {\n\t\t*result = req.ref\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "AddTile": {
                        "Name": "AddTile",
                        "Code": "func (this *DtTileCache) AddTile(data []byte, dataSize int32, flags uint8, result *DtCompressedTileRef) detour.DtStatus {\n\t// Make sure the data is in right format.\n\theader := (*DtTileCacheLayerHeader)(unsafe.Pointer(\u0026data[0]))\n\tif header.Magic != DT_TILECACHE_MAGIC {\n\t\treturn detour.DT_FAILURE | detour.DT_WRONG_MAGIC\n\t}\n\tif header.Version != DT_TILECACHE_VERSION {\n\t\treturn detour.DT_FAILURE | detour.DT_WRONG_VERSION\n\t}\n\n\t// Make sure the location is free.\n\tif this.GetTileAt(header.Tx, header.Ty, header.Tlayer) != nil {\n\t\treturn detour.DT_FAILURE\n\t}\n\n\t// Allocate a tile.\n\tvar tile *DtCompressedTile\n\tif this.m_nextFreeTile != nil {\n\t\ttile = this.m_nextFreeTile\n\t\tthis.m_nextFreeTile = tile.Next\n\t\ttile.Next = nil\n\t}\n\n\t// Make sure we could allocate a tile.\n\tif tile == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\t// Insert tile into the position lut.\n\th := computeTileHash(header.Tx, header.Ty, this.m_tileLutMask)\n\ttile.Next = this.m_posLookup[h]\n\tthis.m_posLookup[h] = tile\n\n\t// Init tile.\n\theaderSize := int32(detour.DtAlign4(int(DtTileCacheLayerHeaderSize)))\n\ttile.Header = (*DtTileCacheLayerHeader)(unsafe.Pointer(\u0026data[0]))\n\ttile.Data = data\n\ttile.DataSize = dataSize\n\ttile.Compressed = tile.Data[headerSize:]\n\ttile.CompressedSize = tile.DataSize - headerSize\n\ttile.Flags = uint32(flags)\n\n\tif result != nil {\n\t\t*result = this.GetTileRef(tile)\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "BuildNavMeshTile": {
                        "Name": "BuildNavMeshTile",
                        "Code": "func (this *DtTileCache) BuildNavMeshTile(ref DtCompressedTileRef, navmesh *detour.DtNavMesh) detour.DtStatus {\n\tdetour.DtAssert(this.m_tcomp != nil)\n\n\tidx := this.DecodeTileIdTile(ref)\n\tif idx \u003e uint32(this.m_params.MaxTiles) {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[idx]\n\tsalt := this.DecodeTileIdSalt(ref)\n\tif tile.Salt != salt {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\n\tvar bc NavMeshTileBuildContext\n\twalkableClimbVx := int32(this.m_params.WalkableClimb / this.m_params.Ch)\n\tvar status detour.DtStatus\n\n\t// Decompress tile layer data.\n\tstatus = DtDecompressTileCacheLayer(this.m_tcomp, tile.Data, tile.DataSize, \u0026bc.layer)\n\tif detour.DtStatusFailed(status) {\n\t\treturn status\n\t}\n\n\t// Rasterize obstacles.\n\tfor i := int32(0); i \u003c this.m_params.MaxObstacles; i++ {\n\t\tob := \u0026this.m_obstacles[i]\n\t\tif ob.State == DT_OBSTACLE_EMPTY || ob.State == DT_OBSTACLE_REMOVING {\n\t\t\tcontinue\n\t\t}\n\t\tif contains(ob.Touched[:], int32(ob.Ntouched), ref) {\n\t\t\tif ob.Type == DT_OBSTACLE_CYLINDER {\n\t\t\t\tDtMarkCylinderArea(bc.layer, tile.Header.Bmin[:], this.m_params.Cs, this.m_params.Ch,\n\t\t\t\t\tob.Cylinder.Pos[:], ob.Cylinder.Radius, ob.Cylinder.Height, 0)\n\t\t\t} else if ob.Type == DT_OBSTACLE_BOX {\n\t\t\t\tDtMarkBoxArea1(bc.layer, tile.Header.Bmin[:], this.m_params.Cs, this.m_params.Ch,\n\t\t\t\t\tob.Box.Bmin[:], ob.Box.Bmax[:], 0)\n\t\t\t} else if ob.Type == DT_OBSTACLE_ORIENTED_BOX {\n\t\t\t\tDtMarkBoxArea2(bc.layer, tile.Header.Bmin[:], this.m_params.Cs, this.m_params.Ch,\n\t\t\t\t\tob.OrientedBox.Center[:], ob.OrientedBox.HalfExtents[:], ob.OrientedBox.RotAux[:], 0)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Build navmesh\n\tstatus = DtBuildTileCacheRegions(bc.layer, walkableClimbVx)\n\tif detour.DtStatusFailed(status) {\n\t\treturn status\n\t}\n\n\tbc.lcset = DtAllocTileCacheContourSet()\n\tif bc.lcset == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\tstatus = DtBuildTileCacheContours(bc.layer, walkableClimbVx,\n\t\tthis.m_params.MaxSimplificationError, bc.lcset)\n\tif detour.DtStatusFailed(status) {\n\t\treturn status\n\t}\n\n\tbc.lmesh = DtAllocTileCachePolyMesh()\n\tif bc.lmesh == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\tstatus = DtBuildTileCachePolyMesh(bc.lcset, bc.lmesh)\n\tif detour.DtStatusFailed(status) {\n\t\treturn status\n\t}\n\n\t// Early out if the mesh tile is empty.\n\tif bc.lmesh.Npolys == 0 {\n\t\t// Remove existing tile.\n\t\tnavmesh.RemoveTile(navmesh.GetTileRefAt(tile.Header.Tx, tile.Header.Ty, tile.Header.Tlayer), nil, nil)\n\t\treturn detour.DT_SUCCESS\n\t}\n\n\tvar params detour.DtNavMeshCreateParams\n\n\tparams.Verts = bc.lmesh.Verts\n\tparams.VertCount = bc.lmesh.Nverts\n\tparams.Polys = bc.lmesh.Polys\n\tparams.PolyAreas = bc.lmesh.Areas\n\tparams.PolyFlags = bc.lmesh.Flags\n\tparams.PolyCount = bc.lmesh.Npolys\n\tparams.Nvp = detour.DT_VERTS_PER_POLYGON\n\tparams.WalkableHeight = this.m_params.WalkableHeight\n\tparams.WalkableRadius = this.m_params.WalkableRadius\n\tparams.WalkableClimb = this.m_params.WalkableClimb\n\tparams.TileX = tile.Header.Tx\n\tparams.TileY = tile.Header.Ty\n\tparams.TileLayer = tile.Header.Tlayer\n\tparams.Cs = this.m_params.Cs\n\tparams.Ch = this.m_params.Ch\n\tparams.BuildBvTree = false\n\tdetour.DtVcopy(params.Bmin[:], tile.Header.Bmin[:])\n\tdetour.DtVcopy(params.Bmax[:], tile.Header.Bmax[:])\n\n\tif this.m_tmproc != nil {\n\t\tthis.m_tmproc.Process(\u0026params, bc.lmesh.Areas[:], bc.lmesh.Flags[:])\n\t}\n\n\tvar navData []byte\n\tvar navDataSize int\n\tif !detour.DtCreateNavMeshData(\u0026params, \u0026navData, \u0026navDataSize) {\n\t\treturn detour.DT_FAILURE\n\t}\n\n\t// Remove existing tile.\n\tnavmesh.RemoveTile(navmesh.GetTileRefAt(tile.Header.Tx, tile.Header.Ty, tile.Header.Tlayer), nil, nil)\n\n\t// Add new tile, or leave the location empty.\n\tif navData != nil {\n\t\t// Let the navmesh own the data.\n\t\tstatus = navmesh.AddTile(navData, navDataSize, detour.DT_TILE_FREE_DATA, 0, nil)\n\t\tif detour.DtStatusFailed(status) {\n\t\t\treturn status\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "BuildNavMeshTilesAt": {
                        "Name": "BuildNavMeshTilesAt",
                        "Code": "func (this *DtTileCache) BuildNavMeshTilesAt(tx, ty int32, navmesh *detour.DtNavMesh) detour.DtStatus {\n\tconst MAX_TILES = int32(32)\n\tvar tiles [MAX_TILES]DtCompressedTileRef\n\tntiles := this.GetTilesAt(tx, ty, tiles[:], MAX_TILES)\n\n\tfor i := int32(0); i \u003c ntiles; i++ {\n\t\tstatus := this.BuildNavMeshTile(tiles[i], navmesh)\n\t\tif detour.DtStatusFailed(status) {\n\t\t\treturn status\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "CalcTightTileBounds": {
                        "Name": "CalcTightTileBounds",
                        "Code": "func (this *DtTileCache) CalcTightTileBounds(header *DtTileCacheLayerHeader, bmin, bmax []float32) {\n\tcs := this.m_params.Cs\n\tbmin[0] = header.Bmin[0] + float32(header.Minx)*cs\n\tbmin[1] = header.Bmin[1]\n\tbmin[2] = header.Bmin[2] + float32(header.Miny)*cs\n\tbmax[0] = header.Bmin[0] + float32(header.Maxx+1)*cs\n\tbmax[1] = header.Bmax[1]\n\tbmax[2] = header.Bmin[2] + float32(header.Maxy+1)*cs\n}\n"
                    },
                    "DecodeObstacleIdObstacle": {
                        "Name": "DecodeObstacleIdObstacle",
                        "Code": "func (this *DtTileCache) DecodeObstacleIdObstacle(ref DtObstacleRef) uint32 {\n\ttileMask := (DtObstacleRef(1) \u003c\u003c 16) - 1\n\treturn uint32(ref \u0026 tileMask)\n}\n"
                    },
                    "DecodeObstacleIdSalt": {
                        "Name": "DecodeObstacleIdSalt",
                        "Code": "func (this *DtTileCache) DecodeObstacleIdSalt(ref DtObstacleRef) uint32 {\n\tsaltMask := (DtObstacleRef(1) \u003c\u003c 16) - 1\n\treturn uint32((ref \u003e\u003e 16) \u0026 saltMask)\n}\n"
                    },
                    "DecodeTileIdSalt": {
                        "Name": "DecodeTileIdSalt",
                        "Code": "func (this *DtTileCache) DecodeTileIdSalt(ref DtCompressedTileRef) uint32 {\n\tsaltMask := (DtCompressedTileRef(1) \u003c\u003c this.m_saltBits) - 1\n\treturn uint32((ref \u003e\u003e this.m_tileBits) \u0026 saltMask)\n}\n"
                    },
                    "DecodeTileIdTile": {
                        "Name": "DecodeTileIdTile",
                        "Code": "func (this *DtTileCache) DecodeTileIdTile(ref DtCompressedTileRef) uint32 {\n\ttileMask := (DtCompressedTileRef(1) \u003c\u003c this.m_tileBits) - 1\n\treturn uint32(ref \u0026 tileMask)\n}\n"
                    },
                    "EncodeObstacleId": {
                        "Name": "EncodeObstacleId",
                        "Code": "func (this *DtTileCache) EncodeObstacleId(salt, it uint32) DtObstacleRef {\n\treturn (DtObstacleRef(salt) \u003c\u003c 16) | DtObstacleRef(it)\n}\n"
                    },
                    "EncodeTileId": {
                        "Name": "EncodeTileId",
                        "Code": "func (this *DtTileCache) EncodeTileId(salt, it uint32) DtCompressedTileRef {\n\treturn (DtCompressedTileRef(salt) \u003c\u003c this.m_tileBits) | DtCompressedTileRef(it)\n}\n"
                    },
                    "GetCompressor": {
                        "Name": "GetCompressor",
                        "Code": "func (this *DtTileCache) GetCompressor() DtTileCacheCompressor   { return this.m_tcomp }\n"
                    },
                    "GetObstacle": {
                        "Name": "GetObstacle",
                        "Code": "func (this *DtTileCache) GetObstacle(i int) *DtTileCacheObstacle { return \u0026this.m_obstacles[i] }\n"
                    },
                    "GetObstacleBounds": {
                        "Name": "GetObstacleBounds",
                        "Code": "func (this *DtTileCache) GetObstacleBounds(ob *DtTileCacheObstacle, bmin, bmax []float32) {\n\tif ob.Type == DT_OBSTACLE_CYLINDER {\n\t\tcl := \u0026ob.Cylinder\n\n\t\tbmin[0] = cl.Pos[0] - cl.Radius\n\t\tbmin[1] = cl.Pos[1]\n\t\tbmin[2] = cl.Pos[2] - cl.Radius\n\t\tbmax[0] = cl.Pos[0] + cl.Radius\n\t\tbmax[1] = cl.Pos[1] + cl.Height\n\t\tbmax[2] = cl.Pos[2] + cl.Radius\n\t} else if ob.Type == DT_OBSTACLE_BOX {\n\t\tdetour.DtVcopy(bmin, ob.Box.Bmin[:])\n\t\tdetour.DtVcopy(bmax, ob.Box.Bmax[:])\n\t} else if ob.Type == DT_OBSTACLE_ORIENTED_BOX {\n\t\torientedBox := \u0026ob.OrientedBox\n\n\t\tmaxr := 1.41 * detour.DtMaxFloat32(orientedBox.HalfExtents[0], orientedBox.HalfExtents[2])\n\t\tbmin[0] = orientedBox.Center[0] - maxr\n\t\tbmax[0] = orientedBox.Center[0] + maxr\n\t\tbmin[1] = orientedBox.Center[1] - orientedBox.HalfExtents[1]\n\t\tbmax[1] = orientedBox.Center[1] + orientedBox.HalfExtents[1]\n\t\tbmin[2] = orientedBox.Center[2] - maxr\n\t\tbmax[2] = orientedBox.Center[2] + maxr\n\t}\n}\n"
                    },
                    "GetObstacleByRef": {
                        "Name": "GetObstacleByRef",
                        "Code": "func (this *DtTileCache) GetObstacleByRef(ref DtObstacleRef) *DtTileCacheObstacle {\n\tif ref == 0 {\n\t\treturn nil\n\t}\n\tidx := this.DecodeObstacleIdObstacle(ref)\n\tif int32(idx) \u003e= this.m_params.MaxObstacles {\n\t\treturn nil\n\t}\n\tob := \u0026this.m_obstacles[idx]\n\tsalt := this.DecodeObstacleIdSalt(ref)\n\tif uint32(ob.Salt) != salt {\n\t\treturn nil\n\t}\n\treturn ob\n}\n"
                    },
                    "GetObstacleCount": {
                        "Name": "GetObstacleCount",
                        "Code": "func (this *DtTileCache) GetObstacleCount() int                  { return int(this.m_params.MaxObstacles) }\n"
                    },
                    "GetObstacleRef": {
                        "Name": "GetObstacleRef",
                        "Code": "func (this *DtTileCache) GetObstacleRef(ob *DtTileCacheObstacle) DtObstacleRef {\n\tif ob == nil {\n\t\treturn 0\n\t}\n\tidx := detour.SliceSizeFromPointer(unsafe.Pointer(ob), unsafe.Pointer(\u0026this.m_obstacles[0]), dtTileCacheObstacleSize)\n\treturn this.EncodeObstacleId(uint32(ob.Salt), idx)\n}\n"
                    },
                    "GetParams": {
                        "Name": "GetParams",
                        "Code": "func (this *DtTileCache) GetParams() *DtTileCacheParams          { return \u0026this.m_params }\n"
                    },
                    "GetTile": {
                        "Name": "GetTile",
                        "Code": "func (this *DtTileCache) GetTile(i int) *DtCompressedTile        { return \u0026this.m_tiles[i] }\n"
                    },
                    "GetTileAt": {
                        "Name": "GetTileAt",
                        "Code": "func (this *DtTileCache) GetTileAt(tx, ty, tlayer int32) *DtCompressedTile {\n\t// Find tile based on hash.\n\th := computeTileHash(tx, ty, this.m_tileLutMask)\n\ttile := this.m_posLookup[h]\n\tfor tile != nil {\n\t\tif tile.Header != nil \u0026\u0026\n\t\t\ttile.Header.Tx == tx \u0026\u0026\n\t\t\ttile.Header.Ty == ty \u0026\u0026\n\t\t\ttile.Header.Tlayer == tlayer {\n\t\t\treturn tile\n\t\t}\n\t\ttile = tile.Next\n\t}\n\treturn nil\n}\n"
                    },
                    "GetTileByRef": {
                        "Name": "GetTileByRef",
                        "Code": "func (this *DtTileCache) GetTileByRef(ref DtCompressedTileRef) *DtCompressedTile {\n\tif ref == 0 {\n\t\treturn nil\n\t}\n\ttileIndex := this.DecodeTileIdTile(ref)\n\ttileSalt := this.DecodeTileIdSalt(ref)\n\tif int32(tileIndex) \u003e= this.m_params.MaxTiles {\n\t\treturn nil\n\t}\n\ttile := \u0026this.m_tiles[tileIndex]\n\tif tile.Salt != tileSalt {\n\t\treturn nil\n\t}\n\treturn tile\n}\n"
                    },
                    "GetTileCount": {
                        "Name": "GetTileCount",
                        "Code": "func (this *DtTileCache) GetTileCount() int                      { return int(this.m_params.MaxTiles) }\n"
                    },
                    "GetTileRef": {
                        "Name": "GetTileRef",
                        "Code": "func (this *DtTileCache) GetTileRef(tile *DtCompressedTile) DtCompressedTileRef {\n\tif tile == nil {\n\t\treturn 0\n\t}\n\n\tit := detour.SliceSizeFromPointer(unsafe.Pointer(tile), unsafe.Pointer(\u0026this.m_tiles[0]), dtCompressedTileSize)\n\treturn DtCompressedTileRef(this.EncodeTileId(tile.Salt, it))\n}\n"
                    },
                    "GetTilesAt": {
                        "Name": "GetTilesAt",
                        "Code": "func (this *DtTileCache) GetTilesAt(tx, ty int32, tiles []DtCompressedTileRef, maxTiles int32) int32 {\n\tvar n int32\n\t// Find tile based on hash.\n\th := computeTileHash(tx, ty, this.m_tileLutMask)\n\ttile := this.m_posLookup[h]\n\tfor tile != nil {\n\t\tif tile.Header != nil \u0026\u0026\n\t\t\ttile.Header.Tx == tx \u0026\u0026\n\t\t\ttile.Header.Ty == ty {\n\t\t\tif n \u003c maxTiles {\n\t\t\t\ttiles[n] = this.GetTileRef(tile)\n\t\t\t\tn++\n\t\t\t}\n\t\t}\n\t\ttile = tile.Next\n\t}\n\n\treturn n\n}\n"
                    },
                    "Init": {
                        "Name": "Init",
                        "Code": "func (this *DtTileCache) Init(params *DtTileCacheParams,\n\ttcomp DtTileCacheCompressor,\n\ttmproc DtTileCacheMeshProcess) detour.DtStatus {\n\tthis.m_tcomp = tcomp\n\tthis.m_tmproc = tmproc\n\tthis.m_nreqs = 0\n\tthis.m_params = *params\n\n\t// Alloc space for obstacles.\n\tthis.m_obstacles = make([]DtTileCacheObstacle, this.m_params.MaxObstacles)\n\tif this.m_obstacles == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\tthis.m_nextFreeObstacle = nil\n\tfor i := int(this.m_params.MaxObstacles - 1); i \u003e= 0; i-- {\n\t\tthis.m_obstacles[i].Salt = 1\n\t\tthis.m_obstacles[i].Next = this.m_nextFreeObstacle\n\t\tthis.m_nextFreeObstacle = \u0026this.m_obstacles[i]\n\t}\n\n\t// Init tiles\n\tthis.m_tileLutSize = int32(detour.DtNextPow2(uint32(this.m_params.MaxTiles / 4)))\n\tif this.m_tileLutSize == 0 {\n\t\tthis.m_tileLutSize = 1\n\t}\n\tthis.m_tileLutMask = this.m_tileLutSize - 1\n\n\tthis.m_tiles = make([]DtCompressedTile, this.m_params.MaxTiles)\n\tif this.m_tiles == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\tthis.m_posLookup = make([]*DtCompressedTile, this.m_tileLutSize)\n\tif this.m_posLookup == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\tthis.m_nextFreeTile = nil\n\tfor i := int(this.m_params.MaxTiles - 1); i \u003e= 0; i-- {\n\t\tthis.m_tiles[i].Salt = 1\n\t\tthis.m_tiles[i].Next = this.m_nextFreeTile\n\t\tthis.m_nextFreeTile = \u0026this.m_tiles[i]\n\t}\n\n\t// Init ID generator values.\n\tthis.m_tileBits = detour.DtIlog2(detour.DtNextPow2(uint32(this.m_params.MaxTiles)))\n\t// Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow.\n\tthis.m_saltBits = detour.DtMinUInt32(uint32(31), 32-this.m_tileBits)\n\tif this.m_saltBits \u003c 10 {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "QueryTiles": {
                        "Name": "QueryTiles",
                        "Code": "func (this *DtTileCache) QueryTiles(bmin, bmax []float32,\n\tresults []DtCompressedTileRef, resultCount *int32, maxResults int32) detour.DtStatus {\n\tconst MAX_TILES int32 = 32\n\tvar tiles [MAX_TILES]DtCompressedTileRef\n\n\tvar n int32\n\n\ttw := float32(this.m_params.Width) * this.m_params.Cs\n\tth := float32(this.m_params.Height) * this.m_params.Cs\n\ttx0 := int32(detour.DtMathFloorf((bmin[0] - this.m_params.Orig[0]) / tw))\n\ttx1 := int32(detour.DtMathFloorf((bmax[0] - this.m_params.Orig[0]) / tw))\n\tty0 := int32(detour.DtMathFloorf((bmin[2] - this.m_params.Orig[2]) / th))\n\tty1 := int32(detour.DtMathFloorf((bmax[2] - this.m_params.Orig[2]) / th))\n\n\tfor ty := ty0; ty \u003c= ty1; ty++ {\n\t\tfor tx := tx0; tx \u003c= tx1; tx++ {\n\t\t\tntiles := this.GetTilesAt(tx, ty, tiles[:], MAX_TILES)\n\n\t\t\tfor i := int32(0); i \u003c ntiles; i++ {\n\t\t\t\ttile := \u0026this.m_tiles[this.DecodeTileIdTile(tiles[i])]\n\t\t\t\tvar tbmin, tbmax [3]float32\n\t\t\t\tthis.CalcTightTileBounds(tile.Header, tbmin[:], tbmax[:])\n\n\t\t\t\tif detour.DtOverlapBounds(bmin, bmax, tbmin[:], tbmax[:]) {\n\t\t\t\t\tif n \u003c maxResults {\n\t\t\t\t\t\tresults[n] = tiles[i]\n\t\t\t\t\t\tn++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*resultCount = n\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "RemoveObstacle": {
                        "Name": "RemoveObstacle",
                        "Code": "func (this *DtTileCache) RemoveObstacle(ref DtObstacleRef) detour.DtStatus {\n\tif ref == 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif this.m_nreqs \u003e= MAX_REQUESTS {\n\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t}\n\n\treq := \u0026this.m_reqs[this.m_nreqs]\n\tthis.m_nreqs++\n\t*req = ObstacleRequest{}\n\treq.action = REQUEST_REMOVE\n\treq.ref = ref\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "RemoveTile": {
                        "Name": "RemoveTile",
                        "Code": "func (this *DtTileCache) RemoveTile(ref DtCompressedTileRef, data *[]byte, dataSize *int32) detour.DtStatus {\n\tif ref == 0 {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\ttileIndex := this.DecodeTileIdTile(ref)\n\ttileSalt := this.DecodeTileIdSalt(ref)\n\tif int32(tileIndex) \u003e= this.m_params.MaxTiles {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\ttile := \u0026this.m_tiles[tileIndex]\n\tif tile.Salt != tileSalt {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\n\t// Remove tile from hash lookup.\n\th := computeTileHash(tile.Header.Tx, tile.Header.Ty, this.m_tileLutMask)\n\tvar prev *DtCompressedTile\n\tcur := this.m_posLookup[h]\n\tfor cur != nil {\n\t\tif cur == tile {\n\t\t\tif prev != nil {\n\t\t\t\tprev.Next = cur.Next\n\t\t\t} else {\n\t\t\t\tthis.m_posLookup[h] = cur.Next\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tprev = cur\n\t\tcur = cur.Next\n\t}\n\n\t// Reset tile.\n\tif (tile.Flags \u0026 DT_COMPRESSEDTILE_FREE_DATA) != 0 {\n\t\t// Owns data\n\t\ttile.Data = nil\n\t\ttile.DataSize = 0\n\t\tif data != nil {\n\t\t\t*data = nil\n\t\t}\n\t\tif dataSize != nil {\n\t\t\t*dataSize = 0\n\t\t}\n\t} else {\n\t\tif data != nil {\n\t\t\t*data = tile.Data\n\t\t}\n\t\tif dataSize != nil {\n\t\t\t*dataSize = tile.DataSize\n\t\t}\n\t}\n\n\ttile.Header = nil\n\ttile.Data = nil\n\ttile.DataSize = 0\n\ttile.Compressed = nil\n\ttile.CompressedSize = 0\n\ttile.Flags = 0\n\n\t// Update salt, salt should never be zero.\n\ttile.Salt = (tile.Salt + 1) \u0026 ((1 \u003c\u003c this.m_saltBits) - 1)\n\tif tile.Salt == 0 {\n\t\ttile.Salt++\n\t}\n\n\t// Add to free list.\n\ttile.Next = this.m_nextFreeTile\n\tthis.m_nextFreeTile = tile\n\n\treturn detour.DT_SUCCESS\n}\n"
                    },
                    "Update": {
                        "Name": "Update",
                        "Code": "func (this *DtTileCache) Update(dt float32, navmesh *detour.DtNavMesh,\n\tupToDate *bool) detour.DtStatus {\n\tif this.m_nupdate == 0 {\n\t\t// Process requests.\n\t\tfor i := int32(0); i \u003c this.m_nreqs; i++ {\n\t\t\treq := \u0026this.m_reqs[i]\n\n\t\t\tidx := this.DecodeObstacleIdObstacle(req.ref)\n\t\t\tif int32(idx) \u003e= this.m_params.MaxObstacles {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tob := \u0026this.m_obstacles[idx]\n\t\t\tsalt := this.DecodeObstacleIdSalt(req.ref)\n\t\t\tif uint32(ob.Salt) != salt {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif req.action == REQUEST_ADD {\n\t\t\t\t// Find touched tiles.\n\t\t\t\tvar bmin, bmax [3]float32\n\t\t\t\tthis.GetObstacleBounds(ob, bmin[:], bmax[:])\n\n\t\t\t\tvar ntouched int32\n\t\t\t\tthis.QueryTiles(bmin[:], bmax[:], ob.Touched[:], \u0026ntouched, DT_MAX_TOUCHED_TILES)\n\t\t\t\tob.Ntouched = uint8(ntouched)\n\t\t\t\t// Add tiles to update list.\n\t\t\t\tob.Npending = 0\n\t\t\t\tfor j := int32(0); j \u003c int32(ob.Ntouched); j++ {\n\t\t\t\t\tif this.m_nupdate \u003c MAX_UPDATE {\n\t\t\t\t\t\tif !contains(this.m_update[:], this.m_nupdate, ob.Touched[j]) {\n\t\t\t\t\t\t\tthis.m_update[this.m_nupdate] = ob.Touched[j]\n\t\t\t\t\t\t\tthis.m_nupdate++\n\t\t\t\t\t\t}\n\t\t\t\t\t\tob.Pending[ob.Npending] = ob.Touched[j]\n\t\t\t\t\t\tob.Npending++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if req.action == REQUEST_REMOVE {\n\t\t\t\t// Prepare to remove obstacle.\n\t\t\t\tob.State = DT_OBSTACLE_REMOVING\n\t\t\t\t// Add tiles to update list.\n\t\t\t\tob.Npending = 0\n\t\t\t\tfor j := int32(0); j \u003c int32(ob.Ntouched); j++ {\n\t\t\t\t\tif this.m_nupdate \u003c MAX_UPDATE {\n\t\t\t\t\t\tif !contains(this.m_update[:], this.m_nupdate, ob.Touched[j]) {\n\t\t\t\t\t\t\tthis.m_update[this.m_nupdate] = ob.Touched[j]\n\t\t\t\t\t\t\tthis.m_nupdate++\n\t\t\t\t\t\t}\n\t\t\t\t\t\tob.Pending[ob.Npending] = ob.Touched[j]\n\t\t\t\t\t\tob.Npending++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.m_nreqs = 0\n\t}\n\n\tstatus := detour.DT_SUCCESS\n\t// Process updates\n\tif this.m_nupdate \u003e 0 {\n\t\t// Build mesh\n\t\tref := this.m_update[0]\n\t\tstatus = this.BuildNavMeshTile(ref, navmesh)\n\t\tthis.m_nupdate--\n\t\tif this.m_nupdate \u003e 0 {\n\t\t\tfor i := int32(0); i \u003c this.m_nupdate; i++ {\n\t\t\t\tthis.m_update[i] = this.m_update[i+1]\n\t\t\t}\n\t\t}\n\n\t\t// Update obstacle states.\n\t\tfor i := int32(0); i \u003c this.m_params.MaxObstacles; i++ {\n\t\t\tob := \u0026this.m_obstacles[i]\n\t\t\tif ob.State == DT_OBSTACLE_PROCESSING || ob.State == DT_OBSTACLE_REMOVING {\n\t\t\t\t// Remove handled tile from pending list.\n\t\t\t\tfor j := int32(0); j \u003c int32(ob.Npending); j++ {\n\t\t\t\t\tif ob.Pending[j] == ref {\n\t\t\t\t\t\tob.Pending[j] = ob.Pending[int32(ob.Npending-1)]\n\t\t\t\t\t\tob.Npending--\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If all pending tiles processed, change state.\n\t\t\t\tif ob.Npending == 0 {\n\t\t\t\t\tif ob.State == DT_OBSTACLE_PROCESSING {\n\t\t\t\t\t\tob.State = DT_OBSTACLE_PROCESSED\n\t\t\t\t\t} else if ob.State == DT_OBSTACLE_REMOVING {\n\t\t\t\t\t\tob.State = DT_OBSTACLE_EMPTY\n\t\t\t\t\t\t// Update salt, salt should never be zero.\n\t\t\t\t\t\tob.Salt = (ob.Salt + 1) \u0026 ((1 \u003c\u003c 16) - 1)\n\t\t\t\t\t\tif ob.Salt == 0 {\n\t\t\t\t\t\t\tob.Salt++\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Return obstacle to free list.\n\t\t\t\t\t\tob.Next = this.m_nextFreeObstacle\n\t\t\t\t\t\tthis.m_nextFreeObstacle = ob\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif upToDate != nil {\n\t\t*upToDate = ((this.m_nupdate == 0) \u0026\u0026 (this.m_nreqs == 0))\n\t}\n\n\treturn status\n}\n"
                    },
                    "construct": {
                        "Name": "construct",
                        "Code": "func (this *DtTileCache) construct() {\n\n}\n"
                    },
                    "destructor": {
                        "Name": "destructor",
                        "Code": "func (this *DtTileCache) destructor() {\n\tfor i := 0; i \u003c int(this.m_params.MaxTiles); i++ {\n\t\tif (this.m_tiles[i].Flags \u0026 DT_COMPRESSEDTILE_FREE_DATA) != 0 {\n\t\t\tthis.m_tiles[i].Data = nil\n\t\t}\n\t}\n\tthis.m_obstacles = nil\n\tthis.m_posLookup = nil\n\tthis.m_tiles = nil\n\tthis.m_nreqs = 0\n\tthis.m_nupdate = 0\n}\n"
                    }
                }
            },
            "DtTileCacheCompressor": {
                "Name": "DtTileCacheCompressor",
                "Code": "type DtTileCacheCompressor interface {\n\tMaxCompressedSize(bufferSize int32) int32\n\tCompress(buffer []byte, bufferSize int32, compressed []byte, maxCompressedSize int32, compressedSize *int32) detour.DtStatus\n\tDecompress(compressed []byte, compressedSize int32, buffer []byte, maxBufferSize int32, bufferSize *int32) detour.DtStatus\n}\n",
                "Methods": {}
            },
            "DtTileCacheContour": {
                "Name": "DtTileCacheContour",
                "Code": "type DtTileCacheContour struct {\n\tNverts int32\n\tVerts  []uint8\n\tReg    uint8\n\tArea   uint8\n}\n",
                "Methods": {}
            },
            "DtTileCacheContourSet": {
                "Name": "DtTileCacheContourSet",
                "Code": "type DtTileCacheContourSet struct {\n\tNconts int32\n\tConts  []DtTileCacheContour\n}\n",
                "Methods": {}
            },
            "DtTileCacheLayer": {
                "Name": "DtTileCacheLayer",
                "Code": "type DtTileCacheLayer struct {\n\tHeader   *DtTileCacheLayerHeader\n\tRegCount uint8 ///\u003c Region count.\n\tHeights  []uint8\n\tAreas    []uint8\n\tCons     []uint8\n\tRegs     []uint8\n}\n",
                "Methods": {}
            },
            "DtTileCacheLayerHeader": {
                "Name": "DtTileCacheLayerHeader",
                "Code": "type DtTileCacheLayerHeader struct {\n\tMagic   int32 ///\u003c Data magic\n\tVersion int32 ///\u003c Data version\n\tTx      int32\n\tTy      int32\n\tTlayer  int32\n\tBmin    [3]float32\n\tBmax    [3]float32\n\tHmin    uint16 ///\u003c Height min/max range\n\tHmax    uint16 ///\u003c Height min/max range\n\tWidth   uint8  ///\u003c Dimension of the layer.\n\tHeight  uint8  ///\u003c Dimension of the layer.\n\tMinx    uint8  ///\u003c Usable sub-region.\n\tMaxx    uint8  ///\u003c Usable sub-region.\n\tMiny    uint8  ///\u003c Usable sub-region.\n\tMaxy    uint8  ///\u003c Usable sub-region.\n}\n",
                "Methods": {}
            },
            "DtTileCacheMeshProcess": {
                "Name": "DtTileCacheMeshProcess",
                "Code": "type DtTileCacheMeshProcess interface {\n\tProcess(params *detour.DtNavMeshCreateParams, polyAreas []uint8, polyFlags []uint16)\n}\n",
                "Methods": {}
            },
            "DtTileCacheObstacle": {
                "Name": "DtTileCacheObstacle",
                "Code": "type DtTileCacheObstacle struct {\n\tCylinder    DtObstacleCylinder\n\tBox         DtObstacleBox\n\tOrientedBox DtObstacleOrientedBox\n\n\tTouched  [DT_MAX_TOUCHED_TILES]DtCompressedTileRef\n\tPending  [DT_MAX_TOUCHED_TILES]DtCompressedTileRef\n\tSalt     uint16\n\tType     ObstacleType\n\tState    ObstacleState\n\tNtouched uint8\n\tNpending uint8\n\tNext     *DtTileCacheObstacle\n}\n",
                "Methods": {}
            },
            "DtTileCacheParams": {
                "Name": "DtTileCacheParams",
                "Code": "type DtTileCacheParams struct {\n\tOrig                   [3]float32\n\tCs                     float32\n\tCh                     float32\n\tWidth                  int32\n\tHeight                 int32\n\tWalkableHeight         float32\n\tWalkableRadius         float32\n\tWalkableClimb          float32\n\tMaxSimplificationError float32\n\tMaxTiles               int32\n\tMaxObstacles           int32\n}\n",
                "Methods": {}
            },
            "DtTileCachePolyMesh": {
                "Name": "DtTileCachePolyMesh",
                "Code": "type DtTileCachePolyMesh struct {\n\tNvp    int32\n\tNverts int32    ///\u003c Number of vertices.\n\tNpolys int32    ///\u003c Number of polygons.\n\tVerts  []uint16 ///\u003c Vertices of the mesh, 3 elements per vertex.\n\tPolys  []uint16 ///\u003c Polygons of the mesh, nvp*2 elements per polygon.\n\tFlags  []uint16 ///\u003c Per polygon flags.\n\tAreas  []uint8  ///\u003c Area ID of polygons.\n}\n",
                "Methods": {}
            },
            "NavMeshTileBuildContext": {
                "Name": "NavMeshTileBuildContext",
                "Code": "type NavMeshTileBuildContext struct {\n\tlayer *DtTileCacheLayer\n\tlcset *DtTileCacheContourSet\n\tlmesh *DtTileCachePolyMesh\n}\n",
                "Methods": {}
            },
            "ObstacleRequest": {
                "Name": "ObstacleRequest",
                "Code": "type ObstacleRequest struct {\n\taction int32\n\tref    DtObstacleRef\n}\n",
                "Methods": {}
            },
            "ObstacleState": {
                "Name": "ObstacleState",
                "Code": "type ObstacleState uint8\n",
                "Methods": {}
            },
            "ObstacleType": {
                "Name": "ObstacleType",
                "Code": "type ObstacleType uint8\n",
                "Methods": {}
            },
            "dtLayerMonotoneRegion": {
                "Name": "dtLayerMonotoneRegion",
                "Code": "type dtLayerMonotoneRegion struct {\n\tArea   int32\n\tNeis   [DT_LAYER_MAX_NEIS]uint8\n\tNneis  uint8\n\tRegId  uint8\n\tAreaId uint8\n}\n",
                "Methods": {}
            },
            "dtLayerSweepSpan": {
                "Name": "dtLayerSweepSpan",
                "Code": "type dtLayerSweepSpan struct {\n\tns  uint16 // number samples\n\tid  uint8  // region id\n\tnei uint8  // neighbour id\n}\n",
                "Methods": {}
            },
            "dtTempContour": {
                "Name": "dtTempContour",
                "Code": "type dtTempContour struct {\n\tVerts  []uint8\n\tNverts int32\n\tCverts int32\n\tPoly   []uint16\n\tNpoly  int32\n\tCpoly  int32\n}\n",
                "Methods": {
                    "init": {
                        "Name": "init",
                        "Code": "func (this *dtTempContour) init(vbuf []uint8, nvbuf int32, pbuf []uint16, npbuf int32) {\n\tthis.Verts = vbuf\n\tthis.Nverts = 0\n\tthis.Cverts = nvbuf\n\tthis.Poly = pbuf\n\tthis.Npoly = 0\n\tthis.Cpoly = npbuf\n\n}\n"
                    }
                }
            },
            "rcEdge": {
                "Name": "rcEdge",
                "Code": "type rcEdge struct {\n\tVert     [2]uint16\n\tPolyEdge [2]uint16\n\tPoly     [2]uint16\n}\n",
                "Methods": {}
            }
        },
        "Functions": {
            "DtAllocTileCache": {
                "Name": "DtAllocTileCache",
                "Code": "func DtAllocTileCache() *DtTileCache {\n\tc := \u0026DtTileCache{}\n\tc.construct()\n\treturn c\n}\n"
            },
            "DtAllocTileCacheContourSet": {
                "Name": "DtAllocTileCacheContourSet",
                "Code": "func DtAllocTileCacheContourSet() *DtTileCacheContourSet {\n\tcset := \u0026DtTileCacheContourSet{}\n\treturn cset\n}\n"
            },
            "DtAllocTileCachePolyMesh": {
                "Name": "DtAllocTileCachePolyMesh",
                "Code": "func DtAllocTileCachePolyMesh() *DtTileCachePolyMesh {\n\tlmesh := \u0026DtTileCachePolyMesh{}\n\treturn lmesh\n}\n"
            },
            "DtBuildTileCacheContours": {
                "Name": "DtBuildTileCacheContours",
                "Code": "func DtBuildTileCacheContours(layer *DtTileCacheLayer, walkableClimb int32, maxError float32, lcset *DtTileCacheContourSet) detour.DtStatus {\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\n\tlcset.Nconts = int32(layer.RegCount)\n\tlcset.Conts = make([]DtTileCacheContour, lcset.Nconts)\n\tif lcset.Conts == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\t// Allocate temp buffer for contour tracing.\n\tmaxTempVerts := (w + h) * 2 * 2 // Twice around the layer.\n\n\ttempVerts := make([]uint8, maxTempVerts*4)\n\tif tempVerts == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\ttempPoly := make([]uint16, maxTempVerts)\n\tif tempPoly == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tvar temp dtTempContour\n\ttemp.init(tempVerts, maxTempVerts, tempPoly, maxTempVerts)\n\n\t// Find contours.\n\tfor y := int32(0); y \u003c h; y++ {\n\t\tfor x := int32(0); x \u003c w; x++ {\n\t\t\tidx := x + y*w\n\t\t\tri := layer.Regs[idx]\n\t\t\tif ri == 0xff {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcont := \u0026lcset.Conts[ri]\n\n\t\t\tif cont.Nverts \u003e 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcont.Reg = ri\n\t\t\tcont.Area = layer.Areas[idx]\n\n\t\t\tif !walkContour(layer, x, y, \u0026temp) {\n\t\t\t\t// Too complex contour.\n\t\t\t\t// Note: If you hit here ofte, try increasing 'maxTempVerts'.\n\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t}\n\n\t\t\tsimplifyContour(\u0026temp, maxError)\n\n\t\t\t// Store contour.\n\t\t\tcont.Nverts = temp.Nverts\n\t\t\tif cont.Nverts \u003e 0 {\n\t\t\t\tcont.Verts = make([]uint8, 4*temp.Nverts)\n\t\t\t\tif cont.Verts == nil {\n\t\t\t\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t\t\t\t}\n\n\t\t\t\tfor i, j := int32(0), temp.Nverts-1; i \u003c temp.Nverts; j, i = i, i+1 {\n\t\t\t\t\tdst := cont.Verts[j*4:]\n\t\t\t\t\tv := temp.Verts[j*4:]\n\t\t\t\t\tvn := temp.Verts[i*4:]\n\t\t\t\t\tnei := vn[3] // The neighbour reg is stored at segment vertex of a segment.\n\t\t\t\t\tshouldRemove := false\n\t\t\t\t\tlh := getCornerHeight(layer, int32(v[0]), int32(v[1]), int32(v[2]),\n\t\t\t\t\t\twalkableClimb, \u0026shouldRemove)\n\n\t\t\t\t\tdst[0] = v[0]\n\t\t\t\t\tdst[1] = lh\n\t\t\t\t\tdst[2] = v[2]\n\n\t\t\t\t\t// Store portal direction and remove status to the fourth component.\n\t\t\t\t\tdst[3] = 0x0f\n\t\t\t\t\tif nei != 0xff \u0026\u0026 nei \u003e= 0xf8 {\n\t\t\t\t\t\tdst[3] = nei - 0xf8\n\t\t\t\t\t}\n\t\t\t\t\tif shouldRemove {\n\t\t\t\t\t\tdst[3] |= 0x80\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtBuildTileCacheLayer": {
                "Name": "DtBuildTileCacheLayer",
                "Code": "func DtBuildTileCacheLayer(comp DtTileCacheCompressor,\n\theader *DtTileCacheLayerHeader,\n\theights, areas, cons []uint8,\n\toutData *[]uint8, outDataSize *int32) detour.DtStatus {\n\n\theaderSize := int32(detour.DtAlign4(int(DtTileCacheLayerHeaderSize)))\n\tgridSize := int32(header.Width) * int32(header.Height)\n\tmaxDataSize := headerSize + comp.MaxCompressedSize(gridSize*3)\n\tdata := make([]byte, maxDataSize)\n\tif data == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\t// Store header\n\t*(*DtTileCacheLayerHeader)(unsafe.Pointer(\u0026data[0])) = *header\n\n\t// Concatenate grid data for compression.\n\tbufferSize := gridSize * 3\n\tbuffer := make([]uint8, bufferSize)\n\tif buffer == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tcopy(buffer[:gridSize], heights)\n\tcopy(buffer[gridSize:gridSize*2], areas)\n\tcopy(buffer[gridSize*2:gridSize*3], cons)\n\n\t// Compress\n\tcompressed := data[headerSize:]\n\tmaxCompressedSize := maxDataSize - headerSize\n\tvar compressedSize int32\n\tstatus := comp.Compress(buffer, bufferSize, compressed, maxCompressedSize, \u0026compressedSize)\n\tif detour.DtStatusFailed(status) {\n\t\treturn status\n\t}\n\n\t*outData = data\n\t*outDataSize = headerSize + compressedSize\n\n\tbuffer = nil\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtBuildTileCachePolyMesh": {
                "Name": "DtBuildTileCachePolyMesh",
                "Code": "func DtBuildTileCachePolyMesh(lcset *DtTileCacheContourSet, mesh *DtTileCachePolyMesh) detour.DtStatus {\n\tvar maxVertices, maxTris, maxVertsPerCont int32\n\tfor i := int32(0); i \u003c lcset.Nconts; i++ {\n\t\t// Skip null contours.\n\t\tif lcset.Conts[i].Nverts \u003c 3 {\n\t\t\tcontinue\n\t\t}\n\t\tmaxVertices += lcset.Conts[i].Nverts\n\t\tmaxTris += lcset.Conts[i].Nverts - 2\n\t\tmaxVertsPerCont = detour.DtMaxInt32(maxVertsPerCont, lcset.Conts[i].Nverts)\n\t}\n\n\t// TODO: warn about too many vertices?\n\n\tmesh.Nvp = MAX_VERTS_PER_POLY\n\n\tvflags := make([]uint8, maxVertices)\n\tif vflags == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tmesh.Verts = make([]uint16, maxVertices*3)\n\tif mesh.Verts == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tmesh.Polys = make([]uint16, maxTris*MAX_VERTS_PER_POLY*2)\n\tif mesh.Polys == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tmesh.Areas = make([]uint8, maxTris)\n\tif mesh.Areas == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tmesh.Flags = make([]uint16, maxTris)\n\tif mesh.Flags == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tmesh.Nverts = 0\n\tmesh.Npolys = 0\n\n\tif len(mesh.Polys) != 0 {\n\t\tdetour.Memset(uintptr(unsafe.Pointer(\u0026(mesh.Polys[0]))), 0xff, ShortSize*int(maxTris*MAX_VERTS_PER_POLY*2))\n\t}\n\n\tvar firstVert [VERTEX_BUCKET_COUNT2]uint16\n\tdetour.Memset(uintptr(unsafe.Pointer(\u0026firstVert[0])), 0xff, ShortSize*int(VERTEX_BUCKET_COUNT2))\n\n\tnextVert := make([]uint16, maxVertices)\n\tif nextVert == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tindices := make([]uint16, maxVertsPerCont)\n\tif indices == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\ttris := make([]uint16, maxVertsPerCont*3)\n\tif tris == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tpolys := make([]uint16, maxVertsPerCont*MAX_VERTS_PER_POLY)\n\tif polys == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tfor i := int32(0); i \u003c lcset.Nconts; i++ {\n\t\tcont := \u0026lcset.Conts[i]\n\n\t\t// Skip null contours.\n\t\tif cont.Nverts \u003c 3 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Triangulate contour\n\t\tfor j := int32(0); j \u003c cont.Nverts; j++ {\n\t\t\tindices[j] = uint16(j)\n\t\t}\n\n\t\tntris := triangulate(cont.Nverts, cont.Verts, indices[:], tris[:])\n\t\tif ntris \u003c= 0 {\n\t\t\t// TODO: issue warning!\n\t\t\tntris = -ntris\n\t\t}\n\n\t\t// Add and merge vertices.\n\t\tfor j := int32(0); j \u003c cont.Nverts; j++ {\n\t\t\tv := cont.Verts[j*4:]\n\t\t\tindices[j] = addVertex(uint16(v[0]), uint16(v[1]), uint16(v[2]),\n\t\t\t\tmesh.Verts, firstVert[:], nextVert[:], \u0026mesh.Nverts)\n\t\t\tif v[3]\u00260x80 != 0 {\n\t\t\t\t// This vertex should be removed.\n\t\t\t\tvflags[indices[j]] = 1\n\t\t\t}\n\t\t}\n\n\t\t// Build initial polygons.\n\t\tvar npolys int32\n\t\tdetour.Memset(uintptr(unsafe.Pointer(\u0026(polys[0]))), 0xff, ShortSize*int(maxVertsPerCont*MAX_VERTS_PER_POLY))\n\t\tfor j := int32(0); j \u003c ntris; j++ {\n\t\t\tt := tris[j*3:]\n\t\t\tif t[0] != t[1] \u0026\u0026 t[0] != t[2] \u0026\u0026 t[1] != t[2] {\n\t\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+0] = indices[t[0]]\n\t\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+1] = indices[t[1]]\n\t\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+2] = indices[t[2]]\n\t\t\t\tnpolys++\n\t\t\t}\n\t\t}\n\t\tif npolys == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Merge polygons.\n\t\tmaxVertsPerPoly := MAX_VERTS_PER_POLY\n\t\tif maxVertsPerPoly \u003e 3 {\n\t\t\tfor {\n\t\t\t\t// Find best polygons to merge.\n\t\t\t\tvar bestMergeVal, bestPa, bestPb, bestEa, bestEb int32\n\n\t\t\t\tfor j := int32(0); j \u003c npolys-1; j++ {\n\t\t\t\t\tpj := polys[j*MAX_VERTS_PER_POLY:]\n\t\t\t\t\tfor k := j + 1; k \u003c npolys; k++ {\n\t\t\t\t\t\tpk := polys[k*MAX_VERTS_PER_POLY:]\n\t\t\t\t\t\tvar ea, eb int32\n\t\t\t\t\t\tv := getPolyMergeValue(pj, pk, mesh.Verts, \u0026ea, \u0026eb)\n\t\t\t\t\t\tif v \u003e bestMergeVal {\n\t\t\t\t\t\t\tbestMergeVal = v\n\t\t\t\t\t\t\tbestPa = j\n\t\t\t\t\t\t\tbestPb = k\n\t\t\t\t\t\t\tbestEa = ea\n\t\t\t\t\t\t\tbestEb = eb\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif bestMergeVal \u003e 0 {\n\t\t\t\t\t// Found best, merge.\n\t\t\t\t\tpa := polys[bestPa*MAX_VERTS_PER_POLY:]\n\t\t\t\t\tpb := polys[bestPb*MAX_VERTS_PER_POLY:]\n\t\t\t\t\tmergePolys(pa, pb, bestEa, bestEb)\n\t\t\t\t\tcopy(pb, polys[(npolys-1)*MAX_VERTS_PER_POLY:(npolys-1)*MAX_VERTS_PER_POLY+MAX_VERTS_PER_POLY])\n\t\t\t\t\tnpolys--\n\t\t\t\t} else {\n\t\t\t\t\t// Could not merge any polygons, stop.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Store polygons.\n\t\tfor j := int32(0); j \u003c npolys; j++ {\n\t\t\tp := mesh.Polys[mesh.Npolys*MAX_VERTS_PER_POLY*2:]\n\t\t\tq := polys[j*MAX_VERTS_PER_POLY:]\n\t\t\tfor k := int32(0); k \u003c MAX_VERTS_PER_POLY; k++ {\n\t\t\t\tp[k] = q[k]\n\t\t\t}\n\n\t\t\tmesh.Areas[mesh.Npolys] = cont.Area\n\t\t\tmesh.Npolys++\n\t\t\tif mesh.Npolys \u003e maxTris {\n\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove edge vertices.\n\tfor i := int32(0); i \u003c mesh.Nverts; i++ {\n\t\tif vflags[i] != 0 {\n\t\t\tif !canRemoveVertex(mesh, uint16(i)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tstatus := removeVertex(mesh, uint16(i), maxTris)\n\t\t\tif detour.DtStatusFailed(status) {\n\t\t\t\treturn status\n\t\t\t}\n\t\t\t// Remove vertex\n\t\t\t// Note: mesh.Nverts is already decremented inside removeVertex()!\n\t\t\tfor j := i; j \u003c mesh.Nverts; j++ {\n\t\t\t\tvflags[j] = vflags[j+1]\n\t\t\t}\n\t\t\ti--\n\t\t}\n\t}\n\n\t// Calculate adjacency.\n\tif !buildMeshAdjacency(mesh.Polys, mesh.Npolys, mesh.Verts, mesh.Nverts, lcset) {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtBuildTileCacheRegions": {
                "Name": "DtBuildTileCacheRegions",
                "Code": "func DtBuildTileCacheRegions(layer *DtTileCacheLayer, walkableClimb int32) detour.DtStatus {\n\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\n\tlayer.Regs = make([]uint8, w*h)\n\tfor i := int32(0); i \u003c w*h; i++ {\n\t\tlayer.Regs[i] = 0xff\n\t}\n\n\tnsweeps := w\n\tsweeps := make([]dtLayerSweepSpan, nsweeps)\n\n\t// Partition walkable area into monotone regions.\n\tvar prevCount [256]uint8\n\tvar regId uint8\n\n\tfor y := int32(0); y \u003c h; y++ {\n\t\tif regId \u003e 0 {\n\t\t\tdetour.Memset(uintptr(unsafe.Pointer(\u0026(prevCount[0]))), 0, int(regId))\n\t\t}\n\t\tvar sweepId uint8\n\n\t\tfor x := int32(0); x \u003c w; x++ {\n\t\t\tidx := x + y*w\n\t\t\tif layer.Areas[idx] == DT_TILECACHE_NULL_AREA {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsid := uint8(0xff)\n\n\t\t\t// -x\n\t\t\txidx := (x - 1) + y*w\n\t\t\tif x \u003e 0 \u0026\u0026 isConnected(layer, idx, xidx, walkableClimb) {\n\t\t\t\tif layer.Regs[xidx] != 0xff {\n\t\t\t\t\tsid = layer.Regs[xidx]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif sid == 0xff {\n\t\t\t\tsid = sweepId\n\t\t\t\tsweepId++\n\t\t\t\tsweeps[sid].nei = 0xff\n\t\t\t\tsweeps[sid].ns = 0\n\t\t\t}\n\n\t\t\t// -y\n\t\t\tyidx := x + (y-1)*w\n\t\t\tif y \u003e 0 \u0026\u0026 isConnected(layer, idx, yidx, walkableClimb) {\n\t\t\t\tnr := layer.Regs[yidx]\n\t\t\t\tif nr != 0xff {\n\t\t\t\t\t// Set neighbour when first valid neighbour is encoutered.\n\t\t\t\t\tif sweeps[sid].ns == 0 {\n\t\t\t\t\t\tsweeps[sid].nei = nr\n\t\t\t\t\t}\n\n\t\t\t\t\tif sweeps[sid].nei == nr {\n\t\t\t\t\t\t// Update existing neighbour\n\t\t\t\t\t\tsweeps[sid].ns++\n\t\t\t\t\t\tprevCount[nr]++\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This is hit if there is nore than one neighbour.\n\t\t\t\t\t\t// Invalidate the neighbour.\n\t\t\t\t\t\tsweeps[sid].nei = 0xff\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlayer.Regs[idx] = sid\n\t\t}\n\n\t\t// Create unique ID.\n\t\tfor i := int32(0); i \u003c int32(sweepId); i++ {\n\t\t\t// If the neighbour is set and there is only one continuous connection to it,\n\t\t\t// the sweep will be merged with the previous one, else new region is created.\n\t\t\tif sweeps[i].nei != 0xff \u0026\u0026 uint16(prevCount[sweeps[i].nei]) == sweeps[i].ns {\n\t\t\t\tsweeps[i].id = sweeps[i].nei\n\t\t\t} else {\n\t\t\t\tif regId == 255 {\n\t\t\t\t\t// Region ID's overflow.\n\t\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t\tsweeps[i].id = regId\n\t\t\t\tregId++\n\t\t\t}\n\t\t}\n\n\t\t// Remap local sweep ids to region ids.\n\t\tfor x := int32(0); x \u003c w; x++ {\n\t\t\tidx := x + y*w\n\t\t\tif layer.Regs[idx] != 0xff {\n\t\t\t\tlayer.Regs[idx] = sweeps[layer.Regs[idx]].id\n\t\t\t}\n\t\t}\n\t}\n\n\t// Allocate and init layer regions.\n\tnregs := int32(regId)\n\tregs := make([]dtLayerMonotoneRegion, nregs)\n\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\tregs[i].RegId = 0xff\n\t}\n\n\t// Find region neighbours.\n\tfor y := int32(0); y \u003c h; y++ {\n\t\tfor x := int32(0); x \u003c w; x++ {\n\t\t\tidx := x + y*w\n\t\t\tri := layer.Regs[idx]\n\t\t\tif ri == 0xff {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Update area.\n\t\t\tregs[ri].Area++\n\t\t\tregs[ri].AreaId = layer.Areas[idx]\n\n\t\t\t// Update neighbours\n\t\t\tymi := x + (y-1)*w\n\t\t\tif y \u003e 0 \u0026\u0026 isConnected(layer, idx, ymi, walkableClimb) {\n\t\t\t\trai := layer.Regs[ymi]\n\t\t\t\tif rai != 0xff \u0026\u0026 rai != ri {\n\t\t\t\t\taddUniqueLast(regs[ri].Neis[:], \u0026regs[ri].Nneis, rai)\n\t\t\t\t\taddUniqueLast(regs[rai].Neis[:], \u0026regs[rai].Nneis, ri)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\tregs[i].RegId = uint8(i)\n\t}\n\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\treg := \u0026regs[i]\n\n\t\tmerge := int32(-1)\n\t\tmergea := int32(0)\n\t\tfor j := int32(0); j \u003c int32(reg.Nneis); j++ {\n\t\t\tnei := reg.Neis[j]\n\t\t\tregn := \u0026regs[nei]\n\t\t\tif reg.RegId == regn.RegId {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif reg.AreaId != regn.AreaId {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif regn.Area \u003e mergea {\n\t\t\t\tif canMerge(reg.RegId, regn.RegId, regs, nregs) {\n\t\t\t\t\tmergea = regn.Area\n\t\t\t\t\tmerge = int32(nei)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif merge != -1 {\n\t\t\toldId := reg.RegId\n\t\t\tnewId := regs[merge].RegId\n\t\t\tfor j := int32(0); j \u003c nregs; j++ {\n\t\t\t\tif regs[j].RegId == oldId {\n\t\t\t\t\tregs[j].RegId = newId\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compact ids.\n\tvar remap [256]uint8\n\t// Find number of unique regions.\n\tregId = 0\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\tremap[regs[i].RegId] = 1\n\t}\n\tfor i := 0; i \u003c 256; i++ {\n\t\tif remap[i] \u003e 0 {\n\t\t\tremap[i] = regId\n\t\t\tregId++\n\t\t}\n\t}\n\t// Remap ids.\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\tregs[i].RegId = remap[regs[i].RegId]\n\t}\n\n\tlayer.RegCount = regId\n\n\tfor i := int32(0); i \u003c w*h; i++ {\n\t\tif layer.Regs[i] != 0xff {\n\t\t\tlayer.Regs[i] = regs[layer.Regs[i]].RegId\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtDecompressTileCacheLayer": {
                "Name": "DtDecompressTileCacheLayer",
                "Code": "func DtDecompressTileCacheLayer(comp DtTileCacheCompressor,\n\tcompressed []uint8, compressedSize int32,\n\tlayerOut **DtTileCacheLayer) detour.DtStatus {\n\n\tdetour.DtAssert(comp != nil)\n\n\tif layerOut == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\tif compressed == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_INVALID_PARAM\n\t}\n\n\t*layerOut = nil\n\n\tcompressedHeader := (*DtTileCacheLayerHeader)(unsafe.Pointer(\u0026compressed[0]))\n\tif compressedHeader.Magic != DT_TILECACHE_MAGIC {\n\t\treturn detour.DT_FAILURE | detour.DT_WRONG_MAGIC\n\t}\n\tif compressedHeader.Version != DT_TILECACHE_VERSION {\n\t\treturn detour.DT_FAILURE | detour.DT_WRONG_VERSION\n\t}\n\n\tlayerSize := int32(detour.DtAlign4(int(DtTileCacheLayerSize)))\n\theaderSize := int32(detour.DtAlign4(int(DtTileCacheLayerHeaderSize)))\n\tgridSize := int32(compressedHeader.Width) * int32(compressedHeader.Height)\n\tbufferSize := layerSize + headerSize + gridSize*4\n\n\tbuffer := make([]byte, bufferSize)\n\tif buffer == nil {\n\t\treturn detour.DT_FAILURE | detour.DT_OUT_OF_MEMORY\n\t}\n\n\tlayer := (*DtTileCacheLayer)(unsafe.Pointer(\u0026buffer[0]))\n\theader := (*DtTileCacheLayerHeader)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026buffer[0])) + uintptr(layerSize)))\n\n\tvar grids []byte\n\tgridsSize := bufferSize - (layerSize + headerSize)\n\tsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(\u0026grids)))\n\tsliceHeader.Cap = int(gridsSize)\n\tsliceHeader.Len = int(gridsSize)\n\tsliceHeader.Data = uintptr(unsafe.Pointer(\u0026buffer[0])) + uintptr(layerSize+headerSize)\n\n\t// Copy header\n\t*header = *compressedHeader\n\t// Decompress grid.\n\tvar size int32\n\tstatus := comp.Decompress(compressed[headerSize:], compressedSize-headerSize, grids, gridsSize, \u0026size)\n\tdetour.DtIgnoreUnused(size)\n\n\tif detour.DtStatusFailed(status) {\n\t\tbuffer = nil\n\t\treturn status\n\t}\n\n\tlayer.Header = header\n\tlayer.Heights = grids\n\tlayer.Areas = grids[gridSize:]\n\tlayer.Cons = grids[gridSize*2:]\n\tlayer.Regs = grids[gridSize*3:]\n\n\t*layerOut = layer\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtFreeTileCache": {
                "Name": "DtFreeTileCache",
                "Code": "func DtFreeTileCache(tc *DtTileCache) {\n\tif tc != nil {\n\t\ttc.destructor()\n\t}\n}\n"
            },
            "DtFreeTileCacheContourSet": {
                "Name": "DtFreeTileCacheContourSet",
                "Code": "func DtFreeTileCacheContourSet(cset *DtTileCacheContourSet) {\n\tif cset == nil {\n\t\treturn\n\t}\n\tcset.Conts = nil\n\tcset.Nconts = 0\n}\n"
            },
            "DtFreeTileCacheLayer": {
                "Name": "DtFreeTileCacheLayer",
                "Code": "func DtFreeTileCacheLayer(layer *DtTileCacheLayer) {\n\n}\n"
            },
            "DtFreeTileCachePolyMesh": {
                "Name": "DtFreeTileCachePolyMesh",
                "Code": "func DtFreeTileCachePolyMesh(lmesh *DtTileCachePolyMesh) {\n\tif lmesh == nil {\n\t\treturn\n\t}\n\tlmesh.Verts = nil\n\tlmesh.Nverts = 0\n\tlmesh.Polys = nil\n\tlmesh.Npolys = 0\n\tlmesh.Flags = nil\n\tlmesh.Areas = nil\n}\n"
            },
            "DtMarkBoxArea1": {
                "Name": "DtMarkBoxArea1",
                "Code": "func DtMarkBoxArea1(layer *DtTileCacheLayer, orig []float32, cs, ch float32,\n\tbmin, bmax []float32, areaId uint8) detour.DtStatus {\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\tics := 1.0 / cs\n\tich := 1.0 / ch\n\n\tminx := int32(detour.DtMathFloorf((bmin[0] - orig[0]) * ics))\n\tminy := int32(detour.DtMathFloorf((bmin[1] - orig[1]) * ich))\n\tminz := int32(detour.DtMathFloorf((bmin[2] - orig[2]) * ics))\n\tmaxx := int32(detour.DtMathFloorf((bmax[0] - orig[0]) * ics))\n\tmaxy := int32(detour.DtMathFloorf((bmax[1] - orig[1]) * ich))\n\tmaxz := int32(detour.DtMathFloorf((bmax[2] - orig[2]) * ics))\n\n\tif maxx \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minx \u003e= w {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif maxz \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minz \u003e= h {\n\t\treturn detour.DT_SUCCESS\n\t}\n\n\tif minx \u003c 0 {\n\t\tminx = 0\n\t}\n\tif maxx \u003e= w {\n\t\tmaxx = w - 1\n\t}\n\tif minz \u003c 0 {\n\t\tminz = 0\n\t}\n\tif maxz \u003e= h {\n\t\tmaxz = h - 1\n\t}\n\n\tfor z := minz; z \u003c= maxz; z++ {\n\t\tfor x := minx; x \u003c= maxx; x++ {\n\t\t\ty := int32(layer.Heights[x+z*w])\n\t\t\tif y \u003c miny || y \u003e maxy {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlayer.Areas[x+z*w] = areaId\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtMarkBoxArea2": {
                "Name": "DtMarkBoxArea2",
                "Code": "func DtMarkBoxArea2(layer *DtTileCacheLayer, orig []float32, cs, ch float32,\n\tcenter, halfExtents, rotAux []float32, areaId uint8) detour.DtStatus {\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\tics := 1.0 / cs\n\tich := 1.0 / ch\n\n\tcx := (center[0] - orig[0]) * ics\n\tcz := (center[2] - orig[2]) * ics\n\n\tmaxr := 1.41 * detour.DtMaxFloat32(halfExtents[0], halfExtents[2])\n\tminx := int32(detour.DtMathFloorf(cx - maxr*ics))\n\tmaxx := int32(detour.DtMathFloorf(cx + maxr*ics))\n\tminz := int32(detour.DtMathFloorf(cz - maxr*ics))\n\tmaxz := int32(detour.DtMathFloorf(cz + maxr*ics))\n\tminy := int32(detour.DtMathFloorf((center[1] - halfExtents[1] - orig[1]) * ich))\n\tmaxy := int32(detour.DtMathFloorf((center[1] + halfExtents[1] - orig[1]) * ich))\n\n\tif maxx \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minx \u003e= w {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif maxz \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minz \u003e= h {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minx \u003c 0 {\n\t\tminx = 0\n\t}\n\tif maxx \u003e= w {\n\t\tmaxx = w - 1\n\t}\n\tif minz \u003c 0 {\n\t\tminz = 0\n\t}\n\tif maxz \u003e= h {\n\t\tmaxz = h - 1\n\t}\n\n\txhalf := halfExtents[0]*ics + 0.5\n\tzhalf := halfExtents[2]*ics + 0.5\n\n\tfor z := minz; z \u003c= maxz; z++ {\n\t\tfor x := minx; x \u003c= maxx; x++ {\n\t\t\tx2 := 2.0 * (float32(x) - cx)\n\t\t\tz2 := 2.0 * (float32(z) - cz)\n\t\t\txrot := rotAux[1]*x2 + rotAux[0]*z2\n\t\t\tif xrot \u003e xhalf || xrot \u003c -xhalf {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tzrot := rotAux[1]*z2 - rotAux[0]*x2\n\t\t\tif zrot \u003e zhalf || zrot \u003c -zhalf {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ty := int32(layer.Heights[x+z*w])\n\t\t\tif y \u003c miny || y \u003e maxy {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlayer.Areas[x+z*w] = areaId\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtMarkCylinderArea": {
                "Name": "DtMarkCylinderArea",
                "Code": "func DtMarkCylinderArea(layer *DtTileCacheLayer, orig []float32, cs, ch float32,\n\tpos []float32, radius, height float32, areaId uint8) detour.DtStatus {\n\tvar bmin, bmax [3]float32\n\tbmin[0] = pos[0] - radius\n\tbmin[1] = pos[1]\n\tbmin[2] = pos[2] - radius\n\tbmax[0] = pos[0] + radius\n\tbmax[1] = pos[1] + height\n\tbmax[2] = pos[2] + radius\n\tr2 := detour.DtSqrFloat32(radius/cs + 0.5)\n\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\tics := 1.0 / cs\n\tich := 1.0 / ch\n\n\tpx := (pos[0] - orig[0]) * ics\n\tpz := (pos[2] - orig[2]) * ics\n\n\tminx := int32(detour.DtMathFloorf((bmin[0] - orig[0]) * ics))\n\tminy := int32(detour.DtMathFloorf((bmin[1] - orig[1]) * ich))\n\tminz := int32(detour.DtMathFloorf((bmin[2] - orig[2]) * ics))\n\tmaxx := int32(detour.DtMathFloorf((bmax[0] - orig[0]) * ics))\n\tmaxy := int32(detour.DtMathFloorf((bmax[1] - orig[1]) * ich))\n\tmaxz := int32(detour.DtMathFloorf((bmax[2] - orig[2]) * ics))\n\n\tif maxx \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minx \u003e= w {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif maxz \u003c 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\tif minz \u003e= h {\n\t\treturn detour.DT_SUCCESS\n\t}\n\n\tif minx \u003c 0 {\n\t\tminx = 0\n\t}\n\tif maxx \u003e= w {\n\t\tmaxx = w - 1\n\t}\n\tif minz \u003c 0 {\n\t\tminz = 0\n\t}\n\tif maxz \u003e= h {\n\t\tmaxz = h - 1\n\t}\n\n\tfor z := minz; z \u003c= maxz; z++ {\n\t\tfor x := minx; x \u003c= maxx; x++ {\n\t\t\tdx := float32(x) + 0.5 - px\n\t\t\tdz := float32(z) + 0.5 - pz\n\t\t\tif dx*dx+dz*dz \u003e r2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ty := int32(layer.Heights[x+z*w])\n\t\t\tif y \u003c miny || y \u003e maxy {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlayer.Areas[x+z*w] = areaId\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "DtTileCacheHeaderSwapEndian": {
                "Name": "DtTileCacheHeaderSwapEndian",
                "Code": "func DtTileCacheHeaderSwapEndian(data []uint8, dataSize int32) bool {\n\t// dtIgnoreUnused(dataSize)\n\theader := (*DtTileCacheLayerHeader)(unsafe.Pointer(\u0026data[0]))\n\n\tswappedMagic := DT_TILECACHE_MAGIC\n\tswappedVersion := DT_TILECACHE_VERSION\n\tdetour.DtSwapEndianInt32(\u0026swappedMagic)\n\tdetour.DtSwapEndianInt32(\u0026swappedVersion)\n\n\tif (header.Magic != DT_TILECACHE_MAGIC || header.Version != DT_TILECACHE_VERSION) \u0026\u0026\n\t\t(header.Magic != swappedMagic || header.Version != swappedVersion) {\n\t\treturn false\n\t}\n\n\tdetour.DtSwapEndianInt32(\u0026header.Magic)\n\tdetour.DtSwapEndianInt32(\u0026header.Version)\n\tdetour.DtSwapEndianInt32(\u0026header.Tx)\n\tdetour.DtSwapEndianInt32(\u0026header.Ty)\n\tdetour.DtSwapEndianInt32(\u0026header.Tlayer)\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmin[0])\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmin[1])\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmin[2])\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmax[0])\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmax[1])\n\tdetour.DtSwapEndianFloat32(\u0026header.Bmax[2])\n\tdetour.DtSwapEndianUInt16(\u0026header.Hmin)\n\tdetour.DtSwapEndianUInt16(\u0026header.Hmax)\n\n\t// width, height, minx, maxx, miny, maxy are unsigned char, no need to swap.\n\n\treturn true\n}\n"
            },
            "addUniqueLast": {
                "Name": "addUniqueLast",
                "Code": "func addUniqueLast(a []uint8, an *uint8, v uint8) {\n\tn := int32(*an)\n\tif n \u003e 0 \u0026\u0026 a[n-1] == v {\n\t\treturn\n\t}\n\ta[*an] = v\n\t(*an)++\n}\n"
            },
            "addVertex": {
                "Name": "addVertex",
                "Code": "func addVertex(x, y, z uint16, verts, firstVert, nextVert []uint16, nv *int32) uint16 {\n\tbucket := computeVertexHash2(int32(x), 0, int32(z))\n\ti := firstVert[bucket]\n\n\tfor i != DT_TILECACHE_NULL_IDX {\n\t\tv := verts[i*3:]\n\t\tif v[0] == x \u0026\u0026 v[2] == z \u0026\u0026 (detour.DtAbsInt32(int32(v[1])-int32(y)) \u003c= 2) {\n\t\t\treturn i\n\t\t}\n\t\ti = nextVert[i] // next\n\t}\n\n\t// Could not find, create new.\n\ti = uint16(*nv)\n\t(*nv)++\n\tv := verts[i*3:]\n\tv[0] = x\n\tv[1] = y\n\tv[2] = z\n\tnextVert[i] = firstVert[bucket]\n\tfirstVert[bucket] = i\n\n\treturn uint16(i)\n}\n"
            },
            "appendVertex": {
                "Name": "appendVertex",
                "Code": "func appendVertex(cont *dtTempContour, x, y, z, r int32) bool {\n\t// Try to merge with existing segments.\n\tif cont.Nverts \u003e 1 {\n\t\tpa := cont.Verts[(cont.Nverts-2)*4:]\n\t\tpb := cont.Verts[(cont.Nverts-1)*4:]\n\t\tif int32(pb[3]) == r {\n\t\t\tif pa[0] == pb[0] \u0026\u0026 int32(pb[0]) == x {\n\t\t\t\t// The verts are aligned aling x-axis, update z.\n\t\t\t\tpb[1] = uint8(y)\n\t\t\t\tpb[2] = uint8(z)\n\t\t\t\treturn true\n\t\t\t} else if pa[2] == pb[2] \u0026\u0026 int32(pb[2]) == z {\n\t\t\t\t// The verts are aligned aling z-axis, update x.\n\t\t\t\tpb[0] = uint8(x)\n\t\t\t\tpb[1] = uint8(y)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add new point.\n\tif cont.Nverts+1 \u003e cont.Cverts {\n\t\treturn false\n\t}\n\n\tv := cont.Verts[cont.Nverts*4:]\n\tv[0] = uint8(x)\n\tv[1] = uint8(y)\n\tv[2] = uint8(z)\n\tv[3] = uint8(r)\n\tcont.Nverts++\n\n\treturn true\n}\n"
            },
            "area2": {
                "Name": "area2",
                "Code": "func area2(a, b, c []uint8) int32 {\n\treturn (int32(b[0])-int32(a[0]))*(int32(c[2])-int32(a[2])) - (int32(c[0])-int32(a[0]))*(int32(b[2])-int32(a[2]))\n}\n"
            },
            "between": {
                "Name": "between",
                "Code": "func between(a, b, c []uint8) bool {\n\tif !collinear(a, b, c) {\n\t\treturn false\n\t}\n\t// If ab not vertical, check betweenness on x; else on y.\n\tif a[0] != b[0] {\n\t\treturn ((a[0] \u003c= c[0]) \u0026\u0026 (c[0] \u003c= b[0])) || ((a[0] \u003e= c[0]) \u0026\u0026 (c[0] \u003e= b[0]))\n\t}\n\treturn ((a[2] \u003c= c[2]) \u0026\u0026 (c[2] \u003c= b[2])) || ((a[2] \u003e= c[2]) \u0026\u0026 (c[2] \u003e= b[2]))\n\n}\n"
            },
            "buildMeshAdjacency": {
                "Name": "buildMeshAdjacency",
                "Code": "func buildMeshAdjacency(polys []uint16, npolys int32,\n\tverts []uint16, nverts int32,\n\tlcset *DtTileCacheContourSet) bool {\n\t// Based on code by Eric Lengyel from:\n\t// http://www.terathon.com/code/edges.php\n\n\tmaxEdgeCount := npolys * MAX_VERTS_PER_POLY\n\tfirstEdge := make([]uint16, nverts*maxEdgeCount)\n\tnextEdge := firstEdge[nverts:]\n\n\tvar edgeCount int32\n\n\tedges := make([]rcEdge, maxEdgeCount)\n\n\tfor i := int32(0); i \u003c nverts; i++ {\n\t\tfirstEdge[i] = DT_TILECACHE_NULL_IDX\n\t}\n\n\tfor i := int32(0); i \u003c npolys; i++ {\n\t\tt := polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tfor j := int32(0); j \u003c MAX_VERTS_PER_POLY; j++ {\n\t\t\tif t[j] == DT_TILECACHE_NULL_IDX {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tv0 := t[j]\n\t\t\tv1 := t[j+1]\n\t\t\tif j+1 \u003e= MAX_VERTS_PER_POLY || t[j+1] == DT_TILECACHE_NULL_IDX {\n\t\t\t\tv1 = t[0]\n\t\t\t}\n\t\t\tif v0 \u003c v1 {\n\t\t\t\tedge := \u0026edges[edgeCount]\n\t\t\t\tedge.Vert[0] = v0\n\t\t\t\tedge.Vert[1] = v1\n\t\t\t\tedge.Poly[0] = uint16(i)\n\t\t\t\tedge.PolyEdge[0] = uint16(j)\n\t\t\t\tedge.Poly[1] = uint16(i)\n\t\t\t\tedge.PolyEdge[1] = 0xff\n\t\t\t\t// Insert edge\n\t\t\t\tnextEdge[edgeCount] = firstEdge[v0]\n\t\t\t\tfirstEdge[v0] = uint16(edgeCount)\n\t\t\t\tedgeCount++\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := int32(0); i \u003c npolys; i++ {\n\t\tt := polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tfor j := int32(0); j \u003c MAX_VERTS_PER_POLY; j++ {\n\t\t\tif t[j] == DT_TILECACHE_NULL_IDX {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tv0 := t[j]\n\t\t\tv1 := t[j+1]\n\t\t\tif j+1 \u003e= MAX_VERTS_PER_POLY || t[j+1] == DT_TILECACHE_NULL_IDX {\n\t\t\t\tv1 = t[0]\n\t\t\t}\n\t\t\tif v0 \u003e v1 {\n\t\t\t\tfound := false\n\t\t\t\tfor e := firstEdge[v1]; e != DT_TILECACHE_NULL_IDX; e = nextEdge[e] {\n\t\t\t\t\tedge := \u0026edges[e]\n\t\t\t\t\tif edge.Vert[1] == v0 \u0026\u0026 edge.Poly[0] == edge.Poly[1] {\n\t\t\t\t\t\tedge.Poly[1] = uint16(i)\n\t\t\t\t\t\tedge.PolyEdge[1] = uint16(j)\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !found {\n\t\t\t\t\t// Matching edge not found, it is an open edge, add it.\n\t\t\t\t\tedge := \u0026edges[edgeCount]\n\t\t\t\t\tedge.Vert[0] = v1\n\t\t\t\t\tedge.Vert[1] = v0\n\t\t\t\t\tedge.Poly[0] = uint16(i)\n\t\t\t\t\tedge.PolyEdge[0] = uint16(j)\n\t\t\t\t\tedge.Poly[1] = uint16(i)\n\t\t\t\t\tedge.PolyEdge[1] = 0xff\n\t\t\t\t\t// Insert edge\n\t\t\t\t\tnextEdge[edgeCount] = firstEdge[v1]\n\t\t\t\t\tfirstEdge[v1] = uint16(edgeCount)\n\t\t\t\t\tedgeCount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Mark portal edges.\n\tfor i := int32(0); i \u003c lcset.Nconts; i++ {\n\t\tcont := \u0026lcset.Conts[i]\n\t\tif cont.Nverts \u003c 3 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor j, k := int32(0), cont.Nverts-1; j \u003c cont.Nverts; k, j = j, j+1 {\n\t\t\tva := cont.Verts[k*4:]\n\t\t\tvb := cont.Verts[j*4:]\n\t\t\tdir := va[3] \u0026 0xf\n\t\t\tif dir == 0xf {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif dir == 0 || dir == 2 {\n\t\t\t\t// Find matching vertical edge\n\t\t\t\tx := uint16(va[0])\n\t\t\t\tzmin := uint16(va[2])\n\t\t\t\tzmax := uint16(vb[2])\n\t\t\t\tif zmin \u003e zmax {\n\t\t\t\t\tzmin, zmax = zmax, zmin\n\t\t\t\t\t// detour.DtSwapUInt16(\u0026zmin, \u0026zmax)\n\t\t\t\t}\n\n\t\t\t\tfor m := int32(0); m \u003c edgeCount; m++ {\n\t\t\t\t\te := \u0026edges[m]\n\t\t\t\t\t// Skip connected edges.\n\t\t\t\t\tif e.Poly[0] != e.Poly[1] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\teva := verts[e.Vert[0]*3:]\n\t\t\t\t\tevb := verts[e.Vert[1]*3:]\n\t\t\t\t\tif eva[0] == x \u0026\u0026 evb[0] == x {\n\t\t\t\t\t\tezmin := eva[2]\n\t\t\t\t\t\tezmax := evb[2]\n\t\t\t\t\t\tif ezmin \u003e ezmax {\n\t\t\t\t\t\t\tezmin, ezmax = ezmax, ezmin\n\t\t\t\t\t\t\t// detour.DtSwapUInt16(\u0026ezmin, \u0026ezmax)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif overlapRangeExl(zmin, zmax, ezmin, ezmax) {\n\t\t\t\t\t\t\t// Reuse the other polyedge to store dir.\n\t\t\t\t\t\t\te.PolyEdge[1] = uint16(dir)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Find matching vertical edge\n\t\t\t\tz := uint16(va[2])\n\t\t\t\txmin := uint16(va[0])\n\t\t\t\txmax := uint16(vb[0])\n\t\t\t\tif xmin \u003e xmax {\n\t\t\t\t\txmin, xmax = xmax, xmin\n\t\t\t\t\t// detour.DtSwapUInt16(\u0026xmin, \u0026xmax)\n\t\t\t\t}\n\t\t\t\tfor m := int32(0); m \u003c edgeCount; m++ {\n\t\t\t\t\te := \u0026edges[m]\n\t\t\t\t\t// Skip connected edges.\n\t\t\t\t\tif e.Poly[0] != e.Poly[1] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\teva := verts[e.Vert[0]*3:]\n\t\t\t\t\tevb := verts[e.Vert[1]*3:]\n\t\t\t\t\tif eva[2] == z \u0026\u0026 evb[2] == z {\n\t\t\t\t\t\texmin := eva[0]\n\t\t\t\t\t\texmax := evb[0]\n\t\t\t\t\t\tif exmin \u003e exmax {\n\t\t\t\t\t\t\texmin, exmax = exmax, exmin\n\t\t\t\t\t\t\t// detour.DtSwapUInt16(\u0026exmin, \u0026exmax)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif overlapRangeExl(xmin, xmax, exmin, exmax) {\n\t\t\t\t\t\t\t// Reuse the other polyedge to store dir.\n\t\t\t\t\t\t\te.PolyEdge[1] = uint16(dir)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Store adjacency\n\tfor i := int32(0); i \u003c edgeCount; i++ {\n\t\te := \u0026edges[i]\n\t\tif e.Poly[0] != e.Poly[1] {\n\t\t\tp0 := polys[int32(e.Poly[0])*MAX_VERTS_PER_POLY*2:]\n\t\t\tp1 := polys[int32(e.Poly[1])*MAX_VERTS_PER_POLY*2:]\n\t\t\tp0[MAX_VERTS_PER_POLY+int32(e.PolyEdge[0])] = e.Poly[1]\n\t\t\tp1[MAX_VERTS_PER_POLY+int32(e.PolyEdge[1])] = e.Poly[0]\n\t\t} else if e.PolyEdge[1] != 0xff {\n\t\t\tp0 := polys[int32(e.Poly[0])*MAX_VERTS_PER_POLY*2:]\n\t\t\tp0[MAX_VERTS_PER_POLY+int32(e.PolyEdge[0])] = 0x8000 | uint16(e.PolyEdge[1])\n\t\t}\n\n\t}\n\n\treturn true\n}\n"
            },
            "canMerge": {
                "Name": "canMerge",
                "Code": "func canMerge(oldRegId, newRegId uint8, regs []dtLayerMonotoneRegion, nregs int32) bool {\n\tvar count int32\n\tfor i := int32(0); i \u003c nregs; i++ {\n\t\treg := \u0026regs[i]\n\t\tif reg.RegId != oldRegId {\n\t\t\tcontinue\n\t\t}\n\t\tnnei := int32(reg.Nneis)\n\t\tfor j := int32(0); j \u003c nnei; j++ {\n\t\t\tif regs[reg.Neis[j]].RegId == newRegId {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\treturn count == 1\n}\n"
            },
            "canRemoveVertex": {
                "Name": "canRemoveVertex",
                "Code": "func canRemoveVertex(mesh *DtTileCachePolyMesh, rem uint16) bool {\n\t// Count number of polygons to remove.\n\tvar numRemovedVerts, numTouchedVerts, numRemainingEdges int32\n\tfor i := int32(0); i \u003c mesh.Npolys; i++ {\n\t\tp := mesh.Polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tnv := countPolyVerts(p)\n\t\tvar numRemoved, numVerts int32\n\t\tfor j := int32(0); j \u003c nv; j++ {\n\t\t\tif p[j] == rem {\n\t\t\t\tnumTouchedVerts++\n\t\t\t\tnumRemoved++\n\t\t\t}\n\t\t\tnumVerts++\n\t\t}\n\t\tif numRemoved \u003e 0 {\n\t\t\tnumRemovedVerts += numRemoved\n\t\t\tnumRemainingEdges += numVerts - (numRemoved + 1)\n\t\t}\n\t}\n\n\t// There would be too few edges remaining to create a polygon.\n\t// This can happen for example when a tip of a triangle is marked\n\t// as deletion, but there are no other polys that share the vertex.\n\t// In this case, the vertex should not be removed.\n\tif numRemainingEdges \u003c= 2 {\n\t\treturn false\n\t}\n\n\t// Check that there is enough memory for the test.\n\tmaxEdges := numTouchedVerts * 2\n\tif maxEdges \u003e MAX_REM_EDGES {\n\t\treturn false\n\t}\n\n\t// Find edges which share the removed vertex.\n\tvar edges [MAX_REM_EDGES]uint16\n\tvar nedges int32\n\n\tfor i := int32(0); i \u003c mesh.Npolys; i++ {\n\t\tp := mesh.Polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tnv := countPolyVerts(p)\n\n\t\t// Collect edges which touches the removed vertex.\n\t\tfor j, k := int32(0), nv-1; j \u003c nv; k, j = j, j+1 {\n\t\t\tif p[j] == rem || p[k] == rem {\n\t\t\t\t// Arrange edge so that a=rem.\n\t\t\t\ta := p[j]\n\t\t\t\tb := p[k]\n\t\t\t\tif b == rem {\n\t\t\t\t\ta, b = b, a\n\t\t\t\t\t// detour.DtSwapUInt16(\u0026a, \u0026b)\n\t\t\t\t}\n\n\t\t\t\t// Check if the edge exists\n\t\t\t\texists := false\n\t\t\t\tfor m := int32(0); m \u003c nedges; m++ {\n\t\t\t\t\te := edges[m*3:]\n\t\t\t\t\tif e[1] == b {\n\t\t\t\t\t\t// Exists, increment vertex share count.\n\t\t\t\t\t\te[2]++\n\t\t\t\t\t\texists = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Add new edge.\n\t\t\t\tif !exists {\n\t\t\t\t\te := edges[nedges*3:]\n\t\t\t\t\te[0] = uint16(a)\n\t\t\t\t\te[1] = uint16(b)\n\t\t\t\t\te[2] = 1\n\t\t\t\t\tnedges++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// There should be no more than 2 open edges.\n\t// This catches the case that two non-adjacent polygons\n\t// share the removed vertex. In that case, do not remove the vertex.\n\tvar numOpenEdges int32\n\tfor i := int32(0); i \u003c nedges; i++ {\n\t\tif edges[i*3+2] \u003c 2 {\n\t\t\tnumOpenEdges++\n\t\t}\n\t}\n\tif numOpenEdges \u003e 2 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"
            },
            "collinear": {
                "Name": "collinear",
                "Code": "func collinear(a, b, c []uint8) bool {\n\treturn area2(a, b, c) == 0\n}\n"
            },
            "computeTileHash": {
                "Name": "computeTileHash",
                "Code": "func computeTileHash(x, y, mask int32) int32 {\n\th1 := uint32(0x8da6b343) // Large multiplicative constants;\n\th2 := uint32(0xd8163841) // here arbitrarily chosen primes\n\tn := h1*uint32(x) + h2*uint32(y)\n\treturn int32(n \u0026 uint32(mask))\n}\n"
            },
            "computeVertexHash2": {
                "Name": "computeVertexHash2",
                "Code": "func computeVertexHash2(x, y, z int32) int32 {\n\tconst h1 uint32 = 0x8da6b343 // Large multiplicative constants;\n\tconst h2 uint32 = 0xd8163841 // here arbitrarily chosen primes\n\tconst h3 uint32 = 0xcb1ab31f\n\tn := h1*uint32(x) + h2*uint32(y) + h3*uint32(z)\n\treturn int32(n \u0026 uint32(VERTEX_BUCKET_COUNT2-1))\n}\n"
            },
            "contains": {
                "Name": "contains",
                "Code": "func contains(a []DtCompressedTileRef, n int32, v DtCompressedTileRef) bool {\n\tfor i := int32(0); i \u003c n; i++ {\n\t\tif a[i] == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
            },
            "countPolyVerts": {
                "Name": "countPolyVerts",
                "Code": "func countPolyVerts(p []uint16) int32 {\n\tfor i := int32(0); i \u003c MAX_VERTS_PER_POLY; i++ {\n\t\tif p[i] == DT_TILECACHE_NULL_IDX {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn MAX_VERTS_PER_POLY\n}\n"
            },
            "diagonal": {
                "Name": "diagonal",
                "Code": "func diagonal(i, j, n int32, verts []uint8, indices []uint16) bool {\n\treturn inCone(i, j, n, verts, indices) \u0026\u0026 diagonalie(i, j, n, verts, indices)\n}\n"
            },
            "diagonalie": {
                "Name": "diagonalie",
                "Code": "func diagonalie(i, j, n int32, verts []uint8, indices []uint16) bool {\n\td0 := verts[(indices[i]\u00260x7fff)*4:]\n\td1 := verts[(indices[j]\u00260x7fff)*4:]\n\n\t// For each edge (k,k+1) of P\n\tfor k := int32(0); k \u003c n; k++ {\n\t\tk1 := next(k, n)\n\t\t// Skip edges incident to i or j\n\t\tif !((k == i) || (k1 == i) || (k == j) || (k1 == j)) {\n\t\t\tp0 := verts[(indices[k]\u00260x7fff)*4:]\n\t\t\tp1 := verts[(indices[k1]\u00260x7fff)*4:]\n\n\t\t\tif vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif intersect(d0, d1, p0, p1) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n"
            },
            "distancePtSeg": {
                "Name": "distancePtSeg",
                "Code": "func distancePtSeg(x, z, px, pz, qx, qz int32) float32 {\n\tpqx := float32(qx - px)\n\tpqz := float32(qz - pz)\n\tdx := float32(x - px)\n\tdz := float32(z - pz)\n\td := float32(pqx*pqx + pqz*pqz)\n\tt := float32(pqx*dx + pqz*dz)\n\tif d \u003e 0 {\n\t\tt /= d\n\t}\n\tif t \u003c 0 {\n\t\tt = 0\n\t} else if t \u003e 1 {\n\t\tt = 1\n\t}\n\n\tdx = float32(px) + t*pqx - float32(x)\n\tdz = float32(pz) + t*pqz - float32(z)\n\n\treturn dx*dx + dz*dz\n}\n"
            },
            "getCornerHeight": {
                "Name": "getCornerHeight",
                "Code": "func getCornerHeight(layer *DtTileCacheLayer, x, y, z, walkableClimb int32, shouldRemove *bool) uint8 {\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\n\tvar n int32\n\n\tportal := uint8(0xf)\n\theight := uint8(0)\n\tpreg := uint8(0xff)\n\tallSameReg := true\n\n\tfor dz := int32(-1); dz \u003c= 0; dz++ {\n\t\tfor dx := int32(-1); dx \u003c= 0; dx++ {\n\t\t\tpx := x + dx\n\t\t\tpz := z + dz\n\t\t\tif px \u003e= 0 \u0026\u0026 pz \u003e= 0 \u0026\u0026 px \u003c w \u0026\u0026 pz \u003c h {\n\t\t\t\tidx := px + pz*w\n\t\t\t\tlh := int32(layer.Heights[idx])\n\t\t\t\tif detour.DtAbsInt32(lh-y) \u003c= walkableClimb \u0026\u0026 layer.Areas[idx] != DT_TILECACHE_NULL_AREA {\n\t\t\t\t\theight = detour.DtMaxUInt8(height, uint8(lh))\n\t\t\t\t\tportal \u0026= (layer.Cons[idx] \u003e\u003e 4)\n\t\t\t\t\tif preg != 0xff \u0026\u0026 preg != layer.Regs[idx] {\n\t\t\t\t\t\tallSameReg = false\n\t\t\t\t\t}\n\t\t\t\t\tpreg = layer.Regs[idx]\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar portalCount int32\n\tfor dir := uint32(0); dir \u003c 4; dir++ {\n\t\tif (portal \u0026 (1 \u003c\u003c dir)) != 0 {\n\t\t\tportalCount++\n\t\t}\n\t}\n\n\t*shouldRemove = false\n\tif n \u003e 1 \u0026\u0026 portalCount == 1 \u0026\u0026 allSameReg {\n\t\t*shouldRemove = true\n\t}\n\n\treturn height\n}\n"
            },
            "getDirOffsetX": {
                "Name": "getDirOffsetX",
                "Code": "func getDirOffsetX(dir int32) int32 {\n\treturn offsetX[dir\u00260x03]\n}\n"
            },
            "getDirOffsetY": {
                "Name": "getDirOffsetY",
                "Code": "func getDirOffsetY(dir int32) int32 {\n\treturn offsetY[dir\u00260x03]\n}\n"
            },
            "getNeighbourReg": {
                "Name": "getNeighbourReg",
                "Code": "func getNeighbourReg(layer *DtTileCacheLayer, ax, ay, dir int32) uint8 {\n\tw := int32(layer.Header.Width)\n\tia := ax + ay*w\n\n\tcon := layer.Cons[ia] \u0026 0xf\n\tportal := layer.Cons[ia] \u003e\u003e 4\n\tmask := uint8(1 \u003c\u003c uint32(dir))\n\n\tif (con \u0026 mask) == 0 {\n\t\t// No connection, return portal or hard edge.\n\t\tif portal\u0026mask \u003e 0 {\n\t\t\treturn 0xf8 + uint8(dir)\n\t\t}\n\t\treturn 0xff\n\t}\n\n\tbx := ax + getDirOffsetX(dir)\n\tby := ay + getDirOffsetY(dir)\n\tib := bx + by*w\n\n\treturn layer.Regs[ib]\n}\n"
            },
            "getPolyMergeValue": {
                "Name": "getPolyMergeValue",
                "Code": "func getPolyMergeValue(pa, pb, verts []uint16, ea, eb *int32) int32 {\n\tna := countPolyVerts(pa)\n\tnb := countPolyVerts(pb)\n\n\t// If the merged polygon would be too big, do not merge.\n\tif na+nb-2 \u003e MAX_VERTS_PER_POLY {\n\t\treturn -1\n\t}\n\n\t// Check if the polygons share an edge.\n\t*ea = -1\n\t*eb = -1\n\n\tfor i := int32(0); i \u003c na; i++ {\n\t\tva0 := pa[i]\n\t\tva1 := pa[(i+1)%na]\n\t\tif va0 \u003e va1 {\n\t\t\tva0, va1 = va1, va0\n\t\t\t// detour.DtSwapUInt16(\u0026va0, \u0026va1)\n\t\t}\n\t\tfor j := int32(0); j \u003c nb; j++ {\n\t\t\tvb0 := pb[j]\n\t\t\tvb1 := pb[(j+1)%nb]\n\t\t\tif vb0 \u003e vb1 {\n\t\t\t\tvb0, vb1 = vb1, vb0\n\t\t\t\t// detour.DtSwapUInt16(\u0026vb0, \u0026vb1)\n\t\t\t}\n\t\t\tif va0 == vb0 \u0026\u0026 va1 == vb1 {\n\t\t\t\t*ea = i\n\t\t\t\t*eb = j\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// No common edge, cannot merge.\n\tif *ea == -1 || *eb == -1 {\n\t\treturn -1\n\t}\n\n\t// Check to see if the merged polygon would be convex.\n\tvar va, vb, vc uint16\n\n\tva = pa[(*ea+na-1)%na]\n\tvb = pa[*ea]\n\tvc = pb[(*eb+2)%nb]\n\tif !uleft(verts[va*3:], verts[vb*3:], verts[vc*3:]) {\n\t\treturn -1\n\t}\n\n\tva = pb[(*eb+nb-1)%nb]\n\tvb = pb[*eb]\n\tvc = pa[(*ea+2)%na]\n\tif !uleft(verts[va*3:], verts[vb*3:], verts[vc*3:]) {\n\t\treturn -1\n\t}\n\n\tva = pa[*ea]\n\tvb = pa[(*ea+1)%na]\n\n\tdx := int32(verts[va*3+0]) - int32(verts[vb*3+0])\n\tdy := int32(verts[va*3+2]) - int32(verts[vb*3+2])\n\n\treturn dx*dx + dy*dy\n}\n"
            },
            "inCone": {
                "Name": "inCone",
                "Code": "func inCone(i, j, n int32, verts []uint8, indices []uint16) bool {\n\tpi := verts[(indices[i]\u00260x7fff)*4:]\n\tpj := verts[(indices[j]\u00260x7fff)*4:]\n\tpi1 := verts[(indices[next(i, n)]\u00260x7fff)*4:]\n\tpin1 := verts[(indices[prev(i, n)]\u00260x7fff)*4:]\n\n\t// If P[i] is a convex vertex [ i+1 left or on (i-1,i) ].\n\tif leftOn(pin1, pi, pi1) {\n\t\treturn left(pi, pj, pin1) \u0026\u0026 left(pj, pi, pi1)\n\t}\n\t// Assume (i-1,i,i+1) not collinear.\n\t// else P[i] is reflex.\n\treturn !(leftOn(pi, pj, pi1) \u0026\u0026 leftOn(pj, pi, pin1))\n}\n"
            },
            "intersect": {
                "Name": "intersect",
                "Code": "func intersect(a, b, c, d []uint8) bool {\n\tif intersectProp(a, b, c, d) {\n\t\treturn true\n\t} else if between(a, b, c) || between(a, b, d) ||\n\t\tbetween(c, d, a) || between(c, d, b) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n"
            },
            "intersectProp": {
                "Name": "intersectProp",
                "Code": "func intersectProp(a, b, c, d []uint8) bool {\n\t// Eliminate improper cases.\n\tif collinear(a, b, c) || collinear(a, b, d) ||\n\t\tcollinear(c, d, a) || collinear(c, d, b) {\n\t\treturn false\n\t}\n\n\treturn xorb(left(a, b, c), left(a, b, d)) \u0026\u0026 xorb(left(c, d, a), left(c, d, b))\n}\n"
            },
            "isConnected": {
                "Name": "isConnected",
                "Code": "func isConnected(layer *DtTileCacheLayer, ia, ib, walkableClimb int32) bool {\n\tif layer.Areas[ia] != layer.Areas[ib] {\n\t\treturn false\n\t}\n\tif detour.DtAbsInt32(int32(layer.Heights[ia])-int32(layer.Heights[ib])) \u003e walkableClimb {\n\t\treturn false\n\t}\n\treturn true\n}\n"
            },
            "left": {
                "Name": "left",
                "Code": "func left(a, b, c []uint8) bool {\n\treturn area2(a, b, c) \u003c 0\n}\n"
            },
            "leftOn": {
                "Name": "leftOn",
                "Code": "func leftOn(a, b, c []uint8) bool {\n\treturn area2(a, b, c) \u003c= 0\n}\n"
            },
            "mergePolys": {
                "Name": "mergePolys",
                "Code": "func mergePolys(pa, pb []uint16, ea, eb int32) {\n\tvar tmp [MAX_VERTS_PER_POLY * 2]uint16\n\n\tna := countPolyVerts(pa)\n\tnb := countPolyVerts(pb)\n\n\t// Merge polygons.\n\tdetour.Memset(uintptr(unsafe.Pointer(\u0026tmp[0])), 0xff, int(MAX_VERTS_PER_POLY*2))\n\n\tvar n int32\n\t// Add pa\n\tfor i := int32(0); i \u003c na-1; i++ {\n\t\ttmp[n] = pa[(ea+1+i)%na]\n\t\tn++\n\t}\n\t// Add pb\n\tfor i := int32(0); i \u003c nb-1; i++ {\n\t\ttmp[n] = pb[(eb+1+i)%nb]\n\t\tn++\n\t}\n\n\tcopy(pa, tmp[:MAX_VERTS_PER_POLY])\n}\n"
            },
            "next": {
                "Name": "next",
                "Code": "func next(i, n int32) int32 {\n\tif i+1 \u003c n {\n\t\treturn i + 1\n\t}\n\treturn 0\n}\n"
            },
            "overlapRangeExl": {
                "Name": "overlapRangeExl",
                "Code": "func overlapRangeExl(amin, amax, bmin, bmax uint16) bool {\n\tif amin \u003e= bmax || amax \u003c= bmin {\n\t\treturn false\n\t}\n\treturn true\n}\n"
            },
            "prev": {
                "Name": "prev",
                "Code": "func prev(i, n int32) int32 {\n\tif i-1 \u003e= 0 {\n\t\treturn i - 1\n\t}\n\treturn n - 1\n}\n"
            },
            "pushBack": {
                "Name": "pushBack",
                "Code": "func pushBack(v uint16, arr []uint16, an *int32) {\n\tarr[*an] = v\n\t*an++\n}\n"
            },
            "pushFront": {
                "Name": "pushFront",
                "Code": "func pushFront(v uint16, arr []uint16, an *int32) {\n\t*an++\n\tfor i := *an - 1; i \u003e 0; i-- {\n\t\tarr[i] = arr[i-1]\n\t}\n\tarr[0] = v\n}\n"
            },
            "removeVertex": {
                "Name": "removeVertex",
                "Code": "func removeVertex(mesh *DtTileCachePolyMesh, rem uint16, maxTris int32) detour.DtStatus {\n\t// Count number of polygons to remove.\n\tvar numRemovedVerts int32\n\tfor i := int32(0); i \u003c mesh.Npolys; i++ {\n\t\tp := mesh.Polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tnv := countPolyVerts(p)\n\t\tfor j := int32(0); j \u003c nv; j++ {\n\t\t\tif p[j] == rem {\n\t\t\t\tnumRemovedVerts++\n\t\t\t}\n\t\t}\n\t}\n\n\tvar nedges, nhole, nharea int32\n\tvar edges [MAX_REM_EDGES * 3]uint16\n\tvar hole, harea [MAX_REM_EDGES]uint16\n\n\tfor i := int32(0); i \u003c mesh.Npolys; i++ {\n\t\tp := mesh.Polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tnv := countPolyVerts(p)\n\t\thasRem := false\n\t\tfor j := int32(0); j \u003c nv; j++ {\n\t\t\tif p[j] == rem {\n\t\t\t\thasRem = true\n\t\t\t}\n\t\t}\n\t\tif hasRem {\n\t\t\t// Collect edges which does not touch the removed vertex.\n\t\t\tfor j, k := int32(0), nv-1; j \u003c nv; k, j = j, j+1 {\n\t\t\t\tif p[j] != rem \u0026\u0026 p[k] != rem {\n\t\t\t\t\tif nedges \u003e= MAX_REM_EDGES {\n\t\t\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t\t\t}\n\t\t\t\t\te := edges[nedges*3:]\n\t\t\t\t\te[0] = p[k]\n\t\t\t\t\te[1] = p[j]\n\t\t\t\t\te[2] = uint16(mesh.Areas[i])\n\t\t\t\t\tnedges++\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remove the polygon.\n\t\t\tp2 := mesh.Polys[(mesh.Npolys-1)*MAX_VERTS_PER_POLY*2:]\n\t\t\tcopy(p, p2[:MAX_VERTS_PER_POLY])\n\t\t\tdetour.Memset(uintptr(unsafe.Pointer(\u0026p[MAX_VERTS_PER_POLY])), 0xff, ShortSize*int(MAX_VERTS_PER_POLY))\n\n\t\t\tmesh.Areas[i] = mesh.Areas[mesh.Npolys-1]\n\t\t\tmesh.Npolys--\n\t\t\ti--\n\t\t}\n\t}\n\n\t// Remove vertex.\n\tfor i := int32(rem); i \u003c mesh.Nverts; i++ {\n\t\tmesh.Verts[i*3+0] = mesh.Verts[(i+1)*3+0]\n\t\tmesh.Verts[i*3+1] = mesh.Verts[(i+1)*3+1]\n\t\tmesh.Verts[i*3+2] = mesh.Verts[(i+1)*3+2]\n\t}\n\tmesh.Nverts--\n\n\t// Adjust indices to match the removed vertex layout.\n\tfor i := int32(0); i \u003c mesh.Npolys; i++ {\n\t\tp := mesh.Polys[i*MAX_VERTS_PER_POLY*2:]\n\t\tnv := countPolyVerts(p)\n\t\tfor j := int32(0); j \u003c nv; j++ {\n\t\t\tif p[j] \u003e rem {\n\t\t\t\tp[j]--\n\t\t\t}\n\t\t}\n\t}\n\tfor i := int32(0); i \u003c nedges; i++ {\n\t\tif edges[i*3+0] \u003e rem {\n\t\t\tedges[i*3+0]--\n\t\t}\n\t\tif edges[i*3+1] \u003e rem {\n\t\t\tedges[i*3+1]--\n\t\t}\n\t}\n\n\tif nedges == 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\n\t// Start with one vertex, keep appending connected\n\t// segments to the start and end of the hole.\n\tpushBack(edges[0], hole[:], \u0026nhole)\n\tpushBack(edges[2], harea[:], \u0026nharea)\n\n\tfor nedges != 0 {\n\t\tmatch := false\n\n\t\tfor i := int32(0); i \u003c nedges; i++ {\n\t\t\tea := edges[i*3+0]\n\t\t\teb := edges[i*3+1]\n\t\t\ta := edges[i*3+2]\n\t\t\tadd := false\n\t\t\tif hole[0] == eb {\n\t\t\t\t// The segment matches the beginning of the hole boundary.\n\t\t\t\tif nhole \u003e= MAX_REM_EDGES {\n\t\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t\tpushFront(ea, hole[:], \u0026nhole)\n\t\t\t\tpushFront(a, harea[:], \u0026nharea)\n\t\t\t\tadd = true\n\t\t\t} else if hole[nhole-1] == ea {\n\t\t\t\t// The segment matches the end of the hole boundary.\n\t\t\t\tif nhole \u003e= MAX_REM_EDGES {\n\t\t\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t\t\t}\n\t\t\t\tpushBack(eb, hole[:], \u0026nhole)\n\t\t\t\tpushBack(a, harea[:], \u0026nharea)\n\t\t\t\tadd = true\n\t\t\t}\n\t\t\tif add {\n\t\t\t\t// The edge segment was added, remove it.\n\t\t\t\tedges[i*3+0] = edges[(nedges-1)*3+0]\n\t\t\t\tedges[i*3+1] = edges[(nedges-1)*3+1]\n\t\t\t\tedges[i*3+2] = edges[(nedges-1)*3+2]\n\t\t\t\tnedges--\n\t\t\t\tmatch = true\n\t\t\t\ti--\n\t\t\t}\n\t\t}\n\n\t\tif !match {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar tris [MAX_REM_EDGES * 3]uint16\n\tvar tverts [MAX_REM_EDGES * 3]uint8\n\tvar tpoly [MAX_REM_EDGES * 3]uint16\n\n\t// Generate temp vertex array for triangulation.\n\tfor i := int32(0); i \u003c nhole; i++ {\n\t\tpi := hole[i]\n\t\ttverts[i*4+0] = uint8(mesh.Verts[pi*3+0])\n\t\ttverts[i*4+1] = uint8(mesh.Verts[pi*3+1])\n\t\ttverts[i*4+2] = uint8(mesh.Verts[pi*3+2])\n\t\ttverts[i*4+3] = 0\n\t\ttpoly[i] = uint16(i)\n\t}\n\n\t// Triangulate the hole.\n\tntris := triangulate(nhole, tverts[:], tpoly[:], tris[:])\n\tif ntris \u003c 0 {\n\t\t// TODO: issue warning!\n\t\tntris = -ntris\n\t}\n\n\tif ntris \u003e MAX_REM_EDGES {\n\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t}\n\n\tvar polys [MAX_REM_EDGES * MAX_VERTS_PER_POLY]uint16\n\tvar pareas [MAX_REM_EDGES]uint8\n\n\t// Build initial polygons.\n\tvar npolys int32\n\tdetour.Memset(uintptr(unsafe.Pointer(\u0026polys[0])), 0xff, int(ntris*MAX_VERTS_PER_POLY)*ShortSize)\n\tfor j := int32(0); j \u003c ntris; j++ {\n\t\tt := tris[j*3:]\n\t\tif t[0] != t[1] \u0026\u0026 t[0] != t[2] \u0026\u0026 t[1] != t[2] {\n\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+0] = hole[t[0]]\n\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+1] = hole[t[1]]\n\t\t\tpolys[npolys*MAX_VERTS_PER_POLY+2] = hole[t[2]]\n\t\t\tpareas[npolys] = uint8(harea[t[0]])\n\t\t\tnpolys++\n\t\t}\n\t}\n\tif npolys == 0 {\n\t\treturn detour.DT_SUCCESS\n\t}\n\n\t// Merge polygons.\n\tvar maxVertsPerPoly int32 = MAX_VERTS_PER_POLY\n\tif maxVertsPerPoly \u003e 3 {\n\t\tfor {\n\t\t\t// Find best polygons to merge.\n\t\t\tvar bestMergeVal, bestPa, bestPb, bestEa, bestEb int32\n\n\t\t\tfor j := int32(0); j \u003c npolys-1; j++ {\n\t\t\t\tpj := polys[j*MAX_VERTS_PER_POLY:]\n\t\t\t\tfor k := j + 1; k \u003c npolys; k++ {\n\t\t\t\t\tpk := polys[k*MAX_VERTS_PER_POLY:]\n\t\t\t\t\tvar ea, eb int32\n\t\t\t\t\tv := getPolyMergeValue(pj, pk, mesh.Verts, \u0026ea, \u0026eb)\n\t\t\t\t\tif v \u003e bestMergeVal {\n\t\t\t\t\t\tbestMergeVal = v\n\t\t\t\t\t\tbestPa = j\n\t\t\t\t\t\tbestPb = k\n\t\t\t\t\t\tbestEa = ea\n\t\t\t\t\t\tbestEb = eb\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif bestMergeVal \u003e 0 {\n\t\t\t\t// Found best, merge.\n\t\t\t\tpa := polys[bestPa*MAX_VERTS_PER_POLY:]\n\t\t\t\tpb := polys[bestPb*MAX_VERTS_PER_POLY:]\n\t\t\t\tmergePolys(pa, pb, bestEa, bestEb)\n\t\t\t\tcopy(pb, polys[(npolys-1)*MAX_VERTS_PER_POLY:(npolys-1)*MAX_VERTS_PER_POLY+MAX_VERTS_PER_POLY])\n\t\t\t\tpareas[bestPb] = pareas[npolys-1]\n\t\t\t\tnpolys--\n\t\t\t} else {\n\t\t\t\t// Could not merge any polygons, stop.\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Store polygons.\n\tfor i := int32(0); i \u003c npolys; i++ {\n\t\tif mesh.Npolys \u003e= maxTris {\n\t\t\tbreak\n\t\t}\n\t\tp := mesh.Polys[mesh.Npolys*MAX_VERTS_PER_POLY*2:]\n\t\tdetour.Memset(uintptr(unsafe.Pointer(\u0026p[0])), 0xff, ShortSize*int(MAX_VERTS_PER_POLY*2))\n\t\tfor j := int32(0); j \u003c MAX_VERTS_PER_POLY; j++ {\n\t\t\tp[j] = polys[i*MAX_VERTS_PER_POLY+j]\n\t\t}\n\t\tmesh.Areas[mesh.Npolys] = pareas[i]\n\t\tmesh.Npolys++\n\t\tif mesh.Npolys \u003e maxTris {\n\t\t\treturn detour.DT_FAILURE | detour.DT_BUFFER_TOO_SMALL\n\t\t}\n\t}\n\n\treturn detour.DT_SUCCESS\n}\n"
            },
            "simplifyContour": {
                "Name": "simplifyContour",
                "Code": "func simplifyContour(cont *dtTempContour, maxError float32) {\n\tcont.Npoly = 0\n\n\tfor i := int32(0); i \u003c cont.Nverts; i++ {\n\t\tj := (i + 1) % cont.Nverts\n\t\t// Check for start of a wall segment.\n\t\tra := cont.Verts[j*4+3]\n\t\trb := cont.Verts[i*4+3]\n\t\tif ra != rb {\n\t\t\tcont.Poly[cont.Npoly] = uint16(i)\n\t\t\tcont.Npoly++\n\t\t}\n\t}\n\tif cont.Npoly \u003c 2 {\n\t\t// If there is no transitions at all,\n\t\t// create some initial points for the simplification process.\n\t\t// Find lower-left and upper-right vertices of the contour.\n\t\tllx := cont.Verts[0]\n\t\tllz := cont.Verts[2]\n\t\tlli := int32(0)\n\t\turx := cont.Verts[0]\n\t\turz := cont.Verts[2]\n\t\turi := int32(0)\n\t\tfor i := int32(1); i \u003c cont.Nverts; i++ {\n\t\t\tx := cont.Verts[i*4+0]\n\t\t\tz := cont.Verts[i*4+2]\n\t\t\tif x \u003c llx || (x == llx \u0026\u0026 z \u003c llz) {\n\t\t\t\tllx = x\n\t\t\t\tllz = z\n\t\t\t\tlli = i\n\t\t\t}\n\t\t\tif x \u003e urx || (x == urx \u0026\u0026 z \u003e urz) {\n\t\t\t\turx = x\n\t\t\t\turz = z\n\t\t\t\turi = i\n\t\t\t}\n\t\t}\n\t\tcont.Npoly = 0\n\t\tcont.Poly[cont.Npoly] = uint16(lli)\n\t\tcont.Npoly++\n\t\tcont.Poly[cont.Npoly] = uint16(uri)\n\t\tcont.Npoly++\n\t}\n\n\t// Add points until all raw points are within\n\t// error tolerance to the simplified shape.\n\tfor i := int32(0); i \u003c cont.Npoly; {\n\t\tii := (i + 1) % cont.Npoly\n\n\t\tai := int32(cont.Poly[i])\n\t\tax := int32(cont.Verts[ai*4+0])\n\t\taz := int32(cont.Verts[ai*4+2])\n\n\t\tbi := int32(cont.Poly[ii])\n\t\tbx := int32(cont.Verts[bi*4+0])\n\t\tbz := int32(cont.Verts[bi*4+2])\n\n\t\t// Find maximum deviation from the segment.\n\t\tvar maxd float32\n\t\tmaxi := int32(-1)\n\t\tvar ci, cinc, endi int32\n\n\t\t// Traverse the segment in lexilogical order so that the\n\t\t// max deviation is calculated similarly when traversing\n\t\t// opposite segments.\n\t\tif bx \u003e ax || (bx == ax \u0026\u0026 bz \u003e az) {\n\t\t\tcinc = 1\n\t\t\tci = (ai + cinc) % cont.Nverts\n\t\t\tendi = bi\n\t\t} else {\n\t\t\tcinc = cont.Nverts - 1\n\t\t\tci = (bi + cinc) % cont.Nverts\n\t\t\tendi = ai\n\t\t}\n\n\t\t// Tessellate only outer edges or edges between areas.\n\t\tfor ci != endi {\n\t\t\td := distancePtSeg(int32(cont.Verts[ci*4+0]), int32(cont.Verts[ci*4+2]), ax, az, bx, bz)\n\t\t\tif d \u003e maxd {\n\t\t\t\tmaxd = d\n\t\t\t\tmaxi = ci\n\t\t\t}\n\t\t\tci = (ci + cinc) % cont.Nverts\n\t\t}\n\n\t\t// If the max deviation is larger than accepted error,\n\t\t// add new point, else continue to next segment.\n\t\tif maxi != -1 \u0026\u0026 maxd \u003e (maxError*maxError) {\n\t\t\tcont.Npoly++\n\t\t\tfor j := cont.Npoly - 1; j \u003e i; j-- {\n\t\t\t\tcont.Poly[j] = cont.Poly[j-1]\n\t\t\t}\n\t\t\tcont.Poly[i+1] = uint16(maxi)\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\n\t// Remap vertices\n\tvar start int32\n\tfor i := int32(1); i \u003c cont.Npoly; i++ {\n\t\tif cont.Poly[i] \u003c cont.Poly[start] {\n\t\t\tstart = i\n\t\t}\n\t}\n\n\tcont.Nverts = 0\n\tfor i := int32(0); i \u003c cont.Npoly; i++ {\n\t\tj := (start + i) % cont.Npoly\n\t\tsrc := cont.Verts[cont.Poly[j]*4:]\n\t\tdst := cont.Verts[cont.Nverts*4:]\n\t\tdst[0] = src[0]\n\t\tdst[1] = src[1]\n\t\tdst[2] = src[2]\n\t\tdst[3] = src[3]\n\t\tcont.Nverts++\n\t}\n}\n"
            },
            "triangulate": {
                "Name": "triangulate",
                "Code": "func triangulate(n int32, verts []uint8, indices, tris []uint16) int32 {\n\tvar ntris int32\n\tdst := tris[:]\n\n\t// The last bit of the index is used to indicate if the vertex can be removed.\n\tfor i := int32(0); i \u003c n; i++ {\n\t\ti1 := next(i, n)\n\t\ti2 := next(i1, n)\n\t\tif diagonal(i, i2, n, verts, indices) {\n\t\t\tindices[i1] |= 0x8000\n\t\t}\n\t}\n\n\tfor n \u003e 3 {\n\t\tminLen := int32(-1)\n\t\tmini := int32(-1)\n\t\tfor i := int32(0); i \u003c n; i++ {\n\t\t\ti1 := next(i, n)\n\t\t\tif indices[i1]\u00260x8000 \u003e 0 {\n\t\t\t\tp0 := verts[(indices[i]\u00260x7fff)*4:]\n\t\t\t\tp2 := verts[(indices[next(i1, n)]\u00260x7fff)*4:]\n\n\t\t\t\tdx := int32(p2[0]) - int32(p0[0])\n\t\t\t\tdz := int32(p2[2]) - int32(p0[2])\n\t\t\t\tlen := dx*dx + dz*dz\n\t\t\t\tif minLen \u003c 0 || len \u003c minLen {\n\t\t\t\t\tminLen = len\n\t\t\t\t\tmini = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif mini == -1 {\n\t\t\t// Should not happen.\n\t\t\t/*\t\t\tprintf(\"mini == -1 ntris=%d n=%d\\n\", ntris, n);\n\t\t\t\t\t\tfor (int i = 0; i \u003c n; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \", indices[i] \u0026 0x0fffffff);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t\treturn -ntris\n\t\t}\n\n\t\ti := mini\n\t\ti1 := next(i, n)\n\t\ti2 := next(i1, n)\n\n\t\tdst[0] = indices[i] \u0026 0x7fff\n\t\tdst[1] = indices[i1] \u0026 0x7fff\n\t\tdst[2] = indices[i2] \u0026 0x7fff\n\t\tdst = dst[3:]\n\t\tntris++\n\n\t\t// Removes P[i1] by copying P[i+1]...P[n-1] left one index.\n\t\tn--\n\t\tfor k := i1; k \u003c n; k++ {\n\t\t\tindices[k] = indices[k+1]\n\t\t}\n\n\t\tif i1 \u003e= n {\n\t\t\ti1 = 0\n\t\t}\n\t\ti = prev(i1, n)\n\t\t// Update diagonal flags.\n\t\tif diagonal(prev(i, n), i1, n, verts, indices) {\n\t\t\tindices[i] |= 0x8000\n\t\t} else {\n\t\t\tindices[i] \u0026= 0x7fff\n\t\t}\n\n\t\tif diagonal(i, next(i1, n), n, verts, indices) {\n\t\t\tindices[i1] |= 0x8000\n\t\t} else {\n\t\t\tindices[i1] \u0026= 0x7fff\n\t\t}\n\t}\n\n\t// Append the remaining triangle.\n\tdst[0] = indices[0] \u0026 0x7fff\n\tdst[1] = indices[1] \u0026 0x7fff\n\tdst[2] = indices[2] \u0026 0x7fff\n\tdst = dst[3:]\n\tntris++\n\n\treturn ntris\n}\n"
            },
            "uleft": {
                "Name": "uleft",
                "Code": "func uleft(a, b, c []uint16) bool {\n\treturn (int32(b[0])-int32(a[0]))*(int32(c[2])-int32(a[2]))-(int32(c[0])-int32(a[0]))*(int32(b[2])-int32(a[2])) \u003c 0\n}\n"
            },
            "vequal": {
                "Name": "vequal",
                "Code": "func vequal(a, b []uint8) bool {\n\treturn a[0] == b[0] \u0026\u0026 a[2] == b[2]\n}\n"
            },
            "walkContour": {
                "Name": "walkContour",
                "Code": "func walkContour(layer *DtTileCacheLayer, x, y int32, cont *dtTempContour) bool {\n\tw := int32(layer.Header.Width)\n\th := int32(layer.Header.Height)\n\n\tcont.Nverts = 0\n\n\tstartX := x\n\tstartY := y\n\tstartDir := int32(-1)\n\n\tfor i := int32(0); i \u003c 4; i++ {\n\t\tdir := (i + 3) \u0026 3\n\t\trn := getNeighbourReg(layer, x, y, dir)\n\t\tif rn != layer.Regs[x+y*w] {\n\t\t\tstartDir = dir\n\t\t\tbreak\n\t\t}\n\t}\n\tif startDir == -1 {\n\t\treturn true\n\t}\n\n\tdir := startDir\n\tmaxIter := w * h\n\n\tvar iter int32\n\tfor iter \u003c maxIter {\n\t\trn := getNeighbourReg(layer, x, y, dir)\n\n\t\tnx := x\n\t\tny := y\n\t\tndir := dir\n\n\t\tif rn != layer.Regs[x+y*w] {\n\t\t\t// Solid edge.\n\t\t\tpx := x\n\t\t\tpz := y\n\t\t\tswitch dir {\n\t\t\tcase 0:\n\t\t\t\tpz++\n\t\t\tcase 1:\n\t\t\t\tpx++\n\t\t\t\tpz++\n\t\t\tcase 2:\n\t\t\t\tpx++\n\t\t\t}\n\n\t\t\t// Try to merge with previous vertex.\n\t\t\tif !appendVertex(cont, px, int32(layer.Heights[x+y*w]), pz, int32(rn)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tndir = (dir + 1) \u0026 0x3 // Rotate CW\n\t\t} else {\n\t\t\t// Move to next.\n\t\t\tnx = x + getDirOffsetX(dir)\n\t\t\tny = y + getDirOffsetY(dir)\n\t\t\tndir = (dir + 3) \u0026 0x3 // Rotate CCW\n\t\t}\n\n\t\tif iter \u003e 0 \u0026\u0026 x == startX \u0026\u0026 y == startY \u0026\u0026 dir == startDir {\n\t\t\tbreak\n\t\t}\n\n\t\tx = nx\n\t\ty = ny\n\t\tdir = ndir\n\n\t\titer++\n\t}\n\n\t// Remove last vertex if it is duplicate of the first one.\n\tpa := cont.Verts[(cont.Nverts-1)*4:]\n\tpb := cont.Verts[0:]\n\tif pa[0] == pb[0] \u0026\u0026 pa[2] == pb[2] {\n\t\tcont.Nverts--\n\t}\n\n\treturn true\n}\n"
            },
            "xorb": {
                "Name": "xorb",
                "Code": "func xorb(x, y bool) bool {\n\t//return !x ^ !y;\n\tif x == y {\n\t\treturn false\n\t}\n\treturn true\n}\n"
            }
        }
    }
]